{"version":3,"file":"index.js","mappings":"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","sources":["webpack://spectrumChartsVegaSpecBuilder/webpack/universalModuleDefinition","webpack://spectrumChartsVegaSpecBuilder/../../node_modules/deepmerge/dist/cjs.js","webpack://spectrumChartsVegaSpecBuilder/../../node_modules/immer/dist/cjs/immer.cjs.production.js","webpack://spectrumChartsVegaSpecBuilder/../../node_modules/immer/dist/cjs/index.js","webpack://spectrumChartsVegaSpecBuilder/./src/area/areaSpecBuilder.ts","webpack://spectrumChartsVegaSpecBuilder/./src/area/areaUtils.ts","webpack://spectrumChartsVegaSpecBuilder/./src/axis/axisLabelUtils.ts","webpack://spectrumChartsVegaSpecBuilder/./src/axis/axisReferenceLineUtils.ts","webpack://spectrumChartsVegaSpecBuilder/./src/axis/axisSpecBuilder.ts","webpack://spectrumChartsVegaSpecBuilder/./src/axis/axisTrellisUtils.ts","webpack://spectrumChartsVegaSpecBuilder/./src/axis/axisUtils.ts","webpack://spectrumChartsVegaSpecBuilder/./src/axisAnnotation/axisAnnotationUtils.ts","webpack://spectrumChartsVegaSpecBuilder/./src/bar/barAnnotationUtils.ts","webpack://spectrumChartsVegaSpecBuilder/./src/bar/barSpecBuilder.ts","webpack://spectrumChartsVegaSpecBuilder/./src/bar/barUtils.ts","webpack://spectrumChartsVegaSpecBuilder/./src/bar/dodgedBarUtils.ts","webpack://spectrumChartsVegaSpecBuilder/./src/bar/stackedBarUtils.ts","webpack://spectrumChartsVegaSpecBuilder/./src/bar/trellisedBarUtils.ts","webpack://spectrumChartsVegaSpecBuilder/./src/bullet/bulletDataUtils.ts","webpack://spectrumChartsVegaSpecBuilder/./src/bullet/bulletMarkUtils.ts","webpack://spectrumChartsVegaSpecBuilder/./src/bullet/bulletSpecBuilder.ts","webpack://spectrumChartsVegaSpecBuilder/./src/chartPopover/chartPopoverUtils.ts","webpack://spectrumChartsVegaSpecBuilder/./src/chartSpecBuilder.ts","webpack://spectrumChartsVegaSpecBuilder/./src/chartTooltip/chartTooltipUtils.ts","webpack://spectrumChartsVegaSpecBuilder/./src/combo/comboSpecBuilder.ts","webpack://spectrumChartsVegaSpecBuilder/./src/data/dataUtils.ts","webpack://spectrumChartsVegaSpecBuilder/./src/donut/donutSpecBuilder.ts","webpack://spectrumChartsVegaSpecBuilder/./src/donut/donutSummaryUtils.ts","webpack://spectrumChartsVegaSpecBuilder/./src/donut/donutUtils.ts","webpack://spectrumChartsVegaSpecBuilder/./src/donut/segmentLabelUtils.ts","webpack://spectrumChartsVegaSpecBuilder/./src/index.ts","webpack://spectrumChartsVegaSpecBuilder/./src/legend/legendFacetUtils.ts","webpack://spectrumChartsVegaSpecBuilder/./src/legend/legendHighlightUtils.ts","webpack://spectrumChartsVegaSpecBuilder/./src/legend/legendSpecBuilder.ts","webpack://spectrumChartsVegaSpecBuilder/./src/legend/legendUtils.ts","webpack://spectrumChartsVegaSpecBuilder/./src/line/lineDataUtils.ts","webpack://spectrumChartsVegaSpecBuilder/./src/line/lineMarkUtils.ts","webpack://spectrumChartsVegaSpecBuilder/./src/line/linePointUtils.ts","webpack://spectrumChartsVegaSpecBuilder/./src/line/lineSpecBuilder.ts","webpack://spectrumChartsVegaSpecBuilder/./src/line/lineUtils.ts","webpack://spectrumChartsVegaSpecBuilder/./src/marks/markUtils.ts","webpack://spectrumChartsVegaSpecBuilder/./src/metricRange/metricRangeUtils.ts","webpack://spectrumChartsVegaSpecBuilder/./src/scale/scaleSpecBuilder.ts","webpack://spectrumChartsVegaSpecBuilder/./src/scatter/scatterMarkUtils.ts","webpack://spectrumChartsVegaSpecBuilder/./src/scatter/scatterSpecBuilder.ts","webpack://spectrumChartsVegaSpecBuilder/./src/scatterPath/index.ts","webpack://spectrumChartsVegaSpecBuilder/./src/scatterPath/scatterPathUtils.ts","webpack://spectrumChartsVegaSpecBuilder/./src/signal/signalSpecBuilder.ts","webpack://spectrumChartsVegaSpecBuilder/./src/specUtils.ts","webpack://spectrumChartsVegaSpecBuilder/./src/textUtils.ts","webpack://spectrumChartsVegaSpecBuilder/./src/title/titleSpecBuilder.ts","webpack://spectrumChartsVegaSpecBuilder/./src/trendline/index.ts","webpack://spectrumChartsVegaSpecBuilder/./src/trendline/trendlineDataTransformUtils.ts","webpack://spectrumChartsVegaSpecBuilder/./src/trendline/trendlineDataUtils.ts","webpack://spectrumChartsVegaSpecBuilder/./src/trendline/trendlineMarkUtils.ts","webpack://spectrumChartsVegaSpecBuilder/./src/trendline/trendlineScaleUtils.ts","webpack://spectrumChartsVegaSpecBuilder/./src/trendline/trendlineSignalUtils.ts","webpack://spectrumChartsVegaSpecBuilder/./src/trendline/trendlineUtils.ts","webpack://spectrumChartsVegaSpecBuilder/./src/trendlineAnnotation/index.ts","webpack://spectrumChartsVegaSpecBuilder/./src/trendlineAnnotation/trendlineAnnotationUtils.ts","webpack://spectrumChartsVegaSpecBuilder/./src/types/axis/index.ts","webpack://spectrumChartsVegaSpecBuilder/./src/types/dialogs/index.ts","webpack://spectrumChartsVegaSpecBuilder/./src/types/index.ts","webpack://spectrumChartsVegaSpecBuilder/./src/types/marks/index.ts","webpack://spectrumChartsVegaSpecBuilder/./src/types/marks/supplemental/index.ts","webpack://spectrumChartsVegaSpecBuilder/./src/types/specUtil.types.ts","webpack://spectrumChartsVegaSpecBuilder/external umd \"@spectrum-charts/constants\"","webpack://spectrumChartsVegaSpecBuilder/external umd \"@spectrum-charts/themes\"","webpack://spectrumChartsVegaSpecBuilder/external umd \"@spectrum-charts/utils\"","webpack://spectrumChartsVegaSpecBuilder/webpack/bootstrap","webpack://spectrumChartsVegaSpecBuilder/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"@spectrum-charts/constants\"), require(\"@spectrum-charts/themes\"), require(\"@spectrum-charts/utils\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"@spectrum-charts/constants\", \"@spectrum-charts/themes\", \"@spectrum-charts/utils\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"spectrumChartsVegaSpecBuilder\"] = factory(require(\"@spectrum-charts/constants\"), require(\"@spectrum-charts/themes\"), require(\"@spectrum-charts/utils\"));\n\telse\n\t\troot[\"spectrumChartsVegaSpecBuilder\"] = factory(root[\"@spectrum-charts/constants\"], root[\"@spectrum-charts/themes\"], root[\"@spectrum-charts/utils\"]);\n})(this, (__WEBPACK_EXTERNAL_MODULE__9633__, __WEBPACK_EXTERNAL_MODULE__1274__, __WEBPACK_EXTERNAL_MODULE__8365__) => {\nreturn ","'use strict';\n\nvar isMergeableObject = function isMergeableObject(value) {\n\treturn isNonNullObject(value)\n\t\t&& !isSpecial(value)\n};\n\nfunction isNonNullObject(value) {\n\treturn !!value && typeof value === 'object'\n}\n\nfunction isSpecial(value) {\n\tvar stringValue = Object.prototype.toString.call(value);\n\n\treturn stringValue === '[object RegExp]'\n\t\t|| stringValue === '[object Date]'\n\t\t|| isReactElement(value)\n}\n\n// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\nvar canUseSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n\nfunction isReactElement(value) {\n\treturn value.$$typeof === REACT_ELEMENT_TYPE\n}\n\nfunction emptyTarget(val) {\n\treturn Array.isArray(val) ? [] : {}\n}\n\nfunction cloneUnlessOtherwiseSpecified(value, options) {\n\treturn (options.clone !== false && options.isMergeableObject(value))\n\t\t? deepmerge(emptyTarget(value), value, options)\n\t\t: value\n}\n\nfunction defaultArrayMerge(target, source, options) {\n\treturn target.concat(source).map(function(element) {\n\t\treturn cloneUnlessOtherwiseSpecified(element, options)\n\t})\n}\n\nfunction getMergeFunction(key, options) {\n\tif (!options.customMerge) {\n\t\treturn deepmerge\n\t}\n\tvar customMerge = options.customMerge(key);\n\treturn typeof customMerge === 'function' ? customMerge : deepmerge\n}\n\nfunction getEnumerableOwnPropertySymbols(target) {\n\treturn Object.getOwnPropertySymbols\n\t\t? Object.getOwnPropertySymbols(target).filter(function(symbol) {\n\t\t\treturn Object.propertyIsEnumerable.call(target, symbol)\n\t\t})\n\t\t: []\n}\n\nfunction getKeys(target) {\n\treturn Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))\n}\n\nfunction propertyIsOnObject(object, property) {\n\ttry {\n\t\treturn property in object\n\t} catch(_) {\n\t\treturn false\n\t}\n}\n\n// Protects from prototype poisoning and unexpected merging up the prototype chain.\nfunction propertyIsUnsafe(target, key) {\n\treturn propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\n\t\t&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\n\t\t\t&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.\n}\n\nfunction mergeObject(target, source, options) {\n\tvar destination = {};\n\tif (options.isMergeableObject(target)) {\n\t\tgetKeys(target).forEach(function(key) {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n\t\t});\n\t}\n\tgetKeys(source).forEach(function(key) {\n\t\tif (propertyIsUnsafe(target, key)) {\n\t\t\treturn\n\t\t}\n\n\t\tif (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {\n\t\t\tdestination[key] = getMergeFunction(key, options)(target[key], source[key], options);\n\t\t} else {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n\t\t}\n\t});\n\treturn destination\n}\n\nfunction deepmerge(target, source, options) {\n\toptions = options || {};\n\toptions.arrayMerge = options.arrayMerge || defaultArrayMerge;\n\toptions.isMergeableObject = options.isMergeableObject || isMergeableObject;\n\t// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()\n\t// implementations can use it. The caller may not replace it.\n\toptions.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;\n\n\tvar sourceIsArray = Array.isArray(source);\n\tvar targetIsArray = Array.isArray(target);\n\tvar sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n\n\tif (!sourceAndTargetTypesMatch) {\n\t\treturn cloneUnlessOtherwiseSpecified(source, options)\n\t} else if (sourceIsArray) {\n\t\treturn options.arrayMerge(target, source, options)\n\t} else {\n\t\treturn mergeObject(target, source, options)\n\t}\n}\n\ndeepmerge.all = function deepmergeAll(array, options) {\n\tif (!Array.isArray(array)) {\n\t\tthrow new Error('first argument should be an array')\n\t}\n\n\treturn array.reduce(function(prev, next) {\n\t\treturn deepmerge(prev, next, options)\n\t}, {})\n};\n\nvar deepmerge_1 = deepmerge;\n\nmodule.exports = deepmerge_1;\n","\"use strict\";var ne=Object.defineProperty;var ge=Object.getOwnPropertyDescriptor;var be=Object.getOwnPropertyNames;var Te=Object.prototype.hasOwnProperty;var Ae=(e,t)=>{for(var r in t)ne(e,r,{get:t[r],enumerable:!0})},Ie=(e,t,r,n)=>{if(t&&typeof t==\"object\"||typeof t==\"function\")for(let i of be(t))!Te.call(e,i)&&i!==r&&ne(e,i,{get:()=>t[i],enumerable:!(n=ge(t,i))||n.enumerable});return e};var De=e=>Ie(ne({},\"__esModule\",{value:!0}),e);var Be={};Ae(Be,{Immer:()=>J,applyPatches:()=>Ce,castDraft:()=>ke,castImmutable:()=>Ke,createDraft:()=>Re,current:()=>re,enableMapSet:()=>xe,enablePatches:()=>Pe,finishDraft:()=>ve,freeze:()=>K,immerable:()=>N,isDraft:()=>O,isDraftable:()=>A,nothing:()=>j,original:()=>le,produce:()=>Fe,produceWithPatches:()=>Ne,setAutoFreeze:()=>ze,setUseStrictShallowCopy:()=>je});module.exports=De(Be);var j=Symbol.for(\"immer-nothing\"),N=Symbol.for(\"immer-draftable\"),u=Symbol.for(\"immer-state\");function h(e,...t){throw new Error(`[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`)}var z=Object.getPrototypeOf;function O(e){return!!e&&!!e[u]}function A(e){return e?ye(e)||Array.isArray(e)||!!e[N]||!!e.constructor?.[N]||v(e)||k(e):!1}var Oe=Object.prototype.constructor.toString();function ye(e){if(!e||typeof e!=\"object\")return!1;let t=z(e);if(t===null)return!0;let r=Object.hasOwnProperty.call(t,\"constructor\")&&t.constructor;return r===Object?!0:typeof r==\"function\"&&Function.toString.call(r)===Oe}function le(e){return O(e)||h(15,e),e[u].t}function _(e,t){C(e)===0?Reflect.ownKeys(e).forEach(r=>{t(r,e[r],e)}):e.forEach((r,n)=>t(n,r,e))}function C(e){let t=e[u];return t?t.o:Array.isArray(e)?1:v(e)?2:k(e)?3:0}function R(e,t){return C(e)===2?e.has(t):Object.prototype.hasOwnProperty.call(e,t)}function X(e,t){return C(e)===2?e.get(t):e[t]}function Q(e,t,r){let n=C(e);n===2?e.set(t,r):n===3?e.add(r):e[t]=r}function pe(e,t){return e===t?e!==0||1/e===1/t:e!==e&&t!==t}function v(e){return e instanceof Map}function k(e){return e instanceof Set}function T(e){return e.e||e.t}function L(e,t){if(v(e))return new Map(e);if(k(e))return new Set(e);if(Array.isArray(e))return Array.prototype.slice.call(e);let r=ye(e);if(t===!0||t===\"class_only\"&&!r){let n=Object.getOwnPropertyDescriptors(e);delete n[u];let i=Reflect.ownKeys(n);for(let f=0;f<i.length;f++){let l=i[f],c=n[l];c.writable===!1&&(c.writable=!0,c.configurable=!0),(c.get||c.set)&&(n[l]={configurable:!0,writable:!0,enumerable:c.enumerable,value:e[l]})}return Object.create(z(e),n)}else{let n=z(e);if(n!==null&&r)return{...e};let i=Object.create(n);return Object.assign(i,e)}}function K(e,t=!1){return $(e)||O(e)||!A(e)||(C(e)>1&&(e.set=e.add=e.clear=e.delete=Me),Object.freeze(e),t&&Object.entries(e).forEach(([r,n])=>K(n,!0))),e}function Me(){h(2)}function $(e){return Object.isFrozen(e)}var ae={};function w(e){let t=ae[e];return t||h(0,e),t}function Y(e,t){ae[e]||(ae[e]=t)}var U;function B(){return U}function _e(e,t){return{a:[],i:e,p:t,P:!0,d:0}}function oe(e,t){t&&(w(\"Patches\"),e.f=[],e.h=[],e.b=t)}function V(e){Z(e),e.a.forEach(we),e.a=null}function Z(e){e===U&&(U=e.i)}function ie(e){return U=_e(U,e)}function we(e){let t=e[u];t.o===0||t.o===1?t.x():t.m=!0}function se(e,t){t.d=t.a.length;let r=t.a[0];return e!==void 0&&e!==r?(r[u].s&&(V(t),h(4)),A(e)&&(e=ee(t,e),t.i||te(t,e)),t.f&&w(\"Patches\").T(r[u].t,e,t.f,t.h)):e=ee(t,r,[]),V(t),t.f&&t.b(t.f,t.h),e!==j?e:void 0}function ee(e,t,r){if($(t))return t;let n=t[u];if(!n)return _(t,(i,f)=>de(e,n,t,i,f,r)),t;if(n.n!==e)return t;if(!n.s)return te(e,n.t,!0),n.t;if(!n.c){n.c=!0,n.n.d--;let i=n.e,f=i,l=!1;n.o===3&&(f=new Set(i),i.clear(),l=!0),_(f,(c,b)=>de(e,n,i,c,b,r,l)),te(e,i,!1),r&&e.f&&w(\"Patches\").g(n,r,e.f,e.h)}return n.e}function de(e,t,r,n,i,f,l){if(O(i)){let c=f&&t&&t.o!==3&&!R(t.r,n)?f.concat(n):void 0,b=ee(e,i,c);if(Q(r,n,b),O(b))e.P=!1;else return}else l&&r.add(i);if(A(i)&&!$(i)){if(!e.p.y&&e.d<1)return;ee(e,i),(!t||!t.n.i)&&typeof n!=\"symbol\"&&Object.prototype.propertyIsEnumerable.call(r,n)&&te(e,i)}}function te(e,t,r=!1){!e.i&&e.p.y&&e.P&&K(t,r)}function he(e,t){let r=Array.isArray(e),n={o:r?1:0,n:t?t.n:B(),s:!1,c:!1,r:{},i:t,t:e,u:null,e:null,x:null,l:!1},i=n,f=ue;r&&(i=[n],f=q);let{revoke:l,proxy:c}=Proxy.revocable(i,f);return n.u=c,n.x=l,c}var ue={get(e,t){if(t===u)return e;let r=T(e);if(!R(r,t))return Ee(e,r,t);let n=r[t];return e.c||!A(n)?n:n===ce(e.t,t)?(fe(e),e.e[t]=W(n,e)):n},has(e,t){return t in T(e)},ownKeys(e){return Reflect.ownKeys(T(e))},set(e,t,r){let n=me(T(e),t);if(n?.set)return n.set.call(e.u,r),!0;if(!e.s){let i=ce(T(e),t),f=i?.[u];if(f&&f.t===r)return e.e[t]=r,e.r[t]=!1,!0;if(pe(r,i)&&(r!==void 0||R(e.t,t)))return!0;fe(e),E(e)}return e.e[t]===r&&(r!==void 0||t in e.e)||Number.isNaN(r)&&Number.isNaN(e.e[t])||(e.e[t]=r,e.r[t]=!0),!0},deleteProperty(e,t){return ce(e.t,t)!==void 0||t in e.t?(e.r[t]=!1,fe(e),E(e)):delete e.r[t],e.e&&delete e.e[t],!0},getOwnPropertyDescriptor(e,t){let r=T(e),n=Reflect.getOwnPropertyDescriptor(r,t);return n&&{writable:!0,configurable:e.o!==1||t!==\"length\",enumerable:n.enumerable,value:r[t]}},defineProperty(){h(11)},getPrototypeOf(e){return z(e.t)},setPrototypeOf(){h(12)}},q={};_(ue,(e,t)=>{q[e]=function(){return arguments[0]=arguments[0][0],t.apply(this,arguments)}});q.deleteProperty=function(e,t){return q.set.call(this,e,t,void 0)};q.set=function(e,t,r){return ue.set.call(this,e[0],t,r,e[0])};function ce(e,t){let r=e[u];return(r?T(r):e)[t]}function Ee(e,t,r){let n=me(t,r);return n?\"value\"in n?n.value:n.get?.call(e.u):void 0}function me(e,t){if(!(t in e))return;let r=z(e);for(;r;){let n=Object.getOwnPropertyDescriptor(r,t);if(n)return n;r=z(r)}}function E(e){e.s||(e.s=!0,e.i&&E(e.i))}function fe(e){e.e||(e.e=L(e.t,e.n.p.S))}var J=class{constructor(t){this.y=!0;this.S=!1;this.produce=(t,r,n)=>{if(typeof t==\"function\"&&typeof r!=\"function\"){let f=r;r=t;let l=this;return function(b=f,...a){return l.produce(b,o=>r.call(this,o,...a))}}typeof r!=\"function\"&&h(6),n!==void 0&&typeof n!=\"function\"&&h(7);let i;if(A(t)){let f=ie(this),l=W(t,void 0),c=!0;try{i=r(l),c=!1}finally{c?V(f):Z(f)}return oe(f,n),se(i,f)}else if(!t||typeof t!=\"object\"){if(i=r(t),i===void 0&&(i=t),i===j&&(i=void 0),this.y&&K(i,!0),n){let f=[],l=[];w(\"Patches\").T(t,i,f,l),n(f,l)}return i}else h(1,t)};this.produceWithPatches=(t,r)=>{if(typeof t==\"function\")return(l,...c)=>this.produceWithPatches(l,b=>t(b,...c));let n,i;return[this.produce(t,r,(l,c)=>{n=l,i=c}),n,i]};typeof t?.autoFreeze==\"boolean\"&&this.setAutoFreeze(t.autoFreeze),typeof t?.useStrictShallowCopy==\"boolean\"&&this.setUseStrictShallowCopy(t.useStrictShallowCopy)}createDraft(t){A(t)||h(8),O(t)&&(t=re(t));let r=ie(this),n=W(t,void 0);return n[u].l=!0,Z(r),n}finishDraft(t,r){let n=t&&t[u];(!n||!n.l)&&h(9);let{n:i}=n;return oe(i,r),se(void 0,i)}setAutoFreeze(t){this.y=t}setUseStrictShallowCopy(t){this.S=t}applyPatches(t,r){let n;for(n=r.length-1;n>=0;n--){let f=r[n];if(f.path.length===0&&f.op===\"replace\"){t=f.value;break}}n>-1&&(r=r.slice(n+1));let i=w(\"Patches\").A;return O(t)?i(t,r):this.produce(t,f=>i(f,r))}};function W(e,t){let r=v(e)?w(\"MapSet\").I(e,t):k(e)?w(\"MapSet\").D(e,t):he(e,t);return(t?t.n:B()).a.push(r),r}function re(e){return O(e)||h(10,e),Se(e)}function Se(e){if(!A(e)||$(e))return e;let t=e[u],r;if(t){if(!t.s)return t.t;t.c=!0,r=L(e,t.n.p.S)}else r=L(e,!0);return _(r,(n,i)=>{Q(r,n,Se(i))}),t&&(t.c=!1),r}function Pe(){let t=\"replace\",r=\"add\",n=\"remove\";function i(s,S,m,x){switch(s.o){case 0:case 2:return l(s,S,m,x);case 1:return f(s,S,m,x);case 3:return c(s,S,m,x)}}function f(s,S,m,x){let{t:I,r:P}=s,g=s.e;g.length<I.length&&([I,g]=[g,I],[m,x]=[x,m]);for(let y=0;y<I.length;y++)if(P[y]&&g[y]!==I[y]){let d=S.concat([y]);m.push({op:t,path:d,value:p(g[y])}),x.push({op:t,path:d,value:p(I[y])})}for(let y=I.length;y<g.length;y++){let d=S.concat([y]);m.push({op:r,path:d,value:p(g[y])})}for(let y=g.length-1;I.length<=y;--y){let d=S.concat([y]);x.push({op:n,path:d})}}function l(s,S,m,x){let{t:I,e:P}=s;_(s.r,(g,y)=>{let d=X(I,g),H=X(P,g),F=y?R(I,g)?t:r:n;if(d===H&&F===t)return;let D=S.concat(g);m.push(F===n?{op:F,path:D}:{op:F,path:D,value:H}),x.push(F===r?{op:n,path:D}:F===n?{op:r,path:D,value:p(d)}:{op:t,path:D,value:p(d)})})}function c(s,S,m,x){let{t:I,e:P}=s,g=0;I.forEach(y=>{if(!P.has(y)){let d=S.concat([g]);m.push({op:n,path:d,value:y}),x.unshift({op:r,path:d,value:y})}g++}),g=0,P.forEach(y=>{if(!I.has(y)){let d=S.concat([g]);m.push({op:r,path:d,value:y}),x.unshift({op:n,path:d,value:y})}g++})}function b(s,S,m,x){m.push({op:t,path:[],value:S===j?void 0:S}),x.push({op:t,path:[],value:s})}function a(s,S){return S.forEach(m=>{let{path:x,op:I}=m,P=s;for(let H=0;H<x.length-1;H++){let F=C(P),D=x[H];typeof D!=\"string\"&&typeof D!=\"number\"&&(D=\"\"+D),(F===0||F===1)&&(D===\"__proto__\"||D===\"constructor\")&&h(16+3),typeof P==\"function\"&&D===\"prototype\"&&h(16+3),P=X(P,D),typeof P!=\"object\"&&h(16+2,x.join(\"/\"))}let g=C(P),y=o(m.value),d=x[x.length-1];switch(I){case t:switch(g){case 2:return P.set(d,y);case 3:h(16);default:return P[d]=y}case r:switch(g){case 1:return d===\"-\"?P.push(y):P.splice(d,0,y);case 2:return P.set(d,y);case 3:return P.add(y);default:return P[d]=y}case n:switch(g){case 1:return P.splice(d,1);case 2:return P.delete(d);case 3:return P.delete(m.value);default:return delete P[d]}default:h(16+1,I)}}),s}function o(s){if(!A(s))return s;if(Array.isArray(s))return s.map(o);if(v(s))return new Map(Array.from(s.entries()).map(([m,x])=>[m,o(x)]));if(k(s))return new Set(Array.from(s).map(o));let S=Object.create(z(s));for(let m in s)S[m]=o(s[m]);return R(s,N)&&(S[N]=s[N]),S}function p(s){return O(s)?o(s):s}Y(\"Patches\",{A:a,g:i,T:b})}function xe(){class e extends Map{constructor(a,o){super();this[u]={o:2,i:o,n:o?o.n:B(),s:!1,c:!1,e:void 0,r:void 0,t:a,u:this,l:!1,m:!1}}get size(){return T(this[u]).size}has(a){return T(this[u]).has(a)}set(a,o){let p=this[u];return l(p),(!T(p).has(a)||T(p).get(a)!==o)&&(r(p),E(p),p.r.set(a,!0),p.e.set(a,o),p.r.set(a,!0)),this}delete(a){if(!this.has(a))return!1;let o=this[u];return l(o),r(o),E(o),o.t.has(a)?o.r.set(a,!1):o.r.delete(a),o.e.delete(a),!0}clear(){let a=this[u];l(a),T(a).size&&(r(a),E(a),a.r=new Map,_(a.t,o=>{a.r.set(o,!1)}),a.e.clear())}forEach(a,o){let p=this[u];T(p).forEach((s,S,m)=>{a.call(o,this.get(S),S,this)})}get(a){let o=this[u];l(o);let p=T(o).get(a);if(o.c||!A(p)||p!==o.t.get(a))return p;let s=W(p,o);return r(o),o.e.set(a,s),s}keys(){return T(this[u]).keys()}values(){let a=this.keys();return{[Symbol.iterator]:()=>this.values(),next:()=>{let o=a.next();return o.done?o:{done:!1,value:this.get(o.value)}}}}entries(){let a=this.keys();return{[Symbol.iterator]:()=>this.entries(),next:()=>{let o=a.next();if(o.done)return o;let p=this.get(o.value);return{done:!1,value:[o.value,p]}}}}[(u,Symbol.iterator)](){return this.entries()}}function t(c,b){return new e(c,b)}function r(c){c.e||(c.r=new Map,c.e=new Map(c.t))}class n extends Set{constructor(a,o){super();this[u]={o:3,i:o,n:o?o.n:B(),s:!1,c:!1,e:void 0,t:a,u:this,a:new Map,m:!1,l:!1}}get size(){return T(this[u]).size}has(a){let o=this[u];return l(o),o.e?!!(o.e.has(a)||o.a.has(a)&&o.e.has(o.a.get(a))):o.t.has(a)}add(a){let o=this[u];return l(o),this.has(a)||(f(o),E(o),o.e.add(a)),this}delete(a){if(!this.has(a))return!1;let o=this[u];return l(o),f(o),E(o),o.e.delete(a)||(o.a.has(a)?o.e.delete(o.a.get(a)):!1)}clear(){let a=this[u];l(a),T(a).size&&(f(a),E(a),a.e.clear())}values(){let a=this[u];return l(a),f(a),a.e.values()}entries(){let a=this[u];return l(a),f(a),a.e.entries()}keys(){return this.values()}[(u,Symbol.iterator)](){return this.values()}forEach(a,o){let p=this.values(),s=p.next();for(;!s.done;)a.call(o,s.value,s.value,this),s=p.next()}}function i(c,b){return new n(c,b)}function f(c){c.e||(c.e=new Set,c.t.forEach(b=>{if(A(b)){let a=W(b,c);c.a.set(b,a),c.e.add(a)}else c.e.add(b)}))}function l(c){c.m&&h(3,JSON.stringify(T(c)))}Y(\"MapSet\",{I:t,D:i})}var M=new J,Fe=M.produce,Ne=M.produceWithPatches.bind(M),ze=M.setAutoFreeze.bind(M),je=M.setUseStrictShallowCopy.bind(M),Ce=M.applyPatches.bind(M),Re=M.createDraft.bind(M),ve=M.finishDraft.bind(M);function ke(e){return e}function Ke(e){return e}0&&(module.exports={Immer,applyPatches,castDraft,castImmutable,createDraft,current,enableMapSet,enablePatches,finishDraft,freeze,immerable,isDraft,isDraftable,nothing,original,produce,produceWithPatches,setAutoFreeze,setUseStrictShallowCopy});\n//# sourceMappingURL=immer.cjs.production.js.map","\n'use strict'\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./immer.cjs.production.js')\n} else {\n  module.exports = require('./immer.cjs.development.js')\n}","/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport { produce } from 'immer';\nimport { Data, Mark, Scale, Signal, SourceData, Spec } from 'vega';\n\nimport {\n\tBACKGROUND_COLOR,\n\tCOLOR_SCALE,\n\tDEFAULT_COLOR,\n\tDEFAULT_COLOR_SCHEME,\n\tDEFAULT_METRIC,\n\tDEFAULT_TIME_DIMENSION,\n\tFILTERED_TABLE,\n\tHIGHLIGHTED_ITEM,\n\tSELECTED_ITEM,\n\tSELECTED_SERIES,\n} from '@spectrum-charts/constants';\nimport { spectrumColors } from '@spectrum-charts/themes';\nimport { toCamelCase } from '@spectrum-charts/utils';\n\nimport {\n\taddTooltipData,\n\taddTooltipSignals,\n\tisHighlightedByDimension,\n\tisHighlightedByGroup,\n} from '../chartTooltip/chartTooltipUtils';\nimport { addTimeTransform, getFilteredTableData, getTableData, getTransformSort } from '../data/dataUtils';\nimport { hasPopover, hasTooltip, isInteractive } from '../marks/markUtils';\nimport { addContinuousDimensionScale, addFieldToFacetScaleDomain, addMetricScale } from '../scale/scaleSpecBuilder';\nimport {\n\taddHighlightedSeriesSignalEvents,\n\tgetControlledHoveredGroupSignal,\n\tgetControlledHoveredIdSignal,\n} from '../signal/signalSpecBuilder';\nimport { AreaOptions, AreaSpecOptions, ChartPopoverOptions, ColorScheme, HighlightedItem, ScaleType } from '../types';\nimport { getAreaMark, getX } from './areaUtils';\n\nexport const addArea = produce<\n\tSpec,\n\t[AreaOptions & { colorScheme?: ColorScheme; highlightedItem?: HighlightedItem; index?: number; idKey: string }]\n>(\n\t(\n\t\tspec,\n\t\t{\n\t\t\tchartPopovers = [],\n\t\t\tchartTooltips = [],\n\t\t\tcolor = DEFAULT_COLOR,\n\t\t\tcolorScheme = DEFAULT_COLOR_SCHEME,\n\t\t\tdimension = DEFAULT_TIME_DIMENSION,\n\t\t\tindex = 0,\n\t\t\tmetric = DEFAULT_METRIC,\n\t\t\tmetricStart,\n\t\t\tmetricEnd,\n\t\t\tname,\n\t\t\topacity = 0.8,\n\t\t\tscaleType = 'time',\n\t\t\t...options\n\t\t}\n\t) => {\n\t\t// put options back together now that all defaults are set\n\t\tconst areaOptions: AreaSpecOptions = {\n\t\t\tchartPopovers,\n\t\t\tchartTooltips,\n\t\t\tcolor,\n\t\t\tcolorScheme,\n\t\t\tdimension,\n\t\t\tindex,\n\t\t\tmetric,\n\t\t\tname: toCamelCase(name || `area${index}`),\n\t\t\tscaleType,\n\t\t\topacity,\n\t\t\tmetricStart,\n\t\t\tmetricEnd,\n\t\t\t...options,\n\t\t};\n\n\t\t// if either start or end is defined but not both, error to the console and default back to metric\n\t\tif ((metricStart || metricEnd) && !(metricStart && metricEnd)) {\n\t\t\tconsole.error(\n\t\t\t\t`${metricEnd ? 'metricEnd' : 'metricStart'} is defined but ${\n\t\t\t\t\tmetricEnd ? 'metricStart' : 'metricEnd'\n\t\t\t\t} is not. Both must be defined in order to use the \"start and end\" method. Defaulting back to 'metric = ${metric}'`\n\t\t\t);\n\t\t\tareaOptions.metricEnd = undefined;\n\t\t\tareaOptions.metricStart = undefined;\n\t\t}\n\n\t\tspec.data = addData(spec.data ?? [], areaOptions);\n\t\tspec.signals = addSignals(spec.signals ?? [], areaOptions);\n\t\tspec.scales = setScales(spec.scales ?? [], areaOptions);\n\t\tspec.marks = addAreaMarks(spec.marks ?? [], areaOptions);\n\n\t\treturn spec;\n\t}\n);\n\nexport const addData = produce<Data[], [AreaSpecOptions]>((data, areaOptions) => {\n\tconst { color, dimension, highlightedItem, metric, metricEnd, metricStart, name, order, scaleType } = areaOptions;\n\tif (scaleType === 'time') {\n\t\tconst tableData = getTableData(data);\n\t\ttableData.transform = addTimeTransform(tableData.transform ?? [], dimension);\n\t}\n\n\tif (!metricEnd || !metricStart) {\n\t\tconst filteredTableData = getFilteredTableData(data);\n\t\t// if metricEnd and metricStart don't exist, then we are using metric so we will support stacked\n\t\tfilteredTableData.transform = [\n\t\t\t...(filteredTableData.transform ?? []),\n\t\t\t{\n\t\t\t\ttype: 'stack',\n\t\t\t\tgroupby: [dimension],\n\t\t\t\tfield: metric,\n\t\t\t\tsort: getTransformSort(order),\n\t\t\t\tas: [`${metric}0`, `${metric}1`],\n\t\t\t},\n\t\t];\n\t}\n\n\tif (isInteractive(areaOptions) || highlightedItem !== undefined) {\n\t\tconst areaHasPopover = hasPopover(areaOptions);\n\t\tconst areaHasTooltip = hasTooltip(areaOptions);\n\t\tdata.push(\n\t\t\tgetAreaHighlightedData(\n\t\t\t\tname,\n\t\t\t\tareaOptions.idKey,\n\t\t\t\tareaHasTooltip,\n\t\t\t\tareaHasPopover,\n\t\t\t\tisHighlightedByGroup(areaOptions)\n\t\t\t)\n\t\t);\n\t\tif (areaHasPopover) {\n\t\t\tdata.push({\n\t\t\t\tname: `${name}_selectedDataSeries`,\n\t\t\t\tsource: FILTERED_TABLE,\n\t\t\t\ttransform: [\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: 'filter',\n\t\t\t\t\t\texpr: `isValid(${SELECTED_SERIES}) && ${SELECTED_SERIES} === datum.${color}`,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t});\n\t\t}\n\t}\n\taddTooltipData(data, areaOptions, false);\n});\n\nexport const getAreaHighlightedData = (\n\tname: string,\n\tidKey: string,\n\thasTooltip: boolean,\n\thasPopover: boolean,\n\thasGroupId: boolean\n): SourceData => {\n\tlet expr = '';\n\tif (hasGroupId) {\n\t\texpr += `${name}_controlledHoveredGroup === datum.${name}_highlightGroupId`;\n\t} else {\n\t\texpr += `isArray(${HIGHLIGHTED_ITEM}) && indexof(${HIGHLIGHTED_ITEM}, datum.${idKey}) > -1  || ${HIGHLIGHTED_ITEM} === datum.${idKey}`;\n\t\tif (hasTooltip) {\n\t\t\texpr = `${name}_controlledHoveredId === datum.${idKey} || ${expr}`;\n\t\t}\n\t}\n\tif (hasPopover) {\n\t\texpr = `isValid(${SELECTED_ITEM}) && ${SELECTED_ITEM} === datum.${idKey} || !isValid(${SELECTED_ITEM}) && ${expr}`;\n\t}\n\treturn {\n\t\tname: `${name}_highlightedData`,\n\t\tsource: FILTERED_TABLE,\n\t\ttransform: [\n\t\t\t{\n\t\t\t\ttype: 'filter',\n\t\t\t\texpr,\n\t\t\t},\n\t\t],\n\t};\n};\n\nexport const addSignals = produce<Signal[], [AreaSpecOptions]>((signals, areaOptions) => {\n\tconst { chartTooltips, name } = areaOptions;\n\tif (!isInteractive(areaOptions)) return;\n\taddHighlightedSeriesSignalEvents(signals, name, 1, chartTooltips[0]?.excludeDataKeys);\n\tif (areaOptions.highlightedItem) {\n\t\taddHighlightedItemEvents(signals, name);\n\t}\n\tif (!isHighlightedByGroup(areaOptions)) {\n\t\tsignals.push(getControlledHoveredIdSignal(name));\n\t} else {\n\t\tsignals.push(getControlledHoveredGroupSignal(name));\n\t}\n\taddTooltipSignals(signals, areaOptions);\n});\n\n/**\n * Adds an on event that clears the controlled highlighted item signal value when the user mouses over the area.\n * @param signals\n * @param areaName\n */\nexport const addHighlightedItemEvents = (signals: Signal[], areaName: string) => {\n\tconst highlightedItemSignal = signals.find((signal) => signal.name === HIGHLIGHTED_ITEM);\n\tif (highlightedItemSignal) {\n\t\tif (highlightedItemSignal.on === undefined) {\n\t\t\thighlightedItemSignal.on = [];\n\t\t}\n\t\t// as soon as the user mouses over the area, we want to null out the highlighted item\n\t\thighlightedItemSignal.on.push(...[{ events: `@${areaName}:mouseover`, update: 'null' }]);\n\t}\n};\n\nexport const setScales = produce<Scale[], [AreaSpecOptions]>(\n\t(scales, { metric, metricEnd, metricStart, dimension, color, scaleType, padding }) => {\n\t\t// add dimension scale\n\t\taddContinuousDimensionScale(scales, { scaleType, dimension, padding });\n\t\t// add color to the color domain\n\t\taddFieldToFacetScaleDomain(scales, COLOR_SCALE, color);\n\t\t// find the linear scale and add our field to it\n\t\tif (!metricEnd || !metricStart) {\n\t\t\tmetricStart = `${metric}0`;\n\t\t\tmetricEnd = `${metric}1`;\n\t\t}\n\t\taddMetricScale(scales, [metricStart, metricEnd]);\n\t\treturn scales;\n\t}\n);\n\nexport const addAreaMarks = produce<Mark[], [AreaSpecOptions]>((marks, areaOptions) => {\n\tconst {\n\t\tchartPopovers,\n\t\tchartTooltips,\n\t\tcolor,\n\t\tcolorScheme,\n\t\tdimension,\n\t\thighlightedItem,\n\t\tmetric,\n\t\tname,\n\t\topacity,\n\t\tscaleType,\n\t} = areaOptions;\n\tlet { metricStart, metricEnd } = areaOptions;\n\tlet isStacked = false;\n\tif (!metricEnd || !metricStart) {\n\t\tisStacked = true;\n\t\tmetricStart = `${metric}0`;\n\t\tmetricEnd = `${metric}1`;\n\t}\n\tmarks.push(\n\t\t{\n\t\t\tname: `${name}_group`,\n\t\t\ttype: 'group',\n\t\t\tfrom: {\n\t\t\t\tfacet: {\n\t\t\t\t\tname: `${name}_facet`,\n\t\t\t\t\tdata: FILTERED_TABLE,\n\t\t\t\t\tgroupby: color,\n\t\t\t\t},\n\t\t\t},\n\t\t\tmarks: [\n\t\t\t\tgetAreaMark({\n\t\t\t\t\tchartPopovers,\n\t\t\t\t\tchartTooltips,\n\t\t\t\t\tcolor,\n\t\t\t\t\tcolorScheme,\n\t\t\t\t\tdimension,\n\t\t\t\t\tisHighlightedByGroup: isHighlightedByGroup(areaOptions),\n\t\t\t\t\tisStacked,\n\t\t\t\t\thighlightedItem,\n\t\t\t\t\tmetricStart,\n\t\t\t\t\tmetricEnd,\n\t\t\t\t\tname,\n\t\t\t\t\topacity,\n\t\t\t\t\tscaleType,\n\t\t\t\t}),\n\t\t\t\t...getAnchorPointMark(areaOptions),\n\t\t\t],\n\t\t},\n\t\t...getSelectedAreaMarks({ chartPopovers, name, scaleType, color, dimension, metricEnd, metricStart }),\n\t\t...getHoverMarks(areaOptions)\n\t);\n\treturn marks;\n});\n\n/**\n * returns a transparent point that gets used by the popover to anchor to\n */\nconst getAnchorPointMark = (areaOptions: AreaSpecOptions): Mark[] => {\n\tconst { name, dimension, metric, scaleType } = areaOptions;\n\tif (!isInteractive(areaOptions)) return [];\n\treturn [\n\t\t{\n\t\t\tname: `${name}_anchorPoint`,\n\t\t\ttype: 'symbol',\n\t\t\tfrom: { data: `${name}_highlightedData` },\n\t\t\tinteractive: false,\n\t\t\tencode: {\n\t\t\t\tenter: {\n\t\t\t\t\ty: { scale: 'yLinear', field: `${metric}1` },\n\t\t\t\t\tstroke: { value: 'transparent' },\n\t\t\t\t\tfill: { value: 'transparent' },\n\t\t\t\t},\n\t\t\t\tupdate: {\n\t\t\t\t\tx: getX(scaleType, dimension),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t];\n};\n\n/**\n * returns a circle symbol and a rule on the hovered/selected point\n */\nconst getHoverMarks = (areaOptions: AreaSpecOptions): Mark[] => {\n\tconst { name, dimension, highlightedItem, metric, scaleType, color } = areaOptions;\n\tif (!isInteractive(areaOptions) && highlightedItem === undefined) return [];\n\tconst highlightMarks: Mark[] = [\n\t\t{\n\t\t\tname: `${name}_point`,\n\t\t\ttype: 'symbol',\n\t\t\tfrom: { data: `${name}_highlightedData` },\n\t\t\tinteractive: false,\n\t\t\tencode: {\n\t\t\t\tenter: {\n\t\t\t\t\ty: { scale: 'yLinear', field: `${metric}1` },\n\t\t\t\t\tstroke: { scale: COLOR_SCALE, field: color },\n\t\t\t\t\tfill: { signal: BACKGROUND_COLOR },\n\t\t\t\t},\n\t\t\t\tupdate: {\n\t\t\t\t\tx: getX(scaleType, dimension),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t];\n\tif (isHighlightedByDimension(areaOptions) || highlightedItem) {\n\t\thighlightMarks.unshift({\n\t\t\tname: `${name}_rule`,\n\t\t\ttype: 'rule',\n\t\t\tfrom: { data: `${name}_highlightedData` },\n\t\t\tinteractive: false,\n\t\t\tencode: {\n\t\t\t\tenter: {\n\t\t\t\t\ty: { value: 0 },\n\t\t\t\t\ty2: { signal: 'height' },\n\t\t\t\t\tstrokeWidth: { value: 1 },\n\t\t\t\t},\n\t\t\t\tupdate: {\n\t\t\t\t\tx: getX(scaleType, dimension),\n\t\t\t\t},\n\t\t\t},\n\t\t});\n\t}\n\treturn highlightMarks;\n};\n\n/**\n * returns an area mark for the blue border around the selected area.\n */\nconst getSelectedAreaMarks = ({\n\tchartPopovers,\n\tname,\n\tscaleType,\n\tcolor,\n\tdimension,\n\tmetricEnd,\n\tmetricStart,\n}: {\n\tchartPopovers: ChartPopoverOptions[];\n\tname: string;\n\tscaleType: ScaleType;\n\tcolor: string;\n\tdimension: string;\n\tmetricEnd: string;\n\tmetricStart: string;\n}): Mark[] => {\n\tif (!chartPopovers.length) return [];\n\treturn [\n\t\t{\n\t\t\tname: `${name}_selectBorder`,\n\t\t\ttype: 'area',\n\t\t\tfrom: { data: `${name}_selectedDataSeries` },\n\t\t\tinteractive: false,\n\t\t\tencode: {\n\t\t\t\tenter: {\n\t\t\t\t\ty: { scale: 'yLinear', field: metricStart },\n\t\t\t\t\ty2: { scale: 'yLinear', field: metricEnd },\n\t\t\t\t\t// need to fill this so the white border doesn't slightly bleed around the blue select border\n\t\t\t\t\tfill: { scale: COLOR_SCALE, field: color },\n\t\t\t\t\tstroke: { value: spectrumColors.light['static-blue'] },\n\t\t\t\t\tstrokeWidth: { value: 2 },\n\t\t\t\t\tstrokeJoin: { value: 'round' },\n\t\t\t\t},\n\t\t\t\tupdate: {\n\t\t\t\t\t// this has to be in update because when you resize the window that doesn't rebuild the spec\n\t\t\t\t\t// but it may change the x position if it causes the chart to resize\n\t\t\t\t\tx: getX(scaleType, dimension),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t];\n};\n","/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport { AreaMark, NumericValueRef, ProductionRule } from 'vega';\n\nimport {\n\tDEFAULT_OPACITY_RULE,\n\tDEFAULT_TRANSFORMED_TIME_DIMENSION,\n\tHIGHLIGHTED_ITEM,\n\tHIGHLIGHTED_SERIES,\n\tHIGHLIGHT_CONTRAST_RATIO,\n\tSELECTED_SERIES,\n\tSERIES_ID,\n} from '@spectrum-charts/constants';\n\nimport {\n\tgetBorderStrokeEncodings,\n\tgetColorProductionRule,\n\tgetCursor,\n\tgetTooltip,\n\tisInteractive,\n} from '../marks/markUtils';\nimport {\n\tChartPopoverOptions,\n\tChartTooltipOptions,\n\tColorFacet,\n\tColorScheme,\n\tHighlightedItem,\n\tScaleType,\n} from '../types';\n\nexport interface AreaMarkOptions {\n\tcolor: ColorFacet;\n\tcolorScheme: ColorScheme;\n\tdimension: string;\n\tdisplayOnHover?: boolean;\n\thighlightedItem?: HighlightedItem;\n\tisHighlightedByGroup?: boolean;\n\tisMetricRange?: boolean;\n\tisStacked: boolean;\n\tmetricStart: string;\n\tmetricEnd: string;\n\tname: string;\n\topacity: number;\n\tparentName?: string; // Optional name of mark that this area is a child of. Used for metric ranges.\n\tscaleType: ScaleType;\n\n\tchartPopovers?: ChartPopoverOptions[];\n\tchartTooltips?: ChartTooltipOptions[];\n}\n\nexport const getAreaMark = (\n\tareaOptions: AreaMarkOptions,\n\tdataSource: string = `${areaOptions.name}_facet`\n): AreaMark => {\n\tconst {\n\t\tname,\n\t\tchartPopovers,\n\t\tchartTooltips,\n\t\tcolor,\n\t\tcolorScheme,\n\t\tmetricStart,\n\t\tmetricEnd,\n\t\tisStacked,\n\t\tscaleType,\n\t\tdimension,\n\t\topacity,\n\t} = areaOptions;\n\treturn {\n\t\tname,\n\t\tdescription: name,\n\t\ttype: 'area',\n\t\tfrom: { data: dataSource },\n\t\tinteractive: isInteractive(areaOptions),\n\t\tencode: {\n\t\t\tenter: {\n\t\t\t\ty: { scale: 'yLinear', field: metricStart },\n\t\t\t\ty2: { scale: 'yLinear', field: metricEnd },\n\t\t\t\tfill: getColorProductionRule(color, colorScheme),\n\t\t\t\ttooltip: getTooltip(chartTooltips ?? [], name),\n\t\t\t\t...getBorderStrokeEncodings(isStacked, true),\n\t\t\t},\n\t\t\tupdate: {\n\t\t\t\t// this has to be in update because when you resize the window that doesn't rebuild the spec\n\t\t\t\t// but it may change the x position if it causes the chart to resize\n\t\t\t\tx: getX(scaleType, dimension),\n\t\t\t\tcursor: getCursor(chartPopovers ?? []),\n\t\t\t\tfillOpacity: { value: opacity },\n\t\t\t\topacity: getAreaOpacity(areaOptions),\n\t\t\t},\n\t\t},\n\t};\n};\n\nexport function getAreaOpacity(areaOptions: AreaMarkOptions): ProductionRule<NumericValueRef> | undefined {\n\tconst { chartPopovers, displayOnHover, isHighlightedByGroup, isMetricRange, highlightedItem, name } = areaOptions;\n\t// if metric ranges only display when hovering, we don't need to include other hover rules for this specific area\n\tconst fadedOpacity = 1 / HIGHLIGHT_CONTRAST_RATIO;\n\tif (isMetricRange && displayOnHover) {\n\t\treturn [\n\t\t\t{ test: `isValid(${HIGHLIGHTED_SERIES}) && ${HIGHLIGHTED_SERIES} === datum.${SERIES_ID}`, value: 1 },\n\t\t\t{\n\t\t\t\ttest: `isValid(${HIGHLIGHTED_ITEM}) && indexof(pluck(data('${name}_highlightedData'), '${SERIES_ID}'), datum.${SERIES_ID}) > -1`,\n\t\t\t},\n\t\t\t{ test: `isValid(${SELECTED_SERIES}) && ${SELECTED_SERIES} === datum.${SERIES_ID}`, value: 1 },\n\t\t\t{ value: 0 },\n\t\t];\n\t}\n\n\tif (!isInteractive(areaOptions) && !highlightedItem) {\n\t\treturn [DEFAULT_OPACITY_RULE];\n\t}\n\n\tconst opacityRules: ProductionRule<NumericValueRef> = [];\n\tif (isHighlightedByGroup) {\n\t\topacityRules.push({\n\t\t\ttest: `indexof(pluck(data('${name}_highlightedData'), '${SERIES_ID}'), datum.${SERIES_ID}) !== -1`,\n\t\t\tvalue: 1,\n\t\t});\n\t}\n\t// if an area is hovered or selected, all other areas should have half opacity\n\tif (!isMetricRange && chartPopovers?.length) {\n\t\treturn [\n\t\t\t...opacityRules,\n\t\t\t{\n\t\t\t\ttest: `!isValid(${SELECTED_SERIES}) && isValid(${HIGHLIGHTED_SERIES}) && ${HIGHLIGHTED_SERIES} !== datum.${SERIES_ID}`,\n\t\t\t\tvalue: fadedOpacity,\n\t\t\t},\n\t\t\t{\n\t\t\t\ttest: `!isValid(${SELECTED_SERIES}) && length(data('${name}_highlightedData')) > 0 && indexof(pluck(data('${name}_highlightedData'), '${SERIES_ID}'), datum.${SERIES_ID}) === -1`,\n\t\t\t\tvalue: fadedOpacity,\n\t\t\t},\n\t\t\t{\n\t\t\t\ttest: `isValid(${SELECTED_SERIES}) && ${SELECTED_SERIES} !== datum.${SERIES_ID}`,\n\t\t\t\tvalue: fadedOpacity,\n\t\t\t},\n\t\t\tDEFAULT_OPACITY_RULE,\n\t\t];\n\t}\n\n\treturn [\n\t\t...opacityRules,\n\t\t{\n\t\t\ttest: `isValid(${HIGHLIGHTED_SERIES}) && ${HIGHLIGHTED_SERIES} !== datum.${SERIES_ID}`,\n\t\t\tvalue: fadedOpacity,\n\t\t},\n\t\t{\n\t\t\ttest: `length(data('${name}_highlightedData')) > 0 && indexof(pluck(data('${name}_highlightedData'), '${SERIES_ID}'), datum.${SERIES_ID}) === -1`,\n\t\t\tvalue: fadedOpacity,\n\t\t},\n\t\tDEFAULT_OPACITY_RULE,\n\t];\n}\n\nexport const getX = (scaleType: ScaleType, dimension: string): ProductionRule<NumericValueRef> => {\n\tif (scaleType === 'time') {\n\t\treturn { scale: 'xTime', field: DEFAULT_TRANSFORMED_TIME_DIMENSION };\n\t} else if (scaleType === 'linear') {\n\t\treturn { scale: 'xLinear', field: dimension };\n\t}\n\treturn { scale: 'xPoint', field: dimension };\n};\n","/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport {\n\tAlign,\n\tBaseline,\n\tEncodeEntry,\n\tFontWeight,\n\tGuideEncodeEntry,\n\tNumberValue,\n\tProductionRule,\n\tTextEncodeEntry,\n\tTextValueRef,\n\tTickCount,\n} from 'vega';\n\nimport { getTextNumberFormat } from '../textUtils';\nimport { AxisSpecOptions, Granularity, Label, LabelAlign, Orientation, Position } from '../types';\nimport { isVerticalAxis } from './axisUtils';\n\n/**\n * Gets the display value of the label. If it's an object, it will return the value property, otherwise it will return the label.\n * @param label\n * @returns string | number\n */\nexport const getLabelValue = (label: Label | number | string): string | number => {\n\tif (typeof label === 'object') {\n\t\treturn label.value;\n\t}\n\treturn label;\n};\n\n/**\n * Gets the label format values based on the granularity\n * @param granularity\n * @returns [secondaryFormat, primaryFormat, tickCount]\n */\nexport const getTimeLabelFormats = (\n\tgranularity: Granularity\n): { secondaryLabelFormat: string; primaryLabelFormat: string; tickCount: TickCount } => {\n\tswitch (granularity) {\n\t\tcase 'minute':\n\t\t\treturn { secondaryLabelFormat: '%-I:%M %p', primaryLabelFormat: '%b %-d', tickCount: 'minute' };\n\t\tcase 'hour':\n\t\t\treturn { secondaryLabelFormat: '%-I %p', primaryLabelFormat: '%b %-d', tickCount: 'hour' };\n\t\tcase 'day':\n\t\t\treturn { secondaryLabelFormat: '%-d', primaryLabelFormat: '%b', tickCount: 'day' };\n\t\tcase 'week':\n\t\t\treturn { secondaryLabelFormat: '%-d', primaryLabelFormat: '%b', tickCount: 'week' };\n\t\tcase 'month':\n\t\t\treturn { secondaryLabelFormat: '%b', primaryLabelFormat: '%Y', tickCount: 'month' };\n\t\tcase 'quarter':\n\t\t\treturn { secondaryLabelFormat: 'Q%q', primaryLabelFormat: '%Y', tickCount: { interval: 'month', step: 3 } };\n\t\tdefault:\n\t\t\treturn { secondaryLabelFormat: '%-d', primaryLabelFormat: '%b', tickCount: 'day' };\n\t}\n};\n\n/**\n * label align can be set in a controlled manner using the `labels` and `subLabels` options\n * This function will return the correct align and baseline encodings based on the labelAlign and position\n * @param position\n * @param labelOrientaion\n * @param labelAlign\n * @returns align and baseline\n */\nexport const getControlledLabelAnchorValues = (\n\tposition: Position,\n\tlabelOrientaion: Orientation,\n\tlabelAlign?: LabelAlign\n): { align: Align | undefined; baseline: Baseline | undefined } => {\n\t// if there isn't a labelAlign, we don't want to set the align or baseline\n\tif (!labelAlign) return { align: undefined, baseline: undefined };\n\treturn getLabelAnchor(position, labelOrientaion, labelAlign);\n};\n\n/**\n * gets the values for labelAlign and labelBaseline based on the `labelAlign`, `labelOrientation`, and `position` options\n * vegaLabelAlign and vegaLabelBaseline options can be used to override these values\n * @param position\n * @param labelOrientaion\n * @param labelAlign\n * @param vegaLabelAlign\n * @param vegaLabelBaseline\n * @returns labelAlign and labelBaseline\n */\nexport const getLabelAnchorValues = (\n\tposition: Position,\n\tlabelOrientaion: Orientation,\n\tlabelAlign: LabelAlign,\n\tvegaLabelAlign?: Align,\n\tvegaLabelBaseline?: Baseline\n): { labelAlign: Align; labelBaseline: Baseline } => {\n\tconst { align, baseline } = getLabelAnchor(position, labelOrientaion, labelAlign);\n\t// if vegaLabelAlign or vegaLabelBaseline are set, we want to use those values instead of the calculated values\n\treturn {\n\t\tlabelAlign: vegaLabelAlign ?? align,\n\t\tlabelBaseline: vegaLabelBaseline ?? baseline,\n\t};\n};\n\n/**\n * gets the label align and baseline values based on the `labelAlign`, `labelOrientation`, and `position` options\n * @param position\n * @param labelOrientaion\n * @param labelAlign\n * @returns align and baseline\n */\nexport const getLabelAnchor = (\n\tposition: Position,\n\tlabelOrientaion: Orientation,\n\tlabelAlign: LabelAlign\n): { align: Align; baseline: Baseline } => {\n\tlet align: Align;\n\tlet baseline: Baseline;\n\tif (labelIsParallelToAxis(position, labelOrientaion)) {\n\t\t// label direction is parallel to the axis\n\t\t// for these, the align depends on the labelAlign and the baseline depends on the position\n\t\tconst labelAlignToAlign: { [key in LabelAlign]: Align } = {\n\t\t\tstart: 'left',\n\t\t\tcenter: 'center',\n\t\t\tend: 'right',\n\t\t};\n\t\talign = labelAlignToAlign[labelAlign];\n\t\tif (['top', 'left'].includes(position)) {\n\t\t\t// baseline is bottom for top and left axes\n\t\t\tbaseline = 'bottom';\n\t\t} else {\n\t\t\t// baseline is top for bottom and right axes\n\t\t\tbaseline = 'top';\n\t\t}\n\t} else {\n\t\t// label direction is perpendicular to the axis\n\t\t// for these, baseline depends on the labelAlign and align depends on the position\n\t\tconst labelAlignToBaseline: { [key in LabelAlign]: Baseline } = {\n\t\t\tstart: 'top',\n\t\t\tcenter: 'middle',\n\t\t\tend: 'bottom',\n\t\t};\n\t\tbaseline = labelAlignToBaseline[labelAlign];\n\t\tif (['bottom', 'left'].includes(position)) {\n\t\t\t// bottom and left will always have the anchor on the right side of the text\n\t\t\talign = 'right';\n\t\t} else {\n\t\t\t// top and right will always have the anchor on the left side of the text\n\t\t\talign = 'left';\n\t\t}\n\t}\n\treturn { align, baseline };\n};\n\n/**\n * determines if the label orientation is parallel to the axis direction\n * @param position\n * @param labelOrientaion\n * @returns boolean\n */\nexport const labelIsParallelToAxis = (position: Position, labelOrientaion: Orientation): boolean => {\n\tconst axisOrientation = ['top', 'bottom'].includes(position) ? 'horizontal' : 'vertical';\n\treturn axisOrientation === labelOrientaion;\n};\n\n/**\n * gets the label angle based on the `labelOrientation` prop\n * @param labelOrientaion\n * @returns labelAngle: number\n */\nexport const getLabelAngle = (labelOrientaion: Orientation): number => {\n\tif (labelOrientaion === 'horizontal') {\n\t\treturn 0;\n\t}\n\t// default vertical label should read from bottom to top\n\treturn 270;\n};\n\n/**\n * gets the vega baseline value based on the labelAlign value\n * @param labelAlign\n * @returns\n */\nexport const getLabelBaseline = (\n\tlabelAlign: LabelAlign | undefined,\n\tposition: Position,\n\tvegaLabelBaseline?: Baseline\n): Baseline | undefined => {\n\tif (vegaLabelBaseline) return vegaLabelBaseline;\n\tif (!labelAlign) return;\n\tif (isVerticalAxis(position)) {\n\t\tswitch (labelAlign) {\n\t\t\tcase 'start':\n\t\t\t\treturn 'top';\n\t\t\tcase 'end':\n\t\t\t\treturn 'bottom';\n\t\t\tcase 'center':\n\t\t\tdefault:\n\t\t\t\treturn 'middle';\n\t\t}\n\t}\n};\n\n/**\n * calculates the label offset for a band scale based on the labelAlign\n * @param labelAlign\n * @param scaleName\n * @returns\n */\nexport const getLabelOffset = (\n\tlabelAlign: LabelAlign,\n\tscaleName: string,\n\tvegaLabelOffset?: NumberValue\n): NumberValue | undefined => {\n\tif (vegaLabelOffset !== undefined) return vegaLabelOffset;\n\tswitch (labelAlign) {\n\t\tcase 'start':\n\t\t\treturn { signal: `bandwidth('${scaleName}') / -2` };\n\t\tcase 'end':\n\t\t\treturn { signal: `bandwidth('${scaleName}') / 2` };\n\t\tdefault:\n\t\t\treturn undefined;\n\t}\n};\n\n/**\n * gets the vega label format based on the labelFormat\n * @param type\n * @returns\n */\nexport const getLabelFormat = (\n\t{\n\t\tlabelFormat,\n\t\tlabelOrientation,\n\t\tnumberFormat,\n\t\tposition,\n\t\ttruncateLabels,\n\t\tcurrencyLocale,\n\t\tcurrencyCode,\n\t}: AxisSpecOptions,\n\tscaleName: string\n): ProductionRule<TextValueRef> => {\n\tif (labelFormat === 'percentage') {\n\t\treturn [{ test: 'isNumber(datum.value)', signal: \"format(datum.value, '~%')\" }, { signal: 'datum.value' }];\n\t}\n\tif (labelFormat === 'duration') {\n\t\treturn { signal: 'formatTimeDurationLabels(datum)' };\n\t}\n\n\treturn [\n\t\t...getTextNumberFormat(numberFormat, undefined, currencyLocale, currencyCode),\n\t\t...(truncateLabels && scaleName.includes('Band') && labelIsParallelToAxis(position, labelOrientation)\n\t\t\t? [{ signal: 'truncateText(datum.value, bandwidth(\"xBand\")/(1- paddingInner), \"normal\", 14)' }]\n\t\t\t: [{ signal: 'datum.value' }]),\n\t];\n};\n\n/**\n * Gets the axis label encoding\n * @param labelAlign\n * @param labelFontWeight\n * @param labelKey\n * @param position\n * @param signalName\n * @returns updateEncoding\n */\nexport const getAxisLabelsEncoding = (\n\tlabelAlign: LabelAlign,\n\tlabelFontWeight: FontWeight,\n\tlabelKey: 'label' | 'subLabel',\n\tlabelOrientation: Orientation,\n\tposition: Position,\n\tsignalName: string\n): GuideEncodeEntry<TextEncodeEntry> => ({\n\tupdate: {\n\t\ttext: [\n\t\t\t{\n\t\t\t\ttest: `indexof(pluck(${signalName}, 'value'), datum.value) !== -1`,\n\t\t\t\tsignal: `${signalName}[indexof(pluck(${signalName}, 'value'), datum.value)].${labelKey}`,\n\t\t\t},\n\t\t\t{ signal: 'datum.value' },\n\t\t],\n\t\tfontWeight: [\n\t\t\t{\n\t\t\t\ttest: `indexof(pluck(${signalName}, 'value'), datum.value) !== -1 && ${signalName}[indexof(pluck(${signalName}, 'value'), datum.value)].fontWeight`,\n\t\t\t\tsignal: `${signalName}[indexof(pluck(${signalName}, 'value'), datum.value)].fontWeight`,\n\t\t\t},\n\t\t\t// default to the primary label font weight\n\t\t\t{ value: labelFontWeight },\n\t\t],\n\t\t...getEncodedLabelAnchor(position, signalName, labelOrientation, labelAlign),\n\t},\n});\n\n/**\n * Will return the label align or baseline based on the position\n * These properties are used within the axis label encoding\n * If this is a vertical axis, it will return the correct baseline property and value\n * Otherwise, it will return the correct align property and value\n * @param position\n * @param signalName\n * @param defaultLabelAlign\n * @returns align | baseline\n */\nexport const getEncodedLabelAnchor = (\n\tposition: Position,\n\tsignalName: string,\n\tlabelOrientation: Orientation,\n\tdefaultLabelAlign: LabelAlign\n): EncodeEntry => {\n\tconst baseTestString = `indexof(pluck(${signalName}, 'value'), datum.value) !== -1 && ${signalName}[indexof(pluck(${signalName}, 'value'), datum.value)]`;\n\tconst baseSignalString = `${signalName}[indexof(pluck(${signalName}, 'value'), datum.value)]`;\n\tconst { align, baseline } = getLabelAnchor(position, labelOrientation, defaultLabelAlign);\n\n\treturn {\n\t\talign: [{ test: `${baseTestString}.align`, signal: `${baseSignalString}.align` }, { value: align }],\n\t\tbaseline: [{ test: `${baseTestString}.baseline`, signal: `${baseSignalString}.baseline` }, { value: baseline }],\n\t};\n};\n","/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport {\n\tEncodeEntry,\n\tGuideEncodeEntry,\n\tMark,\n\tNumericValueRef,\n\tProductionRule,\n\tRuleMark,\n\tScaleType,\n\tSignalRef,\n\tSymbolMark,\n\tTextEncodeEntry,\n\tTextMark,\n} from 'vega';\n\nimport { DEFAULT_FONT_COLOR, DEFAULT_LABEL_FONT_WEIGHT } from '@spectrum-charts/constants';\nimport { getColorValue } from '@spectrum-charts/themes';\n\nimport { getPathFromIcon } from '../specUtils';\nimport { AxisSpecOptions, Position, ReferenceLineOptions, ReferenceLineSpecOptions } from '../types';\nimport { isVerticalAxis } from './axisUtils';\n\nexport const getReferenceLines = (axisOptions: AxisSpecOptions): ReferenceLineSpecOptions[] => {\n\treturn axisOptions.referenceLines.map((referenceLine, index) =>\n\t\tapplyReferenceLineOptionDefaults(referenceLine, axisOptions, index)\n\t);\n};\n\nconst applyReferenceLineOptionDefaults = (\n\toptions: ReferenceLineOptions,\n\taxisOptions: AxisSpecOptions,\n\tindex: number\n): ReferenceLineSpecOptions => ({\n\t...options,\n\tcolor: options.color || 'gray-800',\n\tcolorScheme: axisOptions.colorScheme,\n\ticonColor: options.iconColor || DEFAULT_FONT_COLOR,\n\tlabelColor: options.labelColor || DEFAULT_FONT_COLOR,\n\tlabelFontWeight: options.labelFontWeight ?? DEFAULT_LABEL_FONT_WEIGHT,\n\tlayer: options.layer ?? 'front',\n\tname: `${axisOptions.name}ReferenceLine${index}`,\n});\n\nexport const scaleTypeSupportsReferenceLines = (scaleType: ScaleType | undefined): boolean => {\n\tconst supportedScaleTypes: ScaleType[] = ['band', 'linear', 'point', 'time', 'utc'];\n\treturn Boolean(scaleType && supportedScaleTypes.includes(scaleType));\n};\n\nexport const getReferenceLineMarks = (\n\taxisOptions: AxisSpecOptions,\n\tscaleName: string\n): { back: Mark[]; front: Mark[] } => {\n\tconst referenceLineMarks: { back: Mark[]; front: Mark[] } = { back: [], front: [] };\n\tconst referenceLines = getReferenceLines(axisOptions);\n\n\tfor (const referenceLine of referenceLines) {\n\t\tconst { layer } = referenceLine;\n\t\tconst positionEncoding = getPositionEncoding(axisOptions, referenceLine, scaleName);\n\t\treferenceLineMarks[layer].push(\n\t\t\t...[\n\t\t\t\tgetReferenceLineRuleMark(axisOptions, referenceLine, positionEncoding),\n\t\t\t\t...getReferenceLineSymbolMark(axisOptions, referenceLine, positionEncoding),\n\t\t\t\t...getReferenceLineTextMark(axisOptions, referenceLine, positionEncoding),\n\t\t\t]\n\t\t);\n\t}\n\treturn referenceLineMarks;\n};\n\nexport const getPositionEncoding = (\n\t{ scaleType }: AxisSpecOptions,\n\t{ value, position }: ReferenceLineSpecOptions,\n\tscaleName: string\n): ProductionRule<NumericValueRef> | SignalRef => {\n\tconst signalValue = typeof value === 'string' ? `'${value}'` : value;\n\tconst halfInnerPaddingFormula = `paddingInner * bandwidth('${scaleName}') / (2 * (1 - paddingInner))`;\n\tconst beforePositionSignal = `scale('${scaleName}', ${signalValue}) - ${halfInnerPaddingFormula}`;\n\tconst centeredPositionSignal = `scale('${scaleName}', ${signalValue}) + bandwidth('${scaleName}') / 2`;\n\tconst afterPositionSignal = `scale('${scaleName}', ${signalValue}) + bandwidth('${scaleName}') + ${halfInnerPaddingFormula}`;\n\tif (scaleType === 'band') {\n\t\tif (position === 'before') return { signal: beforePositionSignal };\n\t\tif (position === 'after') return { signal: afterPositionSignal };\n\t\treturn { signal: centeredPositionSignal };\n\t}\n\treturn { scale: scaleName, value };\n};\n\nexport const getReferenceLineRuleMark = (\n\t{ position, ticks }: AxisSpecOptions,\n\t{ color, colorScheme, name }: ReferenceLineSpecOptions,\n\tpositionEncoding: ProductionRule<NumericValueRef> | SignalRef\n): RuleMark => {\n\tconst startOffset = ticks ? 9 : 0;\n\n\tconst positionOptions: { [key in Position]: Partial<EncodeEntry> } = {\n\t\ttop: {\n\t\t\tx: positionEncoding,\n\t\t\ty: { value: -startOffset },\n\t\t\ty2: { signal: 'height' },\n\t\t},\n\t\tbottom: {\n\t\t\tx: positionEncoding,\n\t\t\ty: { value: 0 },\n\t\t\ty2: { signal: `height + ${startOffset}` },\n\t\t},\n\t\tleft: {\n\t\t\tx: { value: -startOffset },\n\t\t\tx2: { signal: 'width' },\n\t\t\ty: positionEncoding,\n\t\t},\n\t\tright: {\n\t\t\tx: { value: 0 },\n\t\t\tx2: { signal: `width + ${startOffset}` },\n\t\t\ty: positionEncoding,\n\t\t},\n\t};\n\n\treturn {\n\t\tname,\n\t\ttype: 'rule',\n\t\tinteractive: false,\n\t\tencode: {\n\t\t\tenter: {\n\t\t\t\tstroke: { value: getColorValue(color, colorScheme) },\n\t\t\t},\n\t\t\tupdate: {\n\t\t\t\t...positionOptions[position],\n\t\t\t},\n\t\t},\n\t};\n};\n\n/**\n * Gets position values for additional marks for the reference line.\n * @param offset\n * @param positionEncoding\n * @param horizontalOffset\n * @returns SymbolMark\n */\nconst getAdditiveMarkPositionOptions = (\n\toffset: number,\n\tpositionEncoding: ProductionRule<NumericValueRef> | SignalRef,\n\thorizontalOffset?: number\n) => ({\n\ttop: {\n\t\tx: positionEncoding,\n\t\ty: { value: -offset },\n\t},\n\tbottom: {\n\t\tx: positionEncoding,\n\t\ty: { signal: `height + ${offset}` },\n\t},\n\tleft: {\n\t\tx: { value: -offset },\n\t\ty: { ...positionEncoding, offset: horizontalOffset },\n\t},\n\tright: {\n\t\tx: { signal: `width + ${offset}` },\n\t\ty: { ...positionEncoding, offset: horizontalOffset },\n\t},\n});\n\n/**\n * Gets the reference line symbol mark\n * @param AxisSpecOptions\n * @param ReferenceLineSpecOptions\n * @param referenceLineIndex\n * @param positionEncoding\n * @returns SymbolMark\n */\nexport const getReferenceLineSymbolMark = (\n\t{ colorScheme, position }: AxisSpecOptions,\n\t{ icon, iconColor, name }: ReferenceLineSpecOptions,\n\tpositionEncoding: ProductionRule<NumericValueRef> | SignalRef\n): SymbolMark[] => {\n\tif (!icon) return [];\n\n\t// offset the icon from the edge of the chart area\n\tconst OFFSET = 24;\n\tconst positionOptions = getAdditiveMarkPositionOptions(OFFSET, positionEncoding);\n\n\treturn [\n\t\t{\n\t\t\tname: `${name}_symbol`,\n\t\t\ttype: 'symbol',\n\t\t\tencode: {\n\t\t\t\tenter: {\n\t\t\t\t\tshape: {\n\t\t\t\t\t\tvalue: getPathFromIcon(icon),\n\t\t\t\t\t},\n\t\t\t\t\tsize: { value: 324 },\n\t\t\t\t\tfill: { value: getColorValue(iconColor, colorScheme) },\n\t\t\t\t},\n\t\t\t\tupdate: {\n\t\t\t\t\t...positionOptions[position],\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t];\n};\n\n/**\n * Gets the reference line text mark\n * @param AxisSpecOptions\n * @param ReferenceLineSpecOptions\n * @param referenceLineIndex\n * @param positionEncoding\n * @returns TextMark\n */\nexport const getReferenceLineTextMark = (\n\taxisOptions: AxisSpecOptions,\n\treferenceLineOptions: ReferenceLineSpecOptions,\n\tpositionEncoding: ProductionRule<NumericValueRef> | SignalRef\n): TextMark[] => {\n\tconst { label, name } = referenceLineOptions;\n\tif (!label) return [];\n\n\treturn [\n\t\t{\n\t\t\tname: `${name}_label`,\n\t\t\ttype: 'text',\n\t\t\tencode: {\n\t\t\t\t...getReferenceLineLabelsEncoding(axisOptions, { ...referenceLineOptions, label }, positionEncoding),\n\t\t\t},\n\t\t},\n\t];\n};\n\n/**\n * Gets the reference line label encoding\n * @param labelFontWeight\n * @param label\n * @param position\n * @param positionEncoding\n * @param icon\n * @returns updateEncoding\n */\nexport const getReferenceLineLabelsEncoding = (\n\t{ position }: AxisSpecOptions,\n\t{ colorScheme, icon, label, labelColor, labelFontWeight }: ReferenceLineSpecOptions & { label: string },\n\tpositionEncoding: ProductionRule<NumericValueRef> | SignalRef\n): GuideEncodeEntry<TextEncodeEntry> => {\n\tconst VERTICAL_OFFSET = icon ? 48 : 26; // Position label outside of icon.\n\tconst HORIZONTAL_OFFSET = isVerticalAxis(position) && icon ? 24 : 12; // Position label outside of icon for horizontal orientation.\n\tconst positionOptions = getAdditiveMarkPositionOptions(VERTICAL_OFFSET, positionEncoding, HORIZONTAL_OFFSET);\n\n\treturn {\n\t\tupdate: {\n\t\t\ttext: [\n\t\t\t\t{\n\t\t\t\t\tvalue: label,\n\t\t\t\t},\n\t\t\t],\n\t\t\tfontWeight: [\n\t\t\t\t// default to the primary label font weight\n\t\t\t\t{ value: labelFontWeight },\n\t\t\t],\n\t\t\tfill: { value: getColorValue(labelColor, colorScheme) },\n\t\t\t...getEncodedLabelBaselineAlign(position),\n\t\t\t...positionOptions[position],\n\t\t},\n\t};\n};\n\n/**\n * Will return the label align or baseline based on the position\n * These properties are used within the reference line label encoding\n * If this is a vertical axis, it will return the correct baseline property and value\n * Otherwise, it will return the correct align property and value\n * @param position\n * @returns align | baseline\n */\nexport const getEncodedLabelBaselineAlign = (position: Position): EncodeEntry => {\n\tswitch (position) {\n\t\tcase 'top':\n\t\tcase 'bottom':\n\t\t\treturn {\n\t\t\t\talign: { value: 'center' },\n\t\t\t};\n\t\tcase 'left':\n\t\tcase 'right':\n\t\t\treturn {\n\t\t\t\tbaseline: { value: 'center' },\n\t\t\t};\n\t}\n};\n","/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport { produce } from 'immer';\nimport { Axis, Data, GroupMark, Mark, ScaleType, Signal, Spec } from 'vega';\n\nimport {\n\tDEFAULT_COLOR_SCHEME,\n\tDEFAULT_GRANULARITY,\n\tDEFAULT_LABEL_ALIGN,\n\tDEFAULT_LABEL_FONT_WEIGHT,\n\tDEFAULT_LABEL_ORIENTATION,\n} from '@spectrum-charts/constants';\n\nimport {\n\taddAxisAnnotationAxis,\n\taddAxisAnnotationData,\n\taddAxisAnnotationMarks,\n\taddAxisAnnotationSignals,\n\tgetAxisAnnotationsFromChildren,\n} from '../axisAnnotation/axisAnnotationUtils';\nimport { getGenericValueSignal } from '../signal/signalSpecBuilder';\nimport { AxisOptions, AxisSpecOptions, ColorScheme, Label, Orientation, Position } from '../types';\nimport { getAxisLabelsEncoding, getControlledLabelAnchorValues, getLabelValue } from './axisLabelUtils';\nimport { getReferenceLineMarks, getReferenceLines, scaleTypeSupportsReferenceLines } from './axisReferenceLineUtils';\nimport { encodeAxisTitle, getTrellisAxisOptions, isTrellisedChart } from './axisTrellisUtils';\nimport {\n\tgetBaselineRule,\n\tgetDefaultAxis,\n\tgetOpposingScaleType,\n\tgetScale,\n\tgetSubLabelAxis,\n\tgetTimeAxes,\n\thasSubLabels,\n} from './axisUtils';\n\nexport const addAxis = produce<Spec, [AxisOptions & { colorScheme?: ColorScheme; index?: number }]>(\n\t(\n\t\tspec,\n\t\t{\n\t\t\tname,\n\t\t\taxisAnnotations = [],\n\t\t\tbaseline = false,\n\t\t\tbaselineOffset = 0,\n\t\t\tcolorScheme = DEFAULT_COLOR_SCHEME,\n\t\t\tgranularity = DEFAULT_GRANULARITY,\n\t\t\tgrid = false,\n\t\t\thideDefaultLabels = false,\n\t\t\tindex = 0,\n\t\t\tlabelAlign = DEFAULT_LABEL_ALIGN,\n\t\t\tlabelFontWeight = DEFAULT_LABEL_FONT_WEIGHT,\n\t\t\tlabelOrientation = DEFAULT_LABEL_ORIENTATION,\n\t\t\tlabels = [],\n\t\t\tnumberFormat = 'shortNumber',\n\t\t\tposition,\n\t\t\trange,\n\t\t\treferenceLines = [],\n\t\t\tsubLabels = [],\n\t\t\tticks = false,\n\t\t\t...options\n\t\t}\n\t) => {\n\t\t// get the scale that this axis will be associated with\n\t\tconst scale = getScale(spec.scales ?? [], position);\n\t\tconst scaleName = name || scale.name;\n\t\tconst scaleType = scale.type;\n\n\t\t// get the opposing scale\n\t\tconst opposingScaleType = getOpposingScaleType(spec.scales ?? [], position);\n\n\t\t// reconstruct options with defaults\n\t\tconst axisOptions: AxisSpecOptions = {\n\t\t\taxisAnnotations,\n\t\t\tbaseline,\n\t\t\tbaselineOffset,\n\t\t\tcolorScheme,\n\t\t\tgranularity,\n\t\t\tgrid,\n\t\t\thideDefaultLabels,\n\t\t\tindex,\n\t\t\tlabelAlign,\n\t\t\tlabelFontWeight,\n\t\t\tlabelOrientation,\n\t\t\tlabels,\n\t\t\tname: `axis${index}`,\n\t\t\tnumberFormat,\n\t\t\tposition,\n\t\t\trange,\n\t\t\treferenceLines,\n\t\t\tsubLabels,\n\t\t\tticks,\n\t\t\tscaleType: scaleType ?? 'linear',\n\t\t\t...options,\n\t\t};\n\n\t\tspec.data = addAxisData(spec.data ?? [], { ...axisOptions, scaleType: scaleType ?? 'linear' });\n\t\tspec.signals = addAxisSignals(spec.signals ?? [], axisOptions);\n\n\t\t// set custom range if applicable\n\t\tif (range && (scaleType === 'linear' || scaleType === 'time')) {\n\t\t\tscale.domain = range;\n\t\t}\n\n\t\tspec.axes = addAxes(spec.axes ?? [], {\n\t\t\t...axisOptions,\n\t\t\tscaleName,\n\t\t\topposingScaleType,\n\n\t\t\t// we don't want to show the grid on top level\n\t\t\t// axes for trellised charts\n\t\t\tgrid: axisOptions.grid && !isTrellisedChart(spec),\n\t\t});\n\n\t\tspec.marks = addAxesMarks(spec.marks ?? [], {\n\t\t\t...axisOptions,\n\t\t\tscaleName,\n\t\t\topposingScaleType,\n\t\t});\n\n\t\treturn spec;\n\t}\n);\n\nexport const addAxisData = produce<Data[], [AxisSpecOptions & { scaleType: ScaleType }]>((data, options) => {\n\tconst axisAnnotations = getAxisAnnotationsFromChildren(options);\n\taxisAnnotations.forEach((annotationOptions) => {\n\t\taddAxisAnnotationData(data, annotationOptions);\n\t});\n});\n\nexport const addAxisSignals = produce<Signal[], [AxisSpecOptions]>((signals, options) => {\n\tconst { name, labels, position, subLabels, labelOrientation } = options;\n\tif (labels?.length) {\n\t\t// add all the label properties to a signal so that the axis encoding can use it to style each label correctly\n\t\tsignals.push(getGenericValueSignal(`${name}_labels`, getLabelSignalValue(labels, position, labelOrientation)));\n\t}\n\tif (hasSubLabels(options)) {\n\t\t// add all the sublabel properties to a signal so that the axis encoding can use it to style each sublabel correctly\n\t\tsignals.push(\n\t\t\tgetGenericValueSignal(\n\t\t\t\t`${name}_subLabels`,\n\t\t\t\tsubLabels.map((label) => ({\n\t\t\t\t\t...label,\n\t\t\t\t\t// convert label align to vega align\n\t\t\t\t\t...getControlledLabelAnchorValues(position, labelOrientation, label.align),\n\t\t\t\t}))\n\t\t\t)\n\t\t);\n\t}\n\tconst axisAnnotations = getAxisAnnotationsFromChildren(options);\n\taxisAnnotations.forEach((annotationOptions) => {\n\t\taddAxisAnnotationSignals(signals, annotationOptions);\n\t});\n});\n\n/**\n * Gets the labels that have style properties on them and gets the correct alignment value based on axis position\n * @param labels\n * @param position\n * @returns\n */\nexport const getLabelSignalValue = (\n\tlabels: (Label | string | number)[],\n\tposition: Position,\n\tlabelOrientation: Orientation\n) =>\n\tlabels\n\t\t.map((label) => {\n\t\t\t// if this label is a string or number, then it doesn't need to be a signal\n\t\t\tif (typeof label !== 'object') {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\treturn {\n\t\t\t\t...label,\n\t\t\t\t...getControlledLabelAnchorValues(position, labelOrientation, label.align),\n\t\t\t};\n\t\t})\n\t\t.filter(Boolean);\n\nexport const addAxes = produce<Axis[], [AxisSpecOptions & { scaleName: string; opposingScaleType?: string }]>(\n\t(axes, { scaleName, opposingScaleType, ...axisOptions }) => {\n\t\tconst newAxes: Axis[] = [];\n\t\t// adds all the trellis axis options if this is a trellis axis\n\t\taxisOptions = { ...axisOptions, ...getTrellisAxisOptions(scaleName) };\n\t\tconst { baseline, labelAlign, labelFontWeight, labelFormat, labelOrientation, name, position } = axisOptions;\n\t\tif (labelFormat === 'time') {\n\t\t\t// time axis actually needs two axes. A primary and secondary.\n\t\t\tnewAxes.push(...getTimeAxes(scaleName, axisOptions));\n\t\t} else {\n\t\t\tconst axis = getDefaultAxis(axisOptions, scaleName);\n\n\t\t\t// if labels exist, add them to the axis\n\t\t\tif (axisOptions.labels.length) {\n\t\t\t\tconst labels = axisOptions.labels;\n\t\t\t\tconst signalName = `${name}_labels`;\n\t\t\t\taxis.values = labels.map((label) => getLabelValue(label));\n\t\t\t\taxis.encode = {\n\t\t\t\t\tlabels: getAxisLabelsEncoding(\n\t\t\t\t\t\tlabelAlign,\n\t\t\t\t\t\tlabelFontWeight,\n\t\t\t\t\t\t'label',\n\t\t\t\t\t\tlabelOrientation,\n\t\t\t\t\t\tposition,\n\t\t\t\t\t\tsignalName\n\t\t\t\t\t),\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// if sublabels exist, create a new axis for the sub labels\n\t\t\tif (hasSubLabels(axisOptions)) {\n\t\t\t\taxis.titlePadding = 24;\n\n\t\t\t\t// add sublabel axis\n\t\t\t\tnewAxes.push(getSubLabelAxis(axisOptions, scaleName));\n\t\t\t}\n\t\t\tnewAxes.unshift(axis);\n\t\t}\n\n\t\t// add baseline\n\t\tif (opposingScaleType !== 'linear') {\n\t\t\tnewAxes[0] = setAxisBaseline(newAxes[0], baseline);\n\t\t}\n\n\t\tif (scaleTypeSupportsReferenceLines(axisOptions.scaleType)) {\n\t\t\t// encode axis to hide labels that overlap reference line icons\n\t\t\tconst referenceLines = getReferenceLines(axisOptions);\n\t\t\treferenceLines.forEach((referenceLineOptions) => {\n\t\t\t\tconst { label: referenceLineLabel, icon, value, position: linePosition } = referenceLineOptions;\n\t\t\t\tconst text = newAxes[0].encode?.labels?.update?.text;\n\t\t\t\tif (\n\t\t\t\t\t(icon || referenceLineLabel) &&\n\t\t\t\t\ttext &&\n\t\t\t\t\tArray.isArray(text) &&\n\t\t\t\t\t(!linePosition || linePosition === 'center')\n\t\t\t\t) {\n\t\t\t\t\t// if the label is within 30 pixels of the reference line icon, hide it\n\t\t\t\t\ttext.unshift({\n\t\t\t\t\t\ttest: `abs(scale('${scaleName}', ${value}) - scale('${scaleName}', datum.value)) < 30`,\n\t\t\t\t\t\tvalue: '',\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tconst axisAnnotations = getAxisAnnotationsFromChildren(axisOptions);\n\t\taxisAnnotations.forEach((annotationOptions) => {\n\t\t\taddAxisAnnotationAxis(newAxes, annotationOptions, scaleName);\n\t\t});\n\n\t\taxes.push(...newAxes);\n\t}\n);\n\nexport const addAxesMarks = produce<\n\tMark[],\n\t[AxisSpecOptions & { scaleName: string; scaleType?: ScaleType; opposingScaleType?: string }]\n>((marks, options) => {\n\tconst { baseline, baselineOffset, opposingScaleType, position, scaleName, scaleType } = options;\n\n\t// only add reference lines to linear or time scales\n\tif (scaleTypeSupportsReferenceLines(scaleType)) {\n\t\tconst { back, front } = getReferenceLineMarks(options, scaleName);\n\t\tmarks.unshift(...back);\n\t\tmarks.push(...front);\n\t}\n\n\tconst trellisGroupMark = marks.find((mark) => mark.name?.includes('Trellis')) as GroupMark;\n\tconst isTrellised = Boolean(trellisGroupMark);\n\n\tif (baseline && opposingScaleType === 'linear') {\n\t\taddBaseline(marks, baselineOffset, position, trellisGroupMark);\n\t}\n\n\tif (isTrellised) {\n\t\taddAxesToTrellisGroup(options, trellisGroupMark, scaleName);\n\t}\n\n\tconst axisAnnotations = getAxisAnnotationsFromChildren(options);\n\taxisAnnotations.forEach((annotationOptions) => {\n\t\taddAxisAnnotationMarks(marks, annotationOptions, scaleName);\n\t});\n});\n\nfunction addBaseline(marks: Mark[], baselineOffset: number, position: Position, trellisGroupMark: GroupMark) {\n\tconst baselineRule = getBaselineRule(baselineOffset, position);\n\n\t// if the chart is trellised, add the baseline to the trellis mark group\n\tif (trellisGroupMark && 'marks' in trellisGroupMark) {\n\t\tif (baselineOffset === 0) {\n\t\t\ttrellisGroupMark.marks?.push(baselineRule);\n\t\t} else {\n\t\t\ttrellisGroupMark.marks?.unshift(baselineRule);\n\t\t}\n\t} else if (baselineOffset === 0) {\n\t\tmarks.push(baselineRule);\n\t} else {\n\t\tmarks.unshift(baselineRule);\n\t}\n}\n\nfunction addAxesToTrellisGroup(options: AxisSpecOptions, trellisGroupMark: GroupMark, scaleName: string) {\n\tconst trellisOrientation = trellisGroupMark.name?.startsWith('x') ? 'horizontal' : 'vertical';\n\tconst axisOrientation = options.position === 'bottom' || options.position === 'top' ? 'horizontal' : 'vertical';\n\n\t// hide labels if the axis is not in the same orientation as the trellis\n\t// for example, we don't want x-axis labels on a vertical trellis\n\tconst hideDefaultLabels = options.hideDefaultLabels || trellisOrientation !== axisOrientation;\n\n\tlet scaleType = options.scaleType;\n\t// get the scale that this axis will be associated with\n\tif (trellisOrientation === axisOrientation) {\n\t\tconst scale = getScale(trellisGroupMark.scales ?? [], options.position);\n\t\tscaleName = scale.name;\n\t\tscaleType = scale.type ?? 'linear';\n\t} else {\n\t\t// if the axis is not the same orientation as the trellis, then we don't display the title\n\t\t// because it will be displayed on the root axis at the spec level\n\t\toptions.title = undefined;\n\t}\n\n\tlet newAxes = addAxes([], {\n\t\t...options,\n\t\thideDefaultLabels,\n\t\tscaleName,\n\t\tscaleType,\n\t});\n\n\t// titles on axes within the trellis group have special encodings so that the title is only shown on the first axis\n\tnewAxes = encodeAxisTitle(newAxes, trellisGroupMark);\n\n\ttrellisGroupMark.axes = [...(trellisGroupMark.axes ?? []), ...newAxes];\n}\n\nexport function setAxisBaseline(axis: Axis, baseline = false): Axis {\n\t// Vega's property is \"domain\" - we use \"baseline\"\n\treturn { ...axis, domain: baseline, domainWidth: 2 };\n}\n","/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport { Axis, GroupMark, Spec } from 'vega';\n\nimport { AxisSpecOptions } from '../types';\n\n/**\n * Checks the spec to see if it is a trellised chart\n * @param spec\n * @returns\n */\nexport const isTrellisedChart = (spec: Spec): boolean => {\n\treturn /[xy]TrellisGroup/g.test(JSON.stringify(spec));\n};\n\n/**\n * Gets all the custom options for a trellis axis\n * If this axis is not a trellis axis, it will return an empty object\n * @param scaleName\n * @returns trellisAxisOptions\n */\nexport const getTrellisAxisOptions = (scaleName: string): Partial<AxisSpecOptions> => {\n\tlet trellisAxisOptions: Partial<AxisSpecOptions> = {};\n\n\t// if 'TrellisBand' is in the scale name then this is a trellis axis\n\tif (scaleName.includes('TrellisBand')) {\n\t\t// shift the labels up/left half the scale bandwidth\n\t\tconst labelOffsetSignal = `bandwidth('${scaleName}') / -2`;\n\t\tconst axisType = scaleName.startsWith('x') ? 'x' : 'y';\n\t\ttrellisAxisOptions = {\n\t\t\tposition: axisType === 'x' ? 'top' : 'left',\n\t\t\tlabelFontWeight: 'bold',\n\t\t\tlabelAlign: undefined, // set this to undefined because we will manually control alignment\n\t\t\ttitle: undefined,\n\t\t\tvegaLabelAlign: 'left',\n\t\t\tvegaLabelBaseline: 'bottom',\n\t\t\tvegaLabelOffset: axisType === 'x' ? { signal: labelOffsetSignal } : { signal: `${labelOffsetSignal} - 8` }, // y axis needs an extra 8px as vertical padding\n\t\t\tvegaLabelPadding: axisType === 'x' ? 8 : 0, // add vertical padding\n\t\t};\n\t}\n\treturn trellisAxisOptions;\n};\n\n/**\n * Adds title encodings so that only the first title is visible.\n * Does not mutate axes but instead returns a copy with the correct encodings added.\n * @param axes\n * @param trellisGroupMark\n * @returns axes\n */\nexport const encodeAxisTitle = (axes: Axis[], trellisGroupMark: GroupMark) => {\n\tconst { facetName, facetGroupBy, trellisScaleName } = getTrellisGroupProperties(trellisGroupMark);\n\n\treturn axes.map((axis) => {\n\t\tif (axis.title) {\n\t\t\treturn {\n\t\t\t\t...axis,\n\t\t\t\tencode: {\n\t\t\t\t\t...axis.encode,\n\t\t\t\t\ttitle: {\n\t\t\t\t\t\tupdate: {\n\t\t\t\t\t\t\topacity: [\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\ttest: `info(domain('${trellisScaleName}')[0] === data('${facetName}')[0].${facetGroupBy})`,\n\t\t\t\t\t\t\t\t\tvalue: 1,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t{ value: 0 },\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t\treturn axis;\n\t});\n};\n\n/**\n * Gets properties of the trellis group mark\n * @param groupMark\n * @returns properties\n */\nexport const getTrellisGroupProperties = (\n\tgroupMark: GroupMark\n): { facetGroupBy: string; facetName: string; trellisScaleName: string } => {\n\tconst trellisScaleName = `${(groupMark.name ?? 'x')[0]}TrellisBand`;\n\tconst fromFacet = groupMark.from as { facet: { name: string; groupby: string } };\n\n\treturn { facetGroupBy: fromFacet.facet.groupby, facetName: fromFacet.facet.name, trellisScaleName };\n};\n","/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport { Axis, Mark, Scale, SignalRef } from 'vega';\n\nimport { AxisSpecOptions, Granularity, Position } from '../types';\nimport {\n\tgetAxisLabelsEncoding,\n\tgetLabelAnchorValues,\n\tgetLabelAngle,\n\tgetLabelFormat,\n\tgetLabelOffset,\n\tgetTimeLabelFormats,\n} from './axisLabelUtils';\n\n/**\n * Generates a default vega axis from the axis options\n * @param axisOptions\n * @param scaleName\n * @returns axis\n */\nexport const getDefaultAxis = (axisOptions: AxisSpecOptions, scaleName: string): Axis => {\n\tconst {\n\t\tgrid,\n\t\thideDefaultLabels,\n\t\tlabelAlign,\n\t\tlabelFontWeight,\n\t\tlabelOrientation,\n\t\tposition,\n\t\tscaleType,\n\t\tticks,\n\t\ttickMinStep,\n\t\ttitle,\n\t\tvegaLabelAlign,\n\t\tvegaLabelBaseline,\n\t\tvegaLabelOffset,\n\t\tvegaLabelPadding,\n\t} = axisOptions;\n\treturn {\n\t\tscale: scaleName,\n\t\torient: position,\n\t\tgrid,\n\t\tticks,\n\t\ttickCount: getTickCount(position, grid),\n\t\ttickMinStep: scaleType !== 'linear' ? undefined : tickMinStep, //only supported for linear scales\n\t\ttitle,\n\t\tlabelAngle: getLabelAngle(labelOrientation),\n\t\tlabelFontWeight,\n\t\tlabelOffset: getLabelOffset(labelAlign, scaleName, vegaLabelOffset),\n\t\tlabelPadding: vegaLabelPadding,\n\t\tlabels: !hideDefaultLabels,\n\t\t...getLabelAnchorValues(position, labelOrientation, labelAlign, vegaLabelAlign, vegaLabelBaseline),\n\t\tencode: {\n\t\t\tlabels: {\n\t\t\t\tupdate: {\n\t\t\t\t\ttext: getLabelFormat(axisOptions, scaleName),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t};\n};\n\n/**\n * Generates the time axes for a time scale from the axis options\n * @param scaleName\n * @param axisOptions\n * @returns axes\n */\nexport const getTimeAxes = (scaleName: string, axisOptions: AxisSpecOptions): Axis[] => {\n\treturn [getSecondaryTimeAxis(scaleName, axisOptions), ...getPrimaryTimeAxis(scaleName, axisOptions)];\n};\n\n/**\n * Generates the secondary time axis from the axis options\n * This is the axis that shows the smaller granularity\n * If this is a vertical axis, it will also show the larger granularity and will hide repeats of the larger granularity\n * @param scaleName\n * @param axisOptions\n * @returns axis\n */\nconst getSecondaryTimeAxis = (\n\tscaleName: string,\n\t{\n\t\tgranularity,\n\t\tgrid,\n\t\tlabelAlign,\n\t\tlabelOrientation,\n\t\tposition,\n\t\tticks,\n\t\ttitle,\n\t\tvegaLabelAlign,\n\t\tvegaLabelBaseline,\n\t}: AxisSpecOptions\n): Axis => {\n\tconst { tickCount } = getTimeLabelFormats(granularity);\n\n\treturn {\n\t\tscale: scaleName,\n\t\torient: position,\n\t\tgrid,\n\t\tticks,\n\t\ttickCount: scaleName.includes('Time') ? tickCount : undefined,\n\t\ttitle,\n\t\tformatType: 'time',\n\t\tlabelAngle: getLabelAngle(labelOrientation),\n\t\tlabelSeparation: 12,\n\t\t...getSecondaryTimeAxisLabelFormatting(granularity, position),\n\t\t...getLabelAnchorValues(position, labelOrientation, labelAlign, vegaLabelAlign, vegaLabelBaseline),\n\t};\n};\n\nconst getSecondaryTimeAxisLabelFormatting = (granularity: Granularity, position: Position): Partial<Axis> => {\n\tconst { secondaryLabelFormat, primaryLabelFormat } = getTimeLabelFormats(granularity);\n\tconst isVerticalAxis = ['left', 'right'].includes(position);\n\tif (isVerticalAxis) {\n\t\treturn {\n\t\t\tformat: `${primaryLabelFormat}\\u2000${secondaryLabelFormat}`,\n\t\t\tencode: {\n\t\t\t\tlabels: {\n\t\t\t\t\tupdate: {\n\t\t\t\t\t\ttext: { signal: 'formatVerticalAxisTimeLabels(datum)' },\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\t}\n\n\treturn {\n\t\tformat: secondaryLabelFormat,\n\t};\n};\n\n/**\n * Generates the primary time axis from the axis options\n * This is the axis that shows the larger granularity and hides duplicate labels\n * Only returns an axis for horizontal axes\n * @param scaleName\n * @param axisOptions\n * @returns axis\n */\nconst getPrimaryTimeAxis = (\n\tscaleName: string,\n\t{\n\t\tgranularity,\n\t\tlabelAlign,\n\t\tlabelOrientation,\n\t\tlabelFontWeight,\n\t\tposition,\n\t\tticks,\n\t\tvegaLabelAlign,\n\t\tvegaLabelBaseline,\n\t}: AxisSpecOptions\n): Axis[] => {\n\tif (['left', 'right'].includes(position)) {\n\t\treturn [];\n\t}\n\tconst { primaryLabelFormat, tickCount } = getTimeLabelFormats(granularity);\n\treturn [\n\t\t{\n\t\t\tscale: scaleName,\n\t\t\torient: position,\n\t\t\tformat: primaryLabelFormat,\n\t\t\ttickCount: scaleName.includes('Time') ? tickCount : undefined,\n\t\t\tformatType: 'time',\n\t\t\tlabelOverlap: 'greedy',\n\t\t\tlabelFontWeight,\n\t\t\tlabelAngle: getLabelAngle(labelOrientation),\n\t\t\t...getLabelAnchorValues(position, labelOrientation, labelAlign, vegaLabelAlign, vegaLabelBaseline),\n\t\t\tencode: {\n\t\t\t\tlabels: {\n\t\t\t\t\tenter: {\n\t\t\t\t\t\tdy: { value: (ticks ? 28 : 20) * (position === 'top' ? -1 : 1) }, // account for tick height\n\t\t\t\t\t},\n\t\t\t\t\tupdate: {\n\t\t\t\t\t\ttext: { signal: 'formatHorizontalTimeAxisLabels(datum)' },\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t];\n};\n\n/**\n * Generates an axis for sub labels from the axis options\n * @param axisOptions\n * @param scaleName\n * @returns axis\n */\nexport const getSubLabelAxis = (axisOptions: AxisSpecOptions, scaleName: string): Axis => {\n\tconst { labelAlign, labelFontWeight, labelOrientation, name, position, ticks } = axisOptions;\n\tconst subLabels = axisOptions.subLabels;\n\tconst signalName = `${name}_subLabels`;\n\tconst subLabelValues = subLabels.map((label) => label.value);\n\n\tlet subLabelAxis = getDefaultAxis(axisOptions, scaleName);\n\tsubLabelAxis = {\n\t\t...subLabelAxis,\n\t\tdomain: false,\n\t\tdomainWidth: undefined,\n\t\tgrid: false,\n\t\tlabelPadding: ticks ? 32 : 24,\n\t\tticks: false,\n\t\ttitle: undefined,\n\t\tvalues: subLabelValues.length ? subLabelValues : undefined,\n\t\tencode: {\n\t\t\tlabels: {\n\t\t\t\t...getAxisLabelsEncoding(\n\t\t\t\t\tlabelAlign,\n\t\t\t\t\tlabelFontWeight,\n\t\t\t\t\t'subLabel',\n\t\t\t\t\tlabelOrientation,\n\t\t\t\t\tposition,\n\t\t\t\t\tsignalName\n\t\t\t\t),\n\t\t\t},\n\t\t},\n\t};\n\treturn subLabelAxis;\n};\n\n/**\n * Finds and returns the scale that this axis is for\n * If the scale does not exist, it will create a new one\n * @param scales\n * @param position\n * @returns scale\n */\nexport const getScale = (scales: Scale[], position: Position) => {\n\tconst applicableScales = scales.filter((s) => 'range' in s && s.range === getRange(position));\n\tlet scale: Scale | undefined;\n\n\tif (applicableScales.length > 1) {\n\t\t// Is there a better way to find the trellis scale?\n\t\tscale = scales.find((s) => s.name.includes('Trellis')) ?? applicableScales[0];\n\t} else {\n\t\tscale = applicableScales[0];\n\t}\n\n\tif (scale) {\n\t\treturn scale;\n\t}\n\n\tscale = {\n\t\tname: getDefaultScaleNameFromPosition(position),\n\t\ttype: 'linear',\n\t\trange: getRange(position),\n\t};\n\tscales.push(scale);\n\treturn scale;\n};\n\n/**\n * Gets the scale range from the position\n * @param position\n * @returns range\n */\nexport const getRange = (position: Position): 'width' | 'height' => {\n\tif (position === 'left' || position === 'right') {\n\t\treturn 'height';\n\t}\n\treturn 'width';\n};\n\n/**\n * Gets the scale type of the opposing scale.\n * For example, if this is an x-axis, it will return the y-scale type\n * @param scales\n * @param position\n * @returns scaleType\n */\nexport const getOpposingScaleType = (scales: Scale[], position: Position) => {\n\tlet scale = scales.find((s) => 'range' in s && s.range === getOpposingRange(position));\n\tif (scale) {\n\t\treturn scale.type;\n\t}\n\tscale = {\n\t\tname: getDefaultOpposingScaleNameFromPosition(position),\n\t\ttype: 'linear',\n\t\trange: getOpposingRange(position),\n\t};\n\tscales.push(scale);\n\treturn scale.type;\n};\n\n/**\n * Gets the scale range for the opposing scale\n * @param position\n * @returns\n */\nexport const getOpposingRange = (position: Position): 'width' | 'height' => {\n\tif (position === 'left' || position === 'right') {\n\t\treturn 'width';\n\t}\n\treturn 'height';\n};\n\n/**\n * Returns whether the axis is vertical.\n * @param position\n * @returns boolean\n */\nexport const isVerticalAxis = (position: Position): boolean => {\n\treturn ['left', 'right'].includes(position);\n};\n\n/**\n * Gets the default scale name based on the position\n * @param position\n * @returns scaleName\n */\nconst getDefaultScaleNameFromPosition = (position: Position) => {\n\treturn isVerticalAxis(position) ? 'yLinear' : 'xLinear';\n};\n\n/**\n * Gets the default opposing scale name based on the position\n * @param position\n * @returns scaleName\n */\nconst getDefaultOpposingScaleNameFromPosition = (position: Position) => {\n\treturn isVerticalAxis(position) ? 'xLinear' : 'yLinear';\n};\n\n/**\n * clamps the tick count to a min of 2 and max of 5 for linear scales\n * @param position\n * @param grid\n * @returns tickCount production rule\n */\nexport const getTickCount = (position: Position, grid: boolean): SignalRef | undefined => {\n\tif (!grid) return;\n\tconst range = ['top', 'bottom'].includes(position) ? 'width' : 'height';\n\t// divide the range by 100 to get the ideal number of ticks (grid lines)\n\t// clamp axis tick count to a min of 2 and max of 10\n\treturn { signal: `clamp(ceil(${range}/100), 2, 10)` };\n};\n\n/**\n * Gets the baseline rule mark\n * @param baselineOffset\n * @param position\n * @returns baselineMark\n */\nexport const getBaselineRule = (baselineOffset: number, position: Position): Mark => {\n\tconst orientation = isVerticalAxis(position) ? 'y' : 'x';\n\n\tconst positionOptions = {\n\t\tx: {\n\t\t\tx: { value: 0 },\n\t\t\tx2: { signal: 'width' },\n\t\t\ty: { scale: 'yLinear', value: baselineOffset },\n\t\t},\n\t\ty: {\n\t\t\tx: { scale: 'xLinear', value: baselineOffset },\n\t\t\ty: { value: 0 },\n\t\t\ty2: { signal: 'height' },\n\t\t},\n\t};\n\n\treturn {\n\t\tname: `${orientation}Baseline`,\n\t\tdescription: `${orientation}Baseline`,\n\t\ttype: 'rule',\n\t\tinteractive: false,\n\t\tencode: {\n\t\t\tupdate: {\n\t\t\t\t...positionOptions[orientation],\n\t\t\t},\n\t\t},\n\t};\n};\n\nexport const hasSubLabels = ({ subLabels, labelOrientation }: AxisSpecOptions) => {\n\t// subLabels are only supported for horizontal axis labels\n\treturn Boolean(subLabels.length && labelOrientation === 'horizontal');\n};\n","/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport { Axis, Data, Mark, ScaleType, Signal, SourceData, ValuesData } from 'vega';\n\nimport {\n\tANNOTATION_RANGED_ICON_SVG,\n\tANNOTATION_SINGLE_ICON_SVG,\n\tDEFAULT_AXIS_ANNOTATION_COLOR,\n\tDEFAULT_AXIS_ANNOTATION_OFFSET,\n\tFILTERED_TABLE,\n} from '@spectrum-charts/constants';\nimport { getColorValue } from '@spectrum-charts/themes';\n\nimport { getCursor } from '../marks/markUtils';\nimport { AxisAnnotationOptions, AxisAnnotationSpecOptions, AxisSpecOptions, ColorScheme, Position } from '../types';\n\n/**\n * Adds the required data for axis annotations.\n *\n * NOTE: this function should only be called from within a produce with data as the root state since it directly\n * mutates the data array\n * @param data\n * @param axisAnnotationOptions\n */\nexport const addAxisAnnotationData = (\n\tdata: Data[],\n\t{ name, dataKey, color, colorScheme, options, format }: AxisAnnotationSpecOptions\n) => {\n\tdata.push(getAxisAnnotationDetailData(name, options, colorScheme));\n\tif (format === 'summary') {\n\t\tdata.push(getAxisAnnotationSummaryData(name, dataKey, color, colorScheme));\n\t} else {\n\t\tdata.push(getAxisAnnotationAggregateData(name, dataKey, color, colorScheme), getAxisAnnotationRangeData(name));\n\t}\n};\n\nconst getAxisAnnotationDetailData = (name: string, options, colorScheme): ValuesData => {\n\tconst newOptions = options.map((option) => ({ ...option, color: getColorValue(option.color, colorScheme) }));\n\treturn { name: `${name}_details`, values: newOptions };\n};\n\nconst getAxisAnnotationAggregateData = (name, dataKey, color, colorScheme): SourceData => {\n\treturn {\n\t\tname: `${name}_aggregate`,\n\t\tsource: FILTERED_TABLE,\n\t\ttransform: [\n\t\t\t{ type: 'filter', expr: `datum.${dataKey}` },\n\t\t\t{\n\t\t\t\ttype: 'flatten',\n\t\t\t\tfields: [dataKey],\n\t\t\t\tas: [`${name}_id`],\n\t\t\t},\n\t\t\t{\n\t\t\t\ttype: 'aggregate',\n\t\t\t\tgroupby: [`${name}_id`],\n\t\t\t\tfields: ['datetime', 'datetime'],\n\t\t\t\tops: ['min', 'max'],\n\t\t\t},\n\t\t\t{\n\t\t\t\ttype: 'formula',\n\t\t\t\texpr: 'datum.max_datetime - datum.min_datetime',\n\t\t\t\tas: 'width',\n\t\t\t},\n\t\t\t{\n\t\t\t\ttype: 'formula',\n\t\t\t\texpr: 'datum.width / 2 + datum.min_datetime',\n\t\t\t\tas: 'center',\n\t\t\t},\n\t\t\t{\n\t\t\t\ttype: 'aggregate',\n\t\t\t\tgroupby: ['center'],\n\t\t\t\tfields: ['min_datetime', 'max_datetime', 'width', dataKey, dataKey],\n\t\t\t\tops: ['min', 'max', 'max', 'count', 'values'],\n\t\t\t\tas: ['lower', 'upper', 'width', 'number', 'annotations'],\n\t\t\t},\n\t\t\t{\n\t\t\t\ttype: 'formula',\n\t\t\t\texpr: `datum.annotations[0].${name}_id`,\n\t\t\t\tas: 'id',\n\t\t\t},\n\t\t\t{\n\t\t\t\ttype: 'lookup',\n\t\t\t\tfrom: `${name}_details`,\n\t\t\t\tkey: `id`,\n\t\t\t\tvalues: ['color'],\n\t\t\t\tfields: [`id`],\n\t\t\t},\n\t\t\t{\n\t\t\t\ttype: 'formula',\n\t\t\t\texpr: `datum.number > 1 || datum.color == null ? '${getColorValue(color, colorScheme)}' : datum.color`,\n\t\t\t\tas: 'color',\n\t\t\t},\n\t\t],\n\t};\n};\n\nconst getAxisAnnotationSummaryData = (name, dataKey, color, colorScheme): SourceData => {\n\treturn {\n\t\tname: `${name}_summary`,\n\t\tsource: FILTERED_TABLE,\n\t\ttransform: [\n\t\t\t{ type: 'filter', expr: `datum.${dataKey}` },\n\t\t\t{\n\t\t\t\ttype: 'flatten',\n\t\t\t\tfields: [dataKey],\n\t\t\t\tas: [`${name}_id`],\n\t\t\t},\n\t\t\t{\n\t\t\t\ttype: 'aggregate',\n\t\t\t\tgroupby: [`${name}_id`],\n\t\t\t},\n\t\t\t{\n\t\t\t\ttype: 'aggregate',\n\t\t\t\tgroupby: ['center'],\n\t\t\t\tfields: [dataKey, dataKey],\n\t\t\t\tops: ['count', 'values'],\n\t\t\t\tas: ['number', 'annotations'],\n\t\t\t},\n\t\t\t{\n\t\t\t\ttype: 'formula',\n\t\t\t\texpr: `datum.annotations[0].${name}_id`,\n\t\t\t\tas: 'id',\n\t\t\t},\n\t\t\t{\n\t\t\t\ttype: 'lookup',\n\t\t\t\tfrom: `${name}_details`,\n\t\t\t\tkey: `id`,\n\t\t\t\tvalues: ['color'],\n\t\t\t\tfields: [`id`],\n\t\t\t},\n\t\t\t{\n\t\t\t\ttype: 'formula',\n\t\t\t\texpr: `datum.number > 1 || datum.color == null ? '${getColorValue(color, colorScheme)}' : datum.color`,\n\t\t\t\tas: 'color',\n\t\t\t},\n\t\t],\n\t};\n};\n\nconst getAxisAnnotationRangeData = (name: string): SourceData => {\n\treturn {\n\t\tname: `${name}_range`,\n\t\tsource: `${name}_aggregate`,\n\t\ttransform: [\n\t\t\t{\n\t\t\t\ttype: 'filter',\n\t\t\t\texpr: `${name}_highlighted && datum.center == ${name}_highlighted.center && ${name}_highlighted.width > 0`,\n\t\t\t},\n\t\t],\n\t};\n};\n\n/**\n * Adds the required signals for axis annotations.\n *\n * NOTE: this function should only be called from within a produce with signals as the root state since it directly\n * mutates the signals array\n * @param signals\n * @param param1\n */\nexport const addAxisAnnotationSignals = (signals: Signal[], { name, format }: AxisAnnotationSpecOptions) => {\n\tif (format === 'span') {\n\t\tsignals.push(\n\t\t\tgetHighlightAxisAnnotationSignal(name),\n\t\t\tgetClickAxisAnnotationSignal(name),\n\t\t\tgetSelectAxisAnnotationSignal(name)\n\t\t);\n\t}\n};\n\n/**\n * Returns the highlighted axis annotation signal\n */\nconst getHighlightAxisAnnotationSignal = (name: string): Signal => {\n\treturn {\n\t\tname: `${name}_highlighted`,\n\t\tvalue: null,\n\t\ton: [\n\t\t\t{ events: `@${name}_icon:mouseover`, update: `datum` },\n\t\t\t{ events: `@${name}_icon:mouseout`, update: `${name}_clicked` },\n\t\t],\n\t};\n};\n\n/**\n * Returns the selected axis annotation signal\n */\nconst getClickAxisAnnotationSignal = (name: string): Signal => {\n\treturn {\n\t\tname: `${name}_clicked`,\n\t\tvalue: {},\n\t\ton: [\n\t\t\t{\n\t\t\t\tevents: {\n\t\t\t\t\tmarkname: `${name}_icon`,\n\t\t\t\t\ttype: 'mousedown',\n\t\t\t\t\tbetween: [{ type: 'mousedown' }, { type: 'mouseup' }],\n\t\t\t\t},\n\t\t\t\tupdate: 'datum',\n\t\t\t},\n\t\t\t{ events: 'window:mouseup', update: '{}' },\n\t\t],\n\t};\n};\n\n/**\n * Returns the selected axis annotation static signal\n */\nconst getSelectAxisAnnotationSignal = (name: string): Signal => {\n\treturn {\n\t\tname: `${name}_selected`,\n\t\tupdate: `${name}_clicked.center`,\n\t};\n};\n\n/**\n * Adds the required marks for axis annotations.\n *\n * NOTE: this function should only be called from within a produce with marks as the root state since it directly\n * mutates the marks array\n * @param marks\n * @param param1\n */\nexport const addAxisAnnotationMarks = (\n\tmarks: Mark[],\n\taxisAnnotationOptions: AxisAnnotationSpecOptions,\n\tscaleName: string\n) => {\n\tconst { format } = axisAnnotationOptions;\n\tif (format === 'summary') {\n\t\tmarks.push(getAxisAnnotationSummaryMarks(axisAnnotationOptions));\n\t} else {\n\t\tmarks.push(getAxisAnnotationSpanMarks(axisAnnotationOptions, scaleName));\n\t}\n};\n\n/**\n * NOTE: this function should only be called from within a produce with marks as the root state since it directly\n * mutates the marks array\n * @param marks\n * @param param1\n */\nexport const getAxisAnnotationSummaryMarks = ({ chartPopovers, name, offset }: AxisAnnotationSpecOptions): Mark => {\n\treturn {\n\t\tname: `${name}_group`,\n\t\ttype: 'group',\n\t\tfrom: {\n\t\t\tdata: `${name}_summary`,\n\t\t},\n\t\tmarks: [\n\t\t\t{\n\t\t\t\tname: `${name}_icon`,\n\t\t\t\ttype: 'path',\n\t\t\t\tfrom: {\n\t\t\t\t\tdata: `${name}_summary`,\n\t\t\t\t},\n\t\t\t\tzindex: 2,\n\t\t\t\tencode: {\n\t\t\t\t\tenter: {\n\t\t\t\t\t\t// adding a 2px transparent border increases the area of the icon so it's easier to hover\n\t\t\t\t\t\tstroke: { value: 'transparent' },\n\t\t\t\t\t\tstrokeWidth: { value: 2 },\n\t\t\t\t\t\tcursor: getCursor(chartPopovers),\n\t\t\t\t\t},\n\t\t\t\t\tupdate: {\n\t\t\t\t\t\tpath: {\n\t\t\t\t\t\t\tsignal: `'${ANNOTATION_SINGLE_ICON_SVG}'`,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfill: {\n\t\t\t\t\t\t\tfield: 'color',\n\t\t\t\t\t\t},\n\t\t\t\t\t\txc: {\n\t\t\t\t\t\t\tsignal: `width - 12`,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tyc: {\n\t\t\t\t\t\t\tsignal: `height + ${offset}`,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t],\n\t};\n};\n\n/**\n * Adds the required marks for axis annotations that support time series axis.\n * @param marks\n * @param param1\n */\nexport const getAxisAnnotationSpanMarks = (\n\t{ chartPopovers, name, offset }: AxisAnnotationSpecOptions,\n\tscaleName: string\n): Mark => {\n\treturn {\n\t\tname: `${name}_group`,\n\t\ttype: 'group',\n\t\tmarks: [\n\t\t\t{\n\t\t\t\tname: `${name}_range`,\n\t\t\t\ttype: 'group',\n\t\t\t\tmarks: [\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: 'rect',\n\t\t\t\t\t\tfrom: {\n\t\t\t\t\t\t\tdata: `${name}_range`,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tencode: {\n\t\t\t\t\t\t\tupdate: {\n\t\t\t\t\t\t\t\tx: {\n\t\t\t\t\t\t\t\t\tscale: scaleName,\n\t\t\t\t\t\t\t\t\tfield: 'lower',\n\t\t\t\t\t\t\t\t\tband: 0.5,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\ty: { signal: `height + ${offset}` },\n\t\t\t\t\t\t\t\twidth: { value: 2 },\n\t\t\t\t\t\t\t\theight: { value: -4 },\n\t\t\t\t\t\t\t\tfill: { field: 'color' },\n\t\t\t\t\t\t\t\tfillOpacity: {\n\t\t\t\t\t\t\t\t\tsignal: `${name}_selected ? 1.0 : 0.2`,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: 'rect',\n\t\t\t\t\t\tfrom: {\n\t\t\t\t\t\t\tdata: `${name}_range`,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tencode: {\n\t\t\t\t\t\t\tupdate: {\n\t\t\t\t\t\t\t\tx: {\n\t\t\t\t\t\t\t\t\tscale: scaleName,\n\t\t\t\t\t\t\t\t\tfield: 'lower',\n\t\t\t\t\t\t\t\t\tband: 0.5,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\ty: { signal: `height + ${offset}` },\n\t\t\t\t\t\t\t\tx2: {\n\t\t\t\t\t\t\t\t\tscale: scaleName,\n\t\t\t\t\t\t\t\t\tfield: 'upper',\n\t\t\t\t\t\t\t\t\tband: 0.5,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\theight: { value: 2 },\n\t\t\t\t\t\t\t\tfill: { field: 'color' },\n\t\t\t\t\t\t\t\tfillOpacity: {\n\t\t\t\t\t\t\t\t\tsignal: `${name}_selected ? 1.0 : 0.2`,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: 'rect',\n\t\t\t\t\t\tfrom: {\n\t\t\t\t\t\t\tdata: `${name}_range`,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tencode: {\n\t\t\t\t\t\t\tupdate: {\n\t\t\t\t\t\t\t\tx: {\n\t\t\t\t\t\t\t\t\tscale: scaleName,\n\t\t\t\t\t\t\t\t\tfield: 'upper',\n\t\t\t\t\t\t\t\t\tband: 0.5,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\ty: { signal: `height + ${offset} + 2` },\n\t\t\t\t\t\t\t\twidth: { value: 2 },\n\t\t\t\t\t\t\t\theight: { value: -6 },\n\t\t\t\t\t\t\t\tfill: { field: 'color' },\n\t\t\t\t\t\t\t\tfillOpacity: {\n\t\t\t\t\t\t\t\t\tsignal: `${name}_selected ? 1.0 : 0.2`,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: `${name}_icon`,\n\t\t\t\ttype: 'path',\n\t\t\t\tfrom: {\n\t\t\t\t\tdata: `${name}_aggregate`,\n\t\t\t\t},\n\t\t\t\tencode: {\n\t\t\t\t\tenter: {\n\t\t\t\t\t\t// adding a 2px transparent border increases the area of the icon so it's easier to hover\n\t\t\t\t\t\tstroke: { value: 'transparent' },\n\t\t\t\t\t\tstrokeWidth: { value: 2 },\n\t\t\t\t\t\tcursor: getCursor(chartPopovers),\n\t\t\t\t\t},\n\t\t\t\t\tupdate: {\n\t\t\t\t\t\tpath: {\n\t\t\t\t\t\t\tsignal: `datum.width > 0 ? '${ANNOTATION_RANGED_ICON_SVG}' : '${ANNOTATION_SINGLE_ICON_SVG}'`,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfill: {\n\t\t\t\t\t\t\tfield: 'color',\n\t\t\t\t\t\t},\n\t\t\t\t\t\txc: {\n\t\t\t\t\t\t\tscale: scaleName,\n\t\t\t\t\t\t\tfield: 'center',\n\t\t\t\t\t\t\tband: 0.5,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tyc: {\n\t\t\t\t\t\t\tsignal: `height + ${offset}`,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfillOpacity: {\n\t\t\t\t\t\t\tsignal: `(${name}_selected && ${name}_selected != datum.center) ? 0.0 : 1.0`,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t],\n\t};\n};\n\n/**\n * Adds the required axis for axis annotations.\n *\n * NOTE: this function should only be called from within a produce with axes as the root state since it directly\n * mutates the axes array\n * @param axes\n * @param param1\n */\nexport const addAxisAnnotationAxis = (axes: Axis[], { offset }: AxisAnnotationSpecOptions, scaleName) => {\n\taxes.push({\n\t\tscale: scaleName,\n\t\torient: 'bottom',\n\t\tvalues: [],\n\t\toffset: offset,\n\t});\n};\n\nexport const getAxisAnnotationsFromChildren = ({\n\taxisAnnotations,\n\tcolorScheme,\n\tname: axisName,\n\tposition,\n\tscaleType,\n}: AxisSpecOptions & { scaleType: ScaleType }): AxisAnnotationSpecOptions[] => {\n\tif (position !== 'bottom') return [];\n\treturn axisAnnotations.map((annotation, annotationIndex) => {\n\t\treturn applyDefaultAxisAnnotationOptions(annotation, annotationIndex, axisName, colorScheme, scaleType);\n\t});\n};\n\nexport const applyDefaultAxisAnnotationOptions = (\n\t{\n\t\tchartPopovers = [],\n\t\tchartTooltips = [],\n\t\tname,\n\t\tformat,\n\t\toffset = DEFAULT_AXIS_ANNOTATION_OFFSET,\n\t\tcolor = DEFAULT_AXIS_ANNOTATION_COLOR,\n\t\tdataKey = 'annotations',\n\t\toptions = [],\n\t}: AxisAnnotationOptions,\n\tannotationIndex: number,\n\taxisName: string,\n\tcolorScheme: ColorScheme,\n\tscaleType: ScaleType\n): AxisAnnotationSpecOptions => {\n\treturn {\n\t\tchartPopovers,\n\t\tchartTooltips,\n\t\tcolor,\n\t\tcolorScheme,\n\t\tdataKey,\n\t\tname: name ?? `${axisName}Annotation${annotationIndex}`,\n\t\toffset,\n\t\toptions,\n\t\taxisName,\n\t\tformat: format ?? (scaleType === 'time' ? 'span' : 'summary'),\n\t};\n};\n\nexport const axisTypeSupportsAxisAnnotations = (position: Position | undefined): boolean => {\n\tconst supportedAxisPositions: Position[] = ['bottom'];\n\treturn Boolean(position && supportedAxisPositions.includes(position));\n};\n","/*\n * Copyright 2024 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport { GroupMark, NumericValueRef, ProductionRule, RectEncodeEntry, RectMark, TextMark } from 'vega';\n\nimport {\n\tANNOTATION_FONT_SIZE,\n\tANNOTATION_FONT_WEIGHT,\n\tANNOTATION_PADDING,\n\tBACKGROUND_COLOR,\n} from '@spectrum-charts/constants';\n\nimport {\n\tBarAnnotationOptions,\n\tBarAnnotationSpecOptions,\n\tBarAnnotationStyleOptions,\n\tBarSpecOptions,\n\tOrientation,\n} from '../types';\nimport { getOrientationProperties, isDodgedAndStacked } from './barUtils';\n\ntype AnnotationWidth = { value: number } | { signal: string };\n\n/**\n * Gets the Annotation component from the children if one exists and applies default options, returning the BarAnnotationSpecOptions\n * @param barOptions\n * @returns BarAnnotationSpecOptions | undefined\n */\nconst getAnnotation = (\n\toptions: BarSpecOptions,\n\tdataName: string,\n\tdimensionScaleName: string,\n\tdimensionField: string\n): BarAnnotationSpecOptions | undefined => {\n\tconst annotation = options.barAnnotations[0];\n\n\tif (!annotation) {\n\t\treturn;\n\t}\n\treturn applyAnnotationPropDefaults(annotation, options, dataName, dimensionScaleName, dimensionField);\n};\n\n/**\n * Applies all default options, converting BarAnnotationOptions into BarAnnotationSpecOptions\n * @param annotationOptions\n * @param barOptions\n * @returns BarAnnotationSpecOptions\n */\nconst applyAnnotationPropDefaults = (\n\t{ textKey, ...options }: BarAnnotationOptions,\n\tbarOptions: BarSpecOptions,\n\tdataName: string,\n\tdimensionScaleName: string,\n\tdimensionField: string\n): BarAnnotationSpecOptions => ({\n\tbarOptions,\n\ttextKey: textKey || barOptions.metric,\n\tdataName,\n\tdimensionScaleName,\n\tdimensionField,\n\t...options,\n});\n\n/**\n * Gets the annotation marks for the bar chart. Returns an empty array if no annotation is provided on the bar children.\n * @param barOptions\n * @param dataName\n * @param dimensionScaleName\n * @param dimensionName\n * @returns GroupMark[]\n */\nexport const getAnnotationMarks = (\n\tbarOptions: BarSpecOptions,\n\n\t// These have to be local fields because it could be used in a group,\n\t// in which case we don't want to use the \"global\" (full table) values.\n\tdataName: string,\n\tdimensionScaleName: string,\n\tdimensionName: string\n): GroupMark[] => {\n\tconst annotationOptions = getAnnotation(barOptions, dataName, dimensionScaleName, dimensionName);\n\tif (!annotationOptions) {\n\t\treturn [];\n\t}\n\n\treturn [\n\t\t{\n\t\t\ttype: 'group',\n\t\t\tname: `${barOptions.name}_annotationGroup`,\n\t\t\tmarks: [getAnnotationTextMark(annotationOptions), getAnnotationBackgroundMark(annotationOptions)],\n\t\t},\n\t];\n};\n\n/**\n * Gets the annotation text mark for the bar chart\n * @param annotationOptions\n * @returns TextMark\n */\nconst getAnnotationTextMark = ({\n\tbarOptions,\n\tdataName,\n\tdimensionField,\n\tdimensionScaleName,\n\ttextKey,\n\tstyle,\n}: BarAnnotationSpecOptions): TextMark => {\n\tconst { metricAxis, dimensionAxis } = getOrientationProperties(barOptions.orientation);\n\tconst annotationWidth = getAnnotationWidth(textKey, style);\n\tconst annotationPosition = getAnnotationMetricAxisPosition(barOptions, annotationWidth);\n\n\treturn {\n\t\tname: `${barOptions.name}_annotationText`,\n\t\ttype: 'text',\n\t\tfrom: { data: dataName },\n\t\tinteractive: false,\n\t\tzindex: 1,\n\t\tencode: {\n\t\t\tenter: {\n\t\t\t\t[dimensionAxis]: {\n\t\t\t\t\tscale: dimensionScaleName,\n\t\t\t\t\tfield: dimensionField,\n\t\t\t\t\tband: 0.5,\n\t\t\t\t},\n\t\t\t\t[metricAxis]: annotationPosition,\n\t\t\t\ttext: [\n\t\t\t\t\t{\n\t\t\t\t\t\ttest: `bandwidth('${dimensionScaleName}') > ${getMinBandwidth(barOptions.orientation)}`,\n\t\t\t\t\t\tfield: textKey,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tfontSize: { value: ANNOTATION_FONT_SIZE },\n\t\t\t\tfontWeight: { value: ANNOTATION_FONT_WEIGHT },\n\t\t\t\tbaseline: { value: 'middle' },\n\t\t\t\talign: { value: 'center' },\n\t\t\t},\n\t\t},\n\t};\n};\n\n/**\n * Gets the annotation background mark\n * @param annotationOptions\n * @returns RectMark\n */\nconst getAnnotationBackgroundMark = ({\n\tbarOptions,\n\tdimensionScaleName,\n\ttextKey,\n\tstyle,\n}: BarAnnotationSpecOptions): RectMark => ({\n\tname: `${barOptions.name}_annotationBackground`,\n\tdescription: `${barOptions.name}_annotationBackground`,\n\ttype: 'rect',\n\tfrom: { data: `${barOptions.name}_annotationText` },\n\tinteractive: false,\n\tencode: {\n\t\tenter: {\n\t\t\t...getAnnotationXEncode(style?.width),\n\t\t\ty: { signal: `datum.bounds.y1  - ${ANNOTATION_PADDING}` },\n\t\t\ty2: { signal: `datum.bounds.y2  + ${ANNOTATION_PADDING}` },\n\t\t\tcornerRadius: { value: 4 },\n\t\t\tfill: [\n\t\t\t\t{\n\t\t\t\t\ttest: `datum.datum.${textKey} && bandwidth('${dimensionScaleName}') > ${getMinBandwidth(\n\t\t\t\t\t\tbarOptions.orientation\n\t\t\t\t\t)}`,\n\t\t\t\t\tsignal: BACKGROUND_COLOR,\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t},\n});\n\n/**\n * Gets the minimum band width needed to display the annotations based on the bar orientation\n * @param orientation\n * @returns number\n */\nexport const getMinBandwidth = (orientation: Orientation): number =>\n\torientation === 'vertical' ? 48 : ANNOTATION_FONT_SIZE + 2 * ANNOTATION_PADDING;\n\n/**\n * Gets the x position encoding for the annotation background\n * @param width\n * @returns RectEncodeEntry\n */\nexport const getAnnotationXEncode = (width?: number): RectEncodeEntry => {\n\tif (width) {\n\t\treturn {\n\t\t\txc: { signal: '(datum.bounds.x1 + datum.bounds.x2) / 2' },\n\t\t\twidth: { value: width },\n\t\t};\n\t}\n\treturn {\n\t\tx: { signal: `datum.bounds.x1 - ${ANNOTATION_PADDING}` },\n\t\tx2: { signal: `datum.bounds.x2 + ${ANNOTATION_PADDING}` },\n\t};\n};\n\nexport const getAnnotationWidth = (textKey: string, style?: BarAnnotationStyleOptions): AnnotationWidth => {\n\tif (style?.width) return { value: style.width };\n\treturn {\n\t\tsignal: `getLabelWidth(datum.${textKey}, '${ANNOTATION_FONT_WEIGHT}', ${ANNOTATION_FONT_SIZE}) + ${\n\t\t\t2 * ANNOTATION_PADDING\n\t\t}`,\n\t};\n};\n\n/**\n * Offset calculation to make sure the annotation does not overlap the baseline\n * @param barOptions\n * @param annotationWidth\n * @returns string\n */\nexport const getAnnotationPositionOffset = (\n\t{ orientation }: BarSpecOptions,\n\tannotationWidth: AnnotationWidth\n): string => {\n\tconst pixelGapFromBaseline = 2.5;\n\n\tif (orientation === 'vertical') {\n\t\treturn `${(2 * ANNOTATION_PADDING + ANNOTATION_FONT_SIZE) / 2 + pixelGapFromBaseline}`;\n\t}\n\n\tif ('value' in annotationWidth) {\n\t\treturn `${annotationWidth.value / 2 + pixelGapFromBaseline}`;\n\t}\n\n\t// Need parens for order of operations\n\t// Evaluate signal expression first, then divide by 2, then add extra offset\n\treturn `((${annotationWidth.signal}) / 2 + ${pixelGapFromBaseline})`;\n};\n\n/**\n * Gets the metric position for the annotation text.\n * This ensures that the annotation does not overlap the baseline.\n * @param barOptions\n * @param annotationWidth\n * @returns NumericValueref\n */\nexport const getAnnotationMetricAxisPosition = (\n\toptions: BarSpecOptions,\n\tannotationWidth: AnnotationWidth\n): ProductionRule<NumericValueRef> => {\n\tconst { type, metric, orientation } = options;\n\tconst field = type === 'stacked' || isDodgedAndStacked(options) ? `${metric}1` : metric;\n\tconst { metricScaleKey: scaleKey } = getOrientationProperties(orientation);\n\tconst positionOffset = getAnnotationPositionOffset(options, annotationWidth);\n\n\tif (orientation === 'vertical') {\n\t\treturn [\n\t\t\t{\n\t\t\t\ttest: `datum.${field} < 0`,\n\t\t\t\tsignal: `max(scale('${scaleKey}', datum.${field}), scale('${scaleKey}', 0) + ${positionOffset})`,\n\t\t\t},\n\t\t\t{\n\t\t\t\tsignal: `min(scale('${scaleKey}', datum.${field}), scale('${scaleKey}', 0) - ${positionOffset})`,\n\t\t\t},\n\t\t];\n\t}\n\n\treturn [\n\t\t{\n\t\t\ttest: `datum.${field} < 0`,\n\t\t\tsignal: `min(scale('${scaleKey}', datum.${field}), scale('${scaleKey}', 0) - ${positionOffset})`,\n\t\t},\n\t\t{\n\t\t\tsignal: `max(scale('${scaleKey}', datum.${field}), scale('${scaleKey}', 0) + ${positionOffset})`,\n\t\t},\n\t];\n};\n","/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport { produce } from 'immer';\nimport { BandScale, Data, FormulaTransform, Mark, OrdinalScale, Scale, Signal, Spec } from 'vega';\n\nimport {\n\tCOLOR_SCALE,\n\tDEFAULT_CATEGORICAL_DIMENSION,\n\tDEFAULT_COLOR_SCHEME,\n\tDEFAULT_METRIC,\n\tFILTERED_TABLE,\n\tLINE_TYPE_SCALE,\n\tOPACITY_SCALE,\n\tPADDING_RATIO,\n\tSTACK_ID,\n\tTIME,\n\tTRELLIS_PADDING,\n} from '@spectrum-charts/constants';\nimport { toCamelCase } from '@spectrum-charts/utils';\n\nimport { addPopoverData, getPopovers } from '../chartPopover/chartPopoverUtils';\nimport { addTooltipData, addTooltipSignals } from '../chartTooltip/chartTooltipUtils';\nimport { addTimeTransform, getTableData, getTransformSort } from '../data/dataUtils';\nimport { getInteractiveMarkName } from '../marks/markUtils';\nimport {\n\taddDomainFields,\n\taddFieldToFacetScaleDomain,\n\taddMetricScale,\n\tgetDefaultScale,\n\tgetMetricScale,\n\tgetScaleIndexByName,\n\tgetScaleIndexByType,\n} from '../scale/scaleSpecBuilder';\nimport { addHighlightedItemSignalEvents, getGenericValueSignal } from '../signal/signalSpecBuilder';\nimport { getFacetsFromOptions } from '../specUtils';\nimport { addTrendlineData, getTrendlineMarks, setTrendlineSignals } from '../trendline';\nimport { BarOptions, BarSpecOptions, ColorScheme, HighlightedItem } from '../types';\nimport { getBarPadding, getDimensionSelectionRing, getScaleValues, isDodgedAndStacked } from './barUtils';\nimport { getDodgedMark } from './dodgedBarUtils';\nimport { getDodgedAndStackedBarMark, getStackedBarMarks } from './stackedBarUtils';\nimport { addTrellisScale, getTrellisGroupMark, isTrellised } from './trellisedBarUtils';\n\nexport const addBar = produce<\n\tSpec,\n\t[BarOptions & { colorScheme?: ColorScheme; highlightedItem?: HighlightedItem; index?: number; idKey: string }]\n>(\n\t(\n\t\tspec,\n\t\t{\n\t\t\tbarAnnotations = [],\n\t\t\tchartPopovers = [],\n\t\t\tchartTooltips = [],\n\t\t\tcolor = { value: 'categorical-100' },\n\t\t\tcolorScheme = DEFAULT_COLOR_SCHEME,\n\t\t\tdimension = DEFAULT_CATEGORICAL_DIMENSION,\n\t\t\thasOnClick = false,\n\t\t\thasSquareCorners = false,\n\t\t\tindex = 0,\n\t\t\tlineType = { value: 'solid' },\n\t\t\tlineWidth = 0,\n\t\t\tmetric = DEFAULT_METRIC,\n\t\t\tmetricAxis,\n\t\t\tname,\n\t\t\topacity = { value: 1 },\n\t\t\torientation = 'vertical',\n\t\t\tpaddingRatio = PADDING_RATIO,\n\t\t\ttrellisOrientation = 'horizontal',\n\t\t\ttrellisPadding = TRELLIS_PADDING,\n\t\t\ttype = 'stacked',\n\t\t\ttrendlines = [],\n\t\t\t...options\n\t\t}\n\t) => {\n\t\tconst barName = toCamelCase(name || `bar${index}`);\n\t\t// put options back together now that all defaults are set\n\t\tconst barOptions: BarSpecOptions = {\n\t\t\tbarAnnotations,\n\t\t\tchartPopovers,\n\t\t\tchartTooltips,\n\t\t\tdimensionScaleType: 'band',\n\t\t\torientation,\n\t\t\tcolor,\n\t\t\tcolorScheme,\n\t\t\tdimension,\n\t\t\thasOnClick,\n\t\t\thasSquareCorners,\n\t\t\tindex,\n\t\t\tinteractiveMarkName: getInteractiveMarkName(\n\t\t\t\t{ chartPopovers, chartTooltips, hasOnClick, highlightedItem: options.highlightedItem, trendlines },\n\t\t\t\tbarName\n\t\t\t),\n\t\t\tlineType,\n\t\t\tlineWidth,\n\t\t\tmetric,\n\t\t\tmetricAxis,\n\t\t\tname: barName,\n\t\t\topacity,\n\t\t\tpaddingRatio,\n\t\t\ttrellisOrientation,\n\t\t\ttrellisPadding,\n\t\t\ttrendlines,\n\t\t\ttype,\n\t\t\t...options,\n\t\t};\n\n\t\tspec.data = addData(spec.data ?? [], barOptions);\n\t\tspec.signals = addSignals(spec.signals ?? [], barOptions);\n\t\tspec.scales = addScales(spec.scales ?? [], barOptions);\n\t\tspec.marks = addMarks(spec.marks ?? [], barOptions);\n\t}\n);\n\nexport const addSignals = produce<Signal[], [BarSpecOptions]>((signals, options) => {\n\tconst {\n\t\tbarAnnotations,\n\t\tchartTooltips,\n\t\tchartPopovers,\n\t\tidKey,\n\t\tname,\n\t\tpaddingRatio,\n\t\tpaddingOuter: barPaddingOuter,\n\t\ttrendlines,\n\t} = options;\n\t// We use this value to calculate ReferenceLine positions.\n\tconst { paddingInner } = getBarPadding(paddingRatio, barPaddingOuter);\n\tsignals.push(getGenericValueSignal('paddingInner', paddingInner));\n\n\tif (!barAnnotations.length && !chartPopovers.length && !chartTooltips.length && !trendlines.length) {\n\t\treturn;\n\t}\n\taddHighlightedItemSignalEvents(signals, name, idKey, 1, chartTooltips[0]?.excludeDataKeys);\n\taddTooltipSignals(signals, options);\n\tsetTrendlineSignals(signals, options);\n});\n\nexport const addData = produce<Data[], [BarSpecOptions]>((data, options) => {\n\tconst { dimension, dimensionDataType, metric, order, type } = options;\n\tif (dimensionDataType === TIME) {\n\t\tconst tableData = getTableData(data);\n\t\ttableData.transform = addTimeTransform(tableData.transform ?? [], dimension);\n\t}\n\n\tconst index = data.findIndex((d) => d.name === FILTERED_TABLE);\n\tdata[index].transform = data[index].transform ?? [];\n\tif (type === 'stacked' || isDodgedAndStacked(options)) {\n\t\tdata[index].transform?.push({\n\t\t\ttype: 'stack',\n\t\t\tgroupby: getStackFields(options),\n\t\t\tfield: metric,\n\t\t\tsort: getTransformSort(order),\n\t\t\tas: [`${metric}0`, `${metric}1`],\n\t\t});\n\n\t\tdata[index].transform?.push(getStackIdTransform(options));\n\t\tdata.push(getStackAggregateData(options));\n\t}\n\tif (type === 'dodged' || isDodgedAndStacked(options)) {\n\t\tdata[index].transform?.push(getDodgeGroupTransform(options));\n\t}\n\taddTrendlineData(data, options);\n\taddTooltipData(data, options);\n\taddPopoverData(data, options);\n});\n\n/**\n * data aggregate used to calculate the min and max of the stack\n * used to figure out the corner radius of the bars\n * @param facets\n * @param barSpecOptions\n * @returns vega Data object\n */\nexport const getStackAggregateData = (options: BarSpecOptions): Data => {\n\tconst { metric, name } = options;\n\treturn {\n\t\tname: `${name}_stacks`,\n\t\tsource: FILTERED_TABLE,\n\t\ttransform: [\n\t\t\t{\n\t\t\t\ttype: 'aggregate',\n\t\t\t\tgroupby: getStackFields(options),\n\t\t\t\tfields: [`${metric}1`, `${metric}1`],\n\t\t\t\tops: ['min', 'max'],\n\t\t\t},\n\t\t\tgetStackIdTransform(options),\n\t\t],\n\t};\n};\n\nexport const getStackIdTransform = (options: BarSpecOptions): FormulaTransform => {\n\treturn {\n\t\ttype: 'formula',\n\t\tas: STACK_ID,\n\t\texpr: getStackFields(options)\n\t\t\t.map((facet) => `datum.${facet}`)\n\t\t\t.join(' + \",\" + '),\n\t} as FormulaTransform;\n};\n\nconst getStackFields = ({ trellis, color, dimension, lineType, opacity, type }: BarSpecOptions): string[] => {\n\tconst { facets, secondaryFacets } = getFacetsFromOptions({ color, lineType, opacity });\n\treturn [\n\t\t...(trellis ? [trellis] : []),\n\t\tdimension,\n\t\t...(type === 'dodged' ? facets : []),\n\t\t...(type === 'stacked' ? secondaryFacets : []),\n\t];\n};\n\nexport const getDodgeGroupTransform = ({ color, lineType, name, opacity, type }: BarSpecOptions): FormulaTransform => {\n\tconst { facets, secondaryFacets } = getFacetsFromOptions({ color, lineType, opacity });\n\treturn {\n\t\ttype: 'formula',\n\t\tas: `${name}_dodgeGroup`,\n\t\texpr: (type === 'dodged' ? facets : secondaryFacets).map((facet) => `datum.${facet}`).join(' + \",\" + '),\n\t};\n};\n\nexport const addScales = produce<Scale[], [BarSpecOptions]>((scales, options) => {\n\tconst { color, lineType, opacity, orientation, metricAxis } = options;\n\tconst axisType = orientation === 'vertical' ? 'y' : 'x';\n\taddMetricScale(scales, getScaleValues(options), axisType);\n\tif (metricAxis) {\n\t\taddMetricScale(scales, getScaleValues(options), axisType, metricAxis);\n\t}\n\taddDimensionScale(scales, options);\n\taddTrellisScale(scales, options);\n\taddFieldToFacetScaleDomain(scales, COLOR_SCALE, color);\n\taddFieldToFacetScaleDomain(scales, LINE_TYPE_SCALE, lineType);\n\taddFieldToFacetScaleDomain(scales, OPACITY_SCALE, opacity);\n\taddSecondaryScales(scales, options);\n});\n\nexport const addDimensionScale = (\n\tscales: Scale[],\n\t{ dimension, paddingRatio, paddingOuter: barPaddingOuter, orientation }: BarSpecOptions\n) => {\n\tconst index = getScaleIndexByType(scales, 'band', orientation === 'vertical' ? 'x' : 'y');\n\tscales[index] = addDomainFields(scales[index], [dimension]);\n\tconst { paddingInner, paddingOuter } = getBarPadding(paddingRatio, barPaddingOuter);\n\n\tscales[index] = { ...scales[index], paddingInner, paddingOuter } as BandScale;\n};\n\n/**\n * adds scales for the secondary dimensions\n * If a bar is stacked and dodged,\n * @param scales\n * @param param1\n */\nexport const addSecondaryScales = (scales: Scale[], options: BarSpecOptions) => {\n\tconst { color, lineType, opacity } = options;\n\tif (isDodgedAndStacked(options)) {\n\t\t[\n\t\t\t{\n\t\t\t\tvalue: color,\n\t\t\t\tscaleName: 'colors',\n\t\t\t\tsecondaryScaleName: 'secondaryColor',\n\t\t\t},\n\t\t\t{\n\t\t\t\tvalue: lineType,\n\t\t\t\tscaleName: 'lineTypes',\n\t\t\t\tsecondaryScaleName: 'secondaryLineType',\n\t\t\t},\n\t\t\t{\n\t\t\t\tvalue: opacity,\n\t\t\t\tscaleName: 'opacities',\n\t\t\t\tsecondaryScaleName: 'secondaryOpacity',\n\t\t\t},\n\t\t].forEach(({ value, scaleName, secondaryScaleName }) => {\n\t\t\tif (Array.isArray(value) && value.length === 2) {\n\t\t\t\t// secondary value scale used for 2D scales\n\t\t\t\tconst secondaryIndex = getScaleIndexByName(scales, secondaryScaleName, 'ordinal');\n\t\t\t\tscales[secondaryIndex] = addDomainFields(scales[secondaryIndex], [value[1]]);\n\n\t\t\t\tconst primaryIndex = getScaleIndexByName(scales, scaleName, 'ordinal');\n\t\t\t\tconst primaryScale = scales[primaryIndex] as OrdinalScale;\n\t\t\t\tprimaryScale.range = { signal: scaleName };\n\t\t\t\tscales[primaryIndex] = addDomainFields(primaryScale, [value[0]]);\n\t\t\t}\n\t\t});\n\t}\n};\n\nexport const addMarks = produce<Mark[], [BarSpecOptions]>((marks, options) => {\n\tconst { chartPopovers, name, type } = options;\n\tconst barMarks: Mark[] = [];\n\tif (isDodgedAndStacked(options)) {\n\t\tbarMarks.push(getDodgedAndStackedBarMark(options));\n\t} else if (type === 'stacked') {\n\t\tbarMarks.push(...getStackedBarMarks(options));\n\t} else {\n\t\tbarMarks.push(getDodgedMark(options));\n\t}\n\n\tconst popovers = getPopovers(chartPopovers, name);\n\tif (popovers.some((popover) => popover.UNSAFE_highlightBy === 'dimension')) {\n\t\tbarMarks.push(getDimensionSelectionRing(options));\n\t}\n\n\t// if this is a trellis plot, we add the bars and the repeated scale to the trellis group\n\tif (isTrellised(options)) {\n\t\tconst repeatedScale = getRepeatedScale(options);\n\t\tmarks.push(getTrellisGroupMark(options, barMarks, repeatedScale));\n\t} else {\n\t\tmarks.push(...barMarks);\n\t}\n\n\tmarks.push(...getTrendlineMarks(options));\n});\n\nexport const getRepeatedScale = (options: BarSpecOptions): Scale => {\n\tconst { orientation, trellisOrientation } = options;\n\t// if the orientations match then the metric scale is repeated, otherwise the dimension scale is repeated\n\t// ex. vertical bar in a vertical trellis will have multiple copies of the metric scale\n\tif (orientation === trellisOrientation) {\n\t\treturn getMetricScale(getScaleValues(options), orientation === 'vertical' ? 'y' : 'x', orientation);\n\t} else {\n\t\treturn getDimensionScale(options);\n\t}\n};\n\n/**\n * Generates a dimension scale and returns it\n * NOTE: does not check if the dimension scale already exists\n * @param param0\n * @returns\n */\nconst getDimensionScale = ({\n\tdimension,\n\torientation,\n\tpaddingRatio,\n\tpaddingOuter: barPaddingOuter,\n}: BarSpecOptions): BandScale => {\n\tlet scale = getDefaultScale('band', orientation === 'vertical' ? 'x' : 'y', orientation);\n\tscale = addDomainFields(scale, [dimension]);\n\tconst { paddingInner, paddingOuter } = getBarPadding(paddingRatio, barPaddingOuter);\n\treturn { ...scale, paddingInner, paddingOuter } as BandScale;\n};\n","/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport {\n\tArrayValueRef,\n\tColorValueRef,\n\tEncodeEntry,\n\tGroupMark,\n\tNumericValueRef,\n\tProductionRule,\n\tRectEncodeEntry,\n\tRectMark,\n} from 'vega';\n\nimport { CORNER_RADIUS, FILTERED_TABLE, SELECTED_GROUP, SELECTED_ITEM, STACK_ID } from '@spectrum-charts/constants';\nimport { getColorValue } from '@spectrum-charts/themes';\n\nimport { getPopovers } from '../chartPopover/chartPopoverUtils';\nimport {\n\tgetColorProductionRule,\n\tgetCursor,\n\tgetMarkOpacity,\n\tgetOpacityProductionRule,\n\tgetStrokeDashProductionRule,\n\tgetTooltip,\n\thasPopover,\n} from '../marks/markUtils';\nimport { getBandPadding } from '../scale/scaleSpecBuilder';\nimport { getLineWidthPixelsFromLineWidth } from '../specUtils';\nimport { BarSpecOptions, Orientation } from '../types';\nimport { getTrellisProperties, isTrellised } from './trellisedBarUtils';\n\n/**\n * checks to see if the bar is faceted in the stacked and dodged dimensions\n * @param color\n */\nexport const isDodgedAndStacked = ({ color, lineType, opacity }: BarSpecOptions): boolean => {\n\treturn [color, lineType, opacity].some((facet) => Array.isArray(facet) && facet.length === 2);\n};\n\nexport const getDodgedGroupMark = (options: BarSpecOptions): GroupMark => {\n\tconst { dimension, groupedPadding, orientation, name, paddingRatio } = options;\n\n\tconst { dimensionScaleKey, dimensionAxis, rangeScale } = getOrientationProperties(orientation);\n\n\treturn {\n\t\tname: `${name}_group`,\n\t\ttype: 'group',\n\t\tfrom: {\n\t\t\tfacet: {\n\t\t\t\tdata: isTrellised(options) ? getTrellisProperties(options).facetName : FILTERED_TABLE,\n\t\t\t\tname: `${name}_facet`,\n\t\t\t\tgroupby: dimension,\n\t\t\t},\n\t\t},\n\t\tencode: {\n\t\t\tenter: {\n\t\t\t\t[dimensionAxis]: {\n\t\t\t\t\tscale: dimensionScaleKey,\n\t\t\t\t\tfield: dimension,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tsignals: [{ name: rangeScale, update: `bandwidth(\"${dimensionScaleKey}\")` }],\n\t\tscales: [\n\t\t\t{\n\t\t\t\tname: `${name}_position`,\n\t\t\t\ttype: 'band',\n\t\t\t\trange: rangeScale,\n\t\t\t\t// want to reference the FILTERED_TABLE and not the facet table because we want the bar widths and positioning to be consistent across facets\n\t\t\t\t// if we don't do this, the bar widths could be different for the different groups if one of the groups is missing a value\n\t\t\t\tdomain: { data: FILTERED_TABLE, field: `${name}_dodgeGroup` },\n\t\t\t\tpaddingInner: groupedPadding ?? paddingRatio,\n\t\t\t},\n\t\t],\n\t};\n};\n\nexport const getDodgedDimensionEncodings = (options: BarSpecOptions): RectEncodeEntry => {\n\tconst { dimensionAxis, rangeScale } = getOrientationProperties(options.orientation);\n\n\tconst scale = `${options.name}_position`;\n\tconst field = `${options.name}_dodgeGroup`;\n\n\treturn {\n\t\t[dimensionAxis]: { scale, field },\n\t\t[rangeScale]: { scale, band: 1 },\n\t};\n};\n\nexport const getTrellisedDimensionEncodings = (options: BarSpecOptions): RectEncodeEntry => {\n\tconst { dimensionAxis, rangeScale, dimensionScaleKey } = getOrientationProperties(options.orientation);\n\n\treturn {\n\t\t[dimensionAxis]: { scale: dimensionScaleKey, field: options.dimension },\n\t\t[rangeScale]: { scale: dimensionScaleKey, band: 1 },\n\t};\n};\n\nexport const getMetricEncodings = (options: BarSpecOptions): RectEncodeEntry => {\n\tconst { metric, type } = options;\n\tconst { metricAxis: startKey, metricScaleKey: scaleKey } = getOrientationProperties(\n\t\toptions.orientation,\n\t\toptions.metricAxis\n\t);\n\tconst endKey = `${startKey}2`;\n\n\tif (type === 'stacked' || isDodgedAndStacked(options)) {\n\t\treturn getStackedMetricEncodings(options);\n\t}\n\treturn {\n\t\t[startKey]: { scale: scaleKey, value: 0 },\n\t\t[endKey]: { scale: scaleKey, field: metric },\n\t};\n};\n\nexport const getStackedMetricEncodings = (options: BarSpecOptions): RectEncodeEntry => {\n\tconst { metric, orientation } = options;\n\tconst { metricAxis: startKey, metricScaleKey: scaleKey } = getOrientationProperties(\n\t\toptions.orientation,\n\t\toptions.metricAxis\n\t);\n\tconst endKey = `${startKey}2`;\n\n\tconst startValue = `datum.${metric}0`;\n\tconst endValue = `datum.${metric}1`;\n\n\tconst pixelGapBetweenBars = 1.5;\n\n\tif (orientation === 'vertical') {\n\t\treturn {\n\t\t\t[startKey]: [\n\t\t\t\t// if the bar starts at 0, no need to calculate any shifts\n\t\t\t\t{ test: `${startValue} === 0`, signal: `scale('${scaleKey}', ${startValue})` },\n\t\t\t\t// if the bar is positive, shift the start up by 1.5px gap\n\t\t\t\t{\n\t\t\t\t\ttest: `${endValue} > 0`,\n\t\t\t\t\tsignal: `max(scale('${scaleKey}', ${startValue}) - ${pixelGapBetweenBars}, scale('${scaleKey}', ${endValue}))`,\n\t\t\t\t},\n\t\t\t\t// if the bar is negative, shift the start down by 1.5px gap\n\t\t\t\t{\n\t\t\t\t\tsignal: `min(scale('${scaleKey}', ${startValue}) + ${pixelGapBetweenBars}, scale('${scaleKey}', ${endValue}))`,\n\t\t\t\t},\n\t\t\t],\n\t\t\t[endKey]: { scale: scaleKey, field: `${metric}1` },\n\t\t};\n\t}\n\n\treturn {\n\t\t[startKey]: [\n\t\t\t// if the bar starts at 0, no need to calculate any shifts\n\t\t\t{ test: `${startValue} === 0`, signal: `scale('${scaleKey}', ${startValue})` },\n\t\t\t// if the bar is positive, shift the start right by 1.5px gap\n\t\t\t{\n\t\t\t\ttest: `${endValue} > 0`,\n\t\t\t\tsignal: `min(scale('${scaleKey}', ${startValue}) + ${pixelGapBetweenBars}, scale('${scaleKey}', ${endValue}))`,\n\t\t\t},\n\t\t\t// if the bar is negative, shift the start left by 1.5px gap\n\t\t\t{\n\t\t\t\tsignal: `max(scale('${scaleKey}', ${startValue}) - ${pixelGapBetweenBars}, scale('${scaleKey}', ${endValue}))`,\n\t\t\t},\n\t\t],\n\t\t[endKey]: { scale: scaleKey, field: `${metric}1` },\n\t};\n};\n\nexport const getCornerRadiusEncodings = (options: BarSpecOptions): RectEncodeEntry => {\n\tconst { type, lineWidth, metric, hasSquareCorners } = options;\n\tconst value = hasSquareCorners ? 0 : Math.max(1, CORNER_RADIUS - getLineWidthPixelsFromLineWidth(lineWidth) / 2);\n\n\tlet rectEncodeEntry: RectEncodeEntry;\n\n\tif (type === 'dodged' && !isDodgedAndStacked(options)) {\n\t\trectEncodeEntry = {\n\t\t\tcornerRadiusTopLeft: [{ test: `datum.${metric} > 0`, value }, { value: 0 }],\n\t\t\tcornerRadiusTopRight: [{ test: `datum.${metric} > 0`, value }, { value: 0 }],\n\t\t\tcornerRadiusBottomLeft: [{ test: `datum.${metric} < 0`, value }, { value: 0 }],\n\t\t\tcornerRadiusBottomRight: [{ test: `datum.${metric} < 0`, value }, { value: 0 }],\n\t\t};\n\t} else {\n\t\trectEncodeEntry = getStackedCornerRadiusEncodings(options);\n\t}\n\n\treturn rotateRectClockwiseIfNeeded(rectEncodeEntry, options);\n};\n\nexport const getStackedCornerRadiusEncodings = ({\n\tname,\n\tmetric,\n\tlineWidth,\n\thasSquareCorners,\n}: BarSpecOptions): RectEncodeEntry => {\n\tconst topTestString = `datum.${metric}1 > 0 && data('${name}_stacks')[indexof(pluck(data('${name}_stacks'), '${STACK_ID}'), datum.${STACK_ID})].max_${metric}1 === datum.${metric}1`;\n\tconst bottomTestString = `datum.${metric}1 < 0 && data('${name}_stacks')[indexof(pluck(data('${name}_stacks'), '${STACK_ID}'), datum.${STACK_ID})].min_${metric}1 === datum.${metric}1`;\n\tconst value = hasSquareCorners ? 0 : Math.max(1, CORNER_RADIUS - getLineWidthPixelsFromLineWidth(lineWidth) / 2);\n\n\treturn {\n\t\tcornerRadiusTopLeft: [{ test: topTestString, value }, { value: 0 }],\n\t\tcornerRadiusTopRight: [{ test: topTestString, value }, { value: 0 }],\n\t\tcornerRadiusBottomLeft: [{ test: bottomTestString, value }, { value: 0 }],\n\t\tcornerRadiusBottomRight: [{ test: bottomTestString, value }, { value: 0 }],\n\t};\n};\n\nexport const rotateRectClockwiseIfNeeded = (\n\trectEncodeEntry: RectEncodeEntry,\n\t{ orientation }: BarSpecOptions\n): RectEncodeEntry => {\n\tif (orientation === 'vertical') return rectEncodeEntry;\n\treturn {\n\t\tcornerRadiusTopLeft: rectEncodeEntry.cornerRadiusBottomLeft,\n\t\tcornerRadiusTopRight: rectEncodeEntry.cornerRadiusTopLeft,\n\t\tcornerRadiusBottomLeft: rectEncodeEntry.cornerRadiusBottomRight,\n\t\tcornerRadiusBottomRight: rectEncodeEntry.cornerRadiusTopRight,\n\t};\n};\n\nexport const getBaseBarEnterEncodings = (options: BarSpecOptions): EncodeEntry => ({\n\t...getMetricEncodings(options),\n\t...getCornerRadiusEncodings(options),\n});\n\nexport const getBarEnterEncodings = ({\n\tchartTooltips,\n\tcolor,\n\tcolorScheme,\n\tname,\n\topacity,\n}: BarSpecOptions): EncodeEntry => ({\n\tfill: getColorProductionRule(color, colorScheme),\n\tfillOpacity: getOpacityProductionRule(opacity),\n\ttooltip: getTooltip(chartTooltips, name),\n});\n\nexport const getBarUpdateEncodings = (options: BarSpecOptions): EncodeEntry => ({\n\tcursor: getCursor(options.chartPopovers, options.hasOnClick),\n\topacity: getMarkOpacity(options),\n\tstroke: getStroke(options),\n\tstrokeDash: getStrokeDash(options),\n\tstrokeWidth: getStrokeWidth(options),\n});\n\nexport const getStroke = ({\n\tname,\n\tchartPopovers,\n\tcolor,\n\tcolorScheme,\n\tidKey,\n}: BarSpecOptions): ProductionRule<ColorValueRef> => {\n\tconst defaultProductionRule = getColorProductionRule(color, colorScheme);\n\tif (!hasPopover({ chartPopovers })) {\n\t\treturn [defaultProductionRule];\n\t}\n\n\treturn [\n\t\t{\n\t\t\ttest: `(${SELECTED_ITEM} && ${SELECTED_ITEM} === datum.${idKey}) || (${SELECTED_GROUP} && ${SELECTED_GROUP} === datum.${name}_selectedGroupId)`,\n\t\t\tvalue: getColorValue('static-blue', colorScheme),\n\t\t},\n\t\tdefaultProductionRule,\n\t];\n};\n\nexport const getDimensionSelectionRing = (options: BarSpecOptions): RectMark => {\n\tconst { name, colorScheme, paddingRatio, orientation } = options;\n\n\tconst update =\n\t\torientation === 'vertical'\n\t\t\t? {\n\t\t\t\t\ty: { value: 0 },\n\t\t\t\t\ty2: { signal: 'height' },\n\t\t\t\t\txc: { signal: `scale('xBand', datum.${name}_selectedGroupId) + bandwidth('xBand')/2` },\n\t\t\t\t\twidth: { signal: `bandwidth('xBand')/(1 - ${paddingRatio} / 2)` },\n\t\t\t  }\n\t\t\t: {\n\t\t\t\t\tx: { value: 0 },\n\t\t\t\t\tx2: { signal: 'width' },\n\t\t\t\t\tyc: { signal: `scale('yBand', datum.${name}_selectedGroupId) + bandwidth('yBand')/2` },\n\t\t\t\t\theight: { signal: `bandwidth('yBand')/(1 - ${paddingRatio} / 2)` },\n\t\t\t  };\n\n\treturn {\n\t\tname: `${name}_selectionRing`,\n\t\ttype: 'rect',\n\t\tfrom: {\n\t\t\tdata: `${name}_selectedData`,\n\t\t},\n\t\tinteractive: false,\n\t\tencode: {\n\t\t\tenter: {\n\t\t\t\tfill: { value: 'transparent' },\n\t\t\t\tstrokeWidth: { value: 2 },\n\t\t\t\tstroke: { value: getColorValue('static-blue', colorScheme) },\n\t\t\t\tcornerRadius: { value: 6 },\n\t\t\t},\n\t\t\tupdate,\n\t\t},\n\t};\n};\n\nexport const getStrokeDash = ({ chartPopovers, idKey, lineType }: BarSpecOptions): ProductionRule<ArrayValueRef> => {\n\tconst defaultProductionRule = getStrokeDashProductionRule(lineType);\n\tif (!hasPopover({ chartPopovers })) {\n\t\treturn [defaultProductionRule];\n\t}\n\n\treturn [\n\t\t{ test: `isValid(${SELECTED_ITEM}) && ${SELECTED_ITEM} === datum.${idKey}`, value: [] },\n\t\tdefaultProductionRule,\n\t];\n};\n\nexport const getStrokeWidth = ({\n\tchartPopovers,\n\tidKey,\n\tlineWidth,\n\tname,\n}: BarSpecOptions): ProductionRule<NumericValueRef> => {\n\tconst lineWidthValue = getLineWidthPixelsFromLineWidth(lineWidth);\n\tconst defaultProductionRule = { value: lineWidthValue };\n\tconst popovers = getPopovers(chartPopovers, name);\n\tconst popoverWithDimensionHighlightExists = popovers.some(\n\t\t({ UNSAFE_highlightBy }) => UNSAFE_highlightBy === 'dimension'\n\t);\n\n\tif (popovers.length === 0 || popoverWithDimensionHighlightExists) {\n\t\treturn [defaultProductionRule];\n\t}\n\n\treturn [\n\t\t{\n\t\t\ttest: `(isValid(${SELECTED_ITEM}) && ${SELECTED_ITEM} === datum.${idKey}) || (isValid(${SELECTED_GROUP}) && ${SELECTED_GROUP} === datum.${name}_selectedGroupId)`,\n\t\t\tvalue: Math.max(lineWidthValue, 2),\n\t\t},\n\t\tdefaultProductionRule,\n\t];\n};\n\nexport const getBarPadding = (paddingRatio: number, paddingOuter?: number) => {\n\treturn getBandPadding(paddingRatio, paddingOuter);\n};\n\nexport const getScaleValues = (options: BarSpecOptions) => {\n\treturn options.type === 'stacked' || isDodgedAndStacked(options) ? [`${options.metric}1`] : [options.metric];\n};\n\nexport interface BarOrientationProperties {\n\tmetricAxis: 'x' | 'y';\n\tdimensionAxis: 'x' | 'y';\n\tmetricScaleKey: string;\n\tdimensionScaleKey: 'xBand' | 'yBand';\n\trangeScale: 'width' | 'height';\n}\n\nexport const getOrientationProperties = (orientation: Orientation, scaleName?: string): BarOrientationProperties =>\n\torientation === 'vertical'\n\t\t? {\n\t\t\t\tmetricAxis: 'y',\n\t\t\t\tdimensionAxis: 'x',\n\t\t\t\tmetricScaleKey: scaleName || 'yLinear',\n\t\t\t\tdimensionScaleKey: 'xBand',\n\t\t\t\trangeScale: 'width',\n\t\t  }\n\t\t: {\n\t\t\t\tmetricAxis: 'x',\n\t\t\t\tdimensionAxis: 'y',\n\t\t\t\tmetricScaleKey: scaleName || 'xLinear',\n\t\t\t\tdimensionScaleKey: 'yBand',\n\t\t\t\trangeScale: 'height',\n\t\t  };\n","/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport { GroupMark } from 'vega';\n\nimport { BACKGROUND_COLOR } from '@spectrum-charts/constants';\n\nimport { isInteractive } from '../marks/markUtils';\nimport { BarSpecOptions } from '../types';\nimport { getAnnotationMarks } from './barAnnotationUtils';\nimport {\n\tgetBarEnterEncodings,\n\tgetBarUpdateEncodings,\n\tgetBaseBarEnterEncodings,\n\tgetDodgedDimensionEncodings,\n\tgetDodgedGroupMark,\n} from './barUtils';\n\nexport const getDodgedMark = (options: BarSpecOptions): GroupMark => {\n\tconst { name } = options;\n\n\treturn {\n\t\t...getDodgedGroupMark(options),\n\t\tmarks: [\n\t\t\t// background bars\n\t\t\t{\n\t\t\t\tname: `${name}_background`,\n\t\t\t\tfrom: { data: `${name}_facet` },\n\t\t\t\ttype: 'rect',\n\t\t\t\tinteractive: false,\n\t\t\t\tencode: {\n\t\t\t\t\tenter: {\n\t\t\t\t\t\t...getBaseBarEnterEncodings(options),\n\t\t\t\t\t\tfill: { signal: BACKGROUND_COLOR },\n\t\t\t\t\t},\n\t\t\t\t\tupdate: {\n\t\t\t\t\t\t...getDodgedDimensionEncodings(options),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\t// bars\n\t\t\t{\n\t\t\t\tname,\n\t\t\t\tfrom: { data: `${name}_facet` },\n\t\t\t\ttype: 'rect',\n\t\t\t\tinteractive: isInteractive(options),\n\t\t\t\tencode: {\n\t\t\t\t\tenter: {\n\t\t\t\t\t\t...getBaseBarEnterEncodings(options),\n\t\t\t\t\t\t...getBarEnterEncodings(options),\n\t\t\t\t\t},\n\t\t\t\t\tupdate: {\n\t\t\t\t\t\t...getDodgedDimensionEncodings(options),\n\t\t\t\t\t\t...getBarUpdateEncodings(options),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\t...getAnnotationMarks(options, `${name}_facet`, `${name}_position`, `${name}_dodgeGroup`),\n\t\t],\n\t};\n};\n","/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport { GroupMark, Mark, RectEncodeEntry, RectMark } from 'vega';\n\nimport { BACKGROUND_COLOR, FILTERED_TABLE } from '@spectrum-charts/constants';\n\nimport { isInteractive } from '../marks/markUtils';\nimport { BarSpecOptions } from '../types';\nimport { getAnnotationMarks } from './barAnnotationUtils';\nimport {\n\tgetBarEnterEncodings,\n\tgetBarUpdateEncodings,\n\tgetBaseBarEnterEncodings,\n\tgetDodgedDimensionEncodings,\n\tgetDodgedGroupMark,\n\tgetOrientationProperties,\n\tisDodgedAndStacked,\n} from './barUtils';\nimport { getTrellisProperties, isTrellised } from './trellisedBarUtils';\n\nexport const getStackedBarMarks = (options: BarSpecOptions): Mark[] => {\n\tconst marks: Mark[] = [];\n\t// add background marks\n\t// these marks make it so that when the opacity of a bar is lowered (like on hover), you can't see the grid lines behind the bars\n\tmarks.push(getStackedBackgroundBar(options));\n\n\t// bar mark\n\tmarks.push(getStackedBar(options));\n\n\t// add annotation marks\n\tmarks.push(\n\t\t...getAnnotationMarks(\n\t\t\toptions,\n\t\t\tgetBaseDataSourceName(options),\n\t\t\tgetOrientationProperties(options.orientation).dimensionScaleKey,\n\t\t\toptions.dimension\n\t\t)\n\t);\n\n\treturn marks;\n};\n\nexport const getDodgedAndStackedBarMark = (options: BarSpecOptions): GroupMark => {\n\tconst marks: Mark[] = [];\n\t// add background marks\n\tmarks.push(getStackedBackgroundBar(options));\n\n\t// bar mark\n\tmarks.push(getStackedBar(options));\n\n\t// add annotation marks\n\tmarks.push(\n\t\t...getAnnotationMarks(\n\t\t\toptions,\n\t\t\t`${options.name}_facet`,\n\t\t\t`${options.name}_position`,\n\t\t\t`${options.name}_dodgeGroup`\n\t\t)\n\t);\n\n\treturn { ...getDodgedGroupMark(options), marks };\n};\n\nexport const getStackedBackgroundBar = (options: BarSpecOptions): RectMark => {\n\tconst { name } = options;\n\n\treturn {\n\t\tname: `${name}_background`,\n\t\tdescription: `${name}_background`,\n\t\ttype: 'rect',\n\t\tfrom: { data: isDodgedAndStacked(options) ? `${name}_facet` : getBaseDataSourceName(options) },\n\t\tinteractive: false,\n\t\tencode: {\n\t\t\tenter: {\n\t\t\t\t...getBaseBarEnterEncodings(options),\n\t\t\t\tfill: { signal: BACKGROUND_COLOR },\n\t\t\t},\n\t\t\tupdate: {\n\t\t\t\t...getStackedDimensionEncodings(options),\n\t\t\t},\n\t\t},\n\t};\n};\n\nexport const getStackedBar = (options: BarSpecOptions): RectMark => {\n\tconst { name } = options;\n\treturn {\n\t\tname,\n\t\tdescription: name,\n\t\ttype: 'rect',\n\t\tfrom: { data: isDodgedAndStacked(options) ? `${name}_facet` : getBaseDataSourceName(options) },\n\t\tinteractive: isInteractive(options),\n\t\tencode: {\n\t\t\tenter: {\n\t\t\t\t...getBaseBarEnterEncodings(options),\n\t\t\t\t...getBarEnterEncodings(options),\n\t\t\t},\n\t\t\tupdate: {\n\t\t\t\t...getStackedDimensionEncodings(options),\n\t\t\t\t...getBarUpdateEncodings(options),\n\t\t\t},\n\t\t},\n\t};\n};\n\nexport const getStackedDimensionEncodings = (options: BarSpecOptions): RectEncodeEntry => {\n\tconst { dimension, orientation } = options;\n\tif (isDodgedAndStacked(options)) {\n\t\treturn getDodgedDimensionEncodings(options);\n\t}\n\n\tconst { dimensionAxis, rangeScale, dimensionScaleKey } = getOrientationProperties(orientation);\n\n\treturn {\n\t\t[dimensionAxis]: { scale: dimensionScaleKey, field: dimension },\n\t\t[rangeScale]: { scale: dimensionScaleKey, band: 1 },\n\t};\n};\n\nconst getBaseDataSourceName = (options: BarSpecOptions) => {\n\tif (isTrellised(options)) return getTrellisProperties(options).facetName;\n\treturn FILTERED_TABLE;\n};\n","/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport { GroupMark, Mark, Scale } from 'vega';\n\nimport { FILTERED_TABLE } from '@spectrum-charts/constants';\n\nimport { addDomainFields, getScaleIndexByName } from '../scale/scaleSpecBuilder';\nimport { BarSpecOptions } from '../types';\nimport { getDodgedDimensionEncodings, getTrellisedDimensionEncodings, isDodgedAndStacked } from './barUtils';\n\n/**\n * Generates the trellis group mark\n * @param options\n * @param marks visualization marks (bar, line, etc)\n * @param repeatedScale this is the scale that is repeated for each trellis, for example: y scale for vertical trellis, x scale for horizontal trellis\n * @returns\n */\nexport const getTrellisGroupMark = (options: BarSpecOptions, marks: Mark[], repeatedScale: Scale): GroupMark => {\n\tconst { trellisOrientation } = options;\n\tconst trellis = options.trellis as string;\n\tconst {\n\t\tmarkName,\n\t\tfacetName,\n\t\tscaleName,\n\t\taxis: trellisAxis,\n\t\trangeScale: trellisRangeScale,\n\t} = getTrellisProperties(options);\n\n\treturn {\n\t\tname: markName,\n\t\ttype: 'group',\n\n\t\t// Define data source for this trellis\n\t\tfrom: {\n\t\t\tfacet: {\n\t\t\t\tdata: FILTERED_TABLE,\n\t\t\t\tname: facetName,\n\t\t\t\tgroupby: trellis,\n\t\t\t},\n\t\t},\n\n\t\t// Override the default 'height' or 'width' signal with the trellis scale bandwidth\n\t\tsignals: [{ name: trellisRangeScale, update: `bandwidth('${scaleName}')` }],\n\n\t\t// Encode the trellis on its axis\n\t\tencode: {\n\t\t\tenter: {\n\t\t\t\t[trellisAxis]: { scale: scaleName, field: trellis },\n\t\t\t\theight: { signal: trellisOrientation === 'vertical' ? `bandwidth('${scaleName}')` : 'height' },\n\t\t\t\twidth: { signal: trellisOrientation === 'horizontal' ? `bandwidth('${scaleName}')` : 'width' },\n\t\t\t},\n\t\t},\n\n\t\tscales: [repeatedScale],\n\t\tmarks,\n\t};\n};\n\nexport const addTrellisScale = (scales: Scale[], options: BarSpecOptions) => {\n\tif (!options.trellis) {\n\t\treturn;\n\t}\n\tconst { scaleName, rangeScale, paddingInner } = getTrellisProperties(options);\n\tconst trellisScaleIndex = getScaleIndexByName(scales, scaleName, 'band');\n\tscales[trellisScaleIndex] = addDomainFields(scales[trellisScaleIndex], [options.trellis]);\n\tscales[trellisScaleIndex] = {\n\t\t...scales[trellisScaleIndex],\n\t\trange: rangeScale,\n\t\tpaddingInner,\n\t} as Scale;\n};\n\nexport const getTrellisedEncodeEntries = (options: BarSpecOptions) => {\n\tif (options.type === 'dodged' || isDodgedAndStacked(options)) {\n\t\treturn getDodgedDimensionEncodings(options);\n\t}\n\n\treturn getTrellisedDimensionEncodings(options);\n};\n\nexport interface BarTrellisProperties {\n\tfacetName: string;\n\tscaleName: 'xTrellisBand' | 'yTrellisBand';\n\tmarkName: 'xTrellisGroup' | 'yTrellisGroup';\n\trangeScale: 'width' | 'height';\n\taxis: 'x' | 'y';\n\tpaddingInner: number;\n}\n\nexport const getTrellisProperties = ({\n\ttrellisOrientation,\n\tname,\n\ttrellisPadding,\n}: BarSpecOptions): BarTrellisProperties => {\n\tconst axis = trellisOrientation === 'horizontal' ? 'x' : 'y';\n\n\treturn {\n\t\tfacetName: `${name}_trellis`,\n\t\tscaleName: `${axis}TrellisBand`,\n\t\tmarkName: `${axis}TrellisGroup`,\n\t\trangeScale: axis === 'x' ? 'width' : 'height',\n\t\taxis,\n\t\tpaddingInner: trellisPadding,\n\t};\n};\n\nexport const isTrellised = (options: BarSpecOptions) => Boolean(options.trellis);\n","/*\n * Copyright 2025 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport { Data, FormulaTransform, ValuesData } from 'vega';\n\nimport { TABLE } from '@spectrum-charts/constants';\n\nimport { getTableData } from '../data/dataUtils';\nimport { BulletSpecOptions, ThresholdBackground } from '../types';\n\n/**\n * Retrieves the bullet table data from the provided data array.\n * If it doesn't exist, creates and pushes a new one.\n * @param data The data array.\n * @returns The bullet table data.\n */\nexport const getBulletTableData = (data: Data[]): ValuesData => {\n\tlet tableData = getTableData(data);\n\tif (!tableData) {\n\t\ttableData = {\n\t\t\tname: TABLE,\n\t\t\tvalues: [],\n\t\t\ttransform: [],\n\t\t};\n\t\tdata.push(tableData);\n\t}\n\treturn tableData;\n};\n\n/**\n * Generates the necessary formula transforms for the bullet chart.\n * It calculates the xPaddingForTarget and, if in flexible scale mode, adds the flexibleScaleValue.\n * It also generates a color expression for the threshold bars if applicable.\n * @param bulletOptions The bullet spec properties.\n * @returns An array of formula transforms.\n */\nexport const getBulletTransforms = (bulletOptions: BulletSpecOptions): FormulaTransform[] => {\n\tconst transforms: FormulaTransform[] = [\n\t\t{\n\t\t\ttype: 'formula',\n\t\t\texpr: `isValid(datum.${bulletOptions.target}) ? round(datum.${bulletOptions.target} * 1.05) : 0`,\n\t\t\tas: 'xPaddingForTarget',\n\t\t},\n\t];\n\n\tif (bulletOptions.scaleType === 'flexible') {\n\t\ttransforms.push({\n\t\t\ttype: 'formula',\n\t\t\texpr: `${bulletOptions.maxScaleValue}`,\n\t\t\tas: 'flexibleScaleValue',\n\t\t});\n\t}\n\n\tif (bulletOptions.thresholdBarColor && (bulletOptions.thresholds?.length ?? 0) > 0) {\n\t\ttransforms.push({\n\t\t\ttype: 'formula',\n\t\t\texpr: generateThresholdColorExpr(bulletOptions.thresholds ?? [], bulletOptions.metric, bulletOptions.color),\n\t\t\tas: 'barColor',\n\t\t});\n\t}\n\n\treturn transforms;\n};\n\n/**\n * Generates a Vega expression for the color of the bullet chart based on the provided thresholds.\n * The expression checks the value of the metric field against the thresholds and assigns the appropriate color.\n * @param thresholds An array of threshold objects.\n * @param metricField The name of the metric field in the data.\n * @param defaultColor The default color to use if no thresholds are met.\n * @returns A string representing the Vega expression for the color.\n */\nexport function generateThresholdColorExpr(\n\tthresholds: ThresholdBackground[],\n\tmetricField: string,\n\tdefaultColor: string\n): string {\n\tif (!thresholds || thresholds.length === 0) return `'${defaultColor}'`;\n\n\tconst sorted: ThresholdBackground[] = thresholds.slice().sort((a, b) => {\n\t\tconst aMin = a.thresholdMin !== undefined ? a.thresholdMin : -1e12;\n\t\tconst bMin = b.thresholdMin !== undefined ? b.thresholdMin : -1e12;\n\t\treturn aMin - bMin;\n\t});\n\n\tconst exprParts: string[] = [];\n\n\t// For values below the first threshold's lower bound, use the default color.\n\texprParts.push(\n\t\t`(datum.${metricField} < ${\n\t\t\tsorted[0].thresholdMin !== undefined ? sorted[0].thresholdMin : -1e12\n\t\t}) ? '${defaultColor}' : `\n\t);\n\n\t// For each threshold, check if the metric field is within the range defined by the thresholdMin and thresholdMax values.\n\t// If it is, use the corresponding fill color.\n\tfor (let i = 0; i < sorted.length - 1; i++) {\n\t\tconst nextLower = sorted[i + 1].thresholdMin !== undefined ? sorted[i + 1].thresholdMin : -1e12;\n\t\texprParts.push(`(datum.${metricField} < ${nextLower}) ? '${sorted[i].fill}' : `);\n\t}\n\n\t// For values above the last threshold's upper bound, use the last threshold's fill color.\n\texprParts.push(`'${sorted[sorted.length - 1].fill}'`);\n\n\tconst expr = exprParts.join('');\n\treturn expr;\n}\n","/*\n * Copyright 2025 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport { produce } from 'immer';\nimport { Axis, GroupMark, Mark } from 'vega';\n\nimport { getColorValue } from '@spectrum-charts/themes';\n\nimport { BulletSpecOptions } from '../types';\n\nexport const addMarks = produce<Mark[], [BulletSpecOptions]>((marks, bulletOptions) => {\n\tconst markGroupEncodeUpdateDirection = bulletOptions.direction === 'column' ? 'y' : 'x';\n\tconst bulletGroupWidth = bulletOptions.direction === 'column' ? 'width' : 'bulletGroupWidth';\n\n\tconst bulletMark: GroupMark = {\n\t\tname: 'bulletGroup',\n\t\ttype: 'group',\n\t\tfrom: {\n\t\t\tfacet: { data: 'table', name: 'bulletGroups', groupby: `${bulletOptions.dimension}` },\n\t\t},\n\t\tencode: {\n\t\t\tupdate: {\n\t\t\t\t[markGroupEncodeUpdateDirection]: { scale: 'groupScale', field: `${bulletOptions.dimension}` },\n\t\t\t\theight: { signal: 'bulletGroupHeight' },\n\t\t\t\twidth: { signal: bulletGroupWidth },\n\t\t\t},\n\t\t},\n\t\tmarks: [],\n\t};\n\n\tconst thresholds = bulletOptions.thresholds;\n\n\tif (Array.isArray(thresholds) && thresholds.length > 0) {\n\t\tbulletMark.data = [\n\t\t\t{\n\t\t\t\tname: 'thresholds',\n\t\t\t\tvalues: thresholds,\n\t\t\t\ttransform: [{ type: 'identifier', as: 'id' }],\n\t\t\t},\n\t\t];\n\t\tbulletMark.marks?.push(getBulletMarkThreshold(bulletOptions));\n\t} else if (bulletOptions.track) {\n\t\tbulletMark.marks?.push(getBulletTrack(bulletOptions));\n\t}\n\n\tbulletMark.marks?.push(getBulletMarkRect(bulletOptions));\n\tif (bulletOptions.target && bulletOptions.showTarget !== false) {\n\t\tbulletMark.marks?.push(getBulletMarkTarget(bulletOptions));\n\t\tif (bulletOptions.showTargetValue) {\n\t\t\tbulletMark.marks?.push(getBulletMarkTargetValueLabel(bulletOptions));\n\t\t}\n\t}\n\n\tif (bulletOptions.labelPosition === 'top' || bulletOptions.direction === 'row') {\n\t\tbulletMark.marks?.push(getBulletMarkLabel(bulletOptions));\n\t\tbulletMark.marks?.push(getBulletMarkValueLabel(bulletOptions));\n\t}\n\n\tmarks.push(bulletMark);\n});\n\nexport function getBulletMarkRect(bulletOptions: BulletSpecOptions): Mark {\n\t//The vertical positioning is calculated starting at the bulletgroupheight\n\t//and then subtracting two times the bullet height to center the bullet bar\n\t//in the middle of the threshold. The 3 is subtracted because the bulletgroup height\n\t//starts the bullet below the threshold area.\n\t//Additionally, the value of the targetValueLabelHeight is subtracted if the target value label is shown\n\t//to make sure that the bullet bar is not drawn over the target value label.\n\tconst bulletMarkRectEncodeUpdateYSignal =\n\t\tbulletOptions.showTarget && bulletOptions.showTargetValue\n\t\t\t? 'bulletGroupHeight - targetValueLabelHeight - 3 - 2 * bulletHeight'\n\t\t\t: 'bulletGroupHeight - 3 - 2 * bulletHeight';\n\n\tconst fillColor =\n\t\tbulletOptions.thresholdBarColor && (bulletOptions.thresholds?.length ?? 0) > 0\n\t\t\t? [{ field: 'barColor' }]\n\t\t\t: [{ value: bulletOptions.color }];\n\n\tconst bulletMarkRect: Mark = {\n\t\tname: `${bulletOptions.name}Rect`,\n\t\tdescription: `${bulletOptions.name}Rect`,\n\t\ttype: 'rect',\n\t\tfrom: { data: 'bulletGroups' },\n\t\tencode: {\n\t\t\tenter: {\n\t\t\t\tcornerRadiusTopLeft: [{ test: `datum.${bulletOptions.metric} < 0`, value: 3 }],\n\t\t\t\tcornerRadiusBottomLeft: [{ test: `datum.${bulletOptions.metric} < 0`, value: 3 }],\n\t\t\t\tcornerRadiusTopRight: [{ test: `datum.${bulletOptions.metric} > 0`, value: 3 }],\n\t\t\t\tcornerRadiusBottomRight: [{ test: `datum.${bulletOptions.metric} > 0`, value: 3 }],\n\t\t\t\tfill: fillColor,\n\t\t\t},\n\t\t\tupdate: {\n\t\t\t\tx: { scale: 'xscale', value: 0 },\n\t\t\t\tx2: { scale: 'xscale', field: `${bulletOptions.metric}` },\n\t\t\t\theight: { signal: 'bulletHeight' },\n\t\t\t\ty: { signal: bulletMarkRectEncodeUpdateYSignal },\n\t\t\t},\n\t\t},\n\t};\n\n\treturn bulletMarkRect;\n}\n\nexport function getBulletMarkTarget(bulletOptions: BulletSpecOptions): Mark {\n\tconst solidColor = getColorValue('gray-900', bulletOptions.colorScheme);\n\n\t//When the target value label is shown, we must subtract the height of the target value label\n\t//to make sure that the target line is not drawn over the target value label\n\tconst bulletMarkTargetEncodeUpdateY =\n\t\tbulletOptions.showTarget && bulletOptions.showTargetValue\n\t\t\t? 'bulletGroupHeight - targetValueLabelHeight - targetHeight'\n\t\t\t: 'bulletGroupHeight - targetHeight';\n\tconst bulletMarkTargetEncodeUpdateY2 =\n\t\tbulletOptions.showTarget && bulletOptions.showTargetValue\n\t\t\t? 'bulletGroupHeight - targetValueLabelHeight'\n\t\t\t: 'bulletGroupHeight';\n\n\tconst bulletMarkTarget: Mark = {\n\t\tname: `${bulletOptions.name}Target`,\n\t\tdescription: `${bulletOptions.name}Target`,\n\t\ttype: 'rule',\n\t\tfrom: { data: 'bulletGroups' },\n\t\tencode: {\n\t\t\tenter: {\n\t\t\t\tstroke: { value: `${solidColor}` },\n\t\t\t\tstrokeWidth: { value: 2 },\n\t\t\t},\n\t\t\tupdate: {\n\t\t\t\tx: { scale: 'xscale', field: `${bulletOptions.target}` },\n\t\t\t\ty: { signal: bulletMarkTargetEncodeUpdateY },\n\t\t\t\ty2: { signal: bulletMarkTargetEncodeUpdateY2 },\n\t\t\t},\n\t\t},\n\t};\n\n\treturn bulletMarkTarget;\n}\n\nexport function getBulletMarkLabel(bulletOptions: BulletSpecOptions): Mark {\n\tconst barLabelColor = getColorValue('gray-600', bulletOptions.colorScheme);\n\n\tconst bulletMarkLabel: Mark = {\n\t\tname: `${bulletOptions.name}Label`,\n\t\tdescription: `${bulletOptions.name}Label`,\n\t\ttype: 'text',\n\t\tfrom: { data: 'bulletGroups' },\n\t\tencode: {\n\t\t\tenter: {\n\t\t\t\ttext: { signal: `datum.${bulletOptions.dimension}` },\n\t\t\t\talign: { value: 'left' },\n\t\t\t\tbaseline: { value: 'top' },\n\t\t\t\tfill: { value: `${barLabelColor}` },\n\t\t\t},\n\t\t\tupdate: { x: { value: 0 }, y: { value: 0 } },\n\t\t},\n\t};\n\n\treturn bulletMarkLabel;\n}\n\nexport function getBulletMarkValueLabel(bulletOptions: BulletSpecOptions): Mark {\n\tconst defaultColor = getColorValue(bulletOptions.color, bulletOptions.colorScheme);\n\tconst solidColor = getColorValue('gray-900', bulletOptions.colorScheme);\n\tconst encodeUpdateSignalWidth = bulletOptions.direction === 'column' ? 'width' : 'bulletGroupWidth';\n\tconst fillExpr =\n\t\tbulletOptions.thresholdBarColor && (bulletOptions.thresholds?.length ?? 0) > 0\n\t\t\t? `datum.barColor === '${defaultColor}' ? '${solidColor}' : datum.barColor`\n\t\t\t: `'${solidColor}'`;\n\n\tconst bulletMarkValueLabel: Mark = {\n\t\tname: `${bulletOptions.name}ValueLabel`,\n\t\tdescription: `${bulletOptions.name}ValueLabel`,\n\t\ttype: 'text',\n\t\tfrom: { data: 'bulletGroups' },\n\t\tencode: {\n\t\t\tenter: {\n\t\t\t\ttext: {\n\t\t\t\t\tsignal: `datum.${bulletOptions.metric} != null ? format(datum.${bulletOptions.metric}, '${\n\t\t\t\t\t\tbulletOptions.numberFormat || ''\n\t\t\t\t\t}') : ''`,\n\t\t\t\t},\n\t\t\t\talign: { value: 'right' },\n\t\t\t\tbaseline: { value: 'top' },\n\t\t\t\tfill: { signal: fillExpr },\n\t\t\t},\n\t\t\tupdate: { x: { signal: encodeUpdateSignalWidth }, y: { value: 0 } },\n\t\t},\n\t};\n\n\treturn bulletMarkValueLabel;\n}\n\nexport function getBulletMarkTargetValueLabel(bulletOptions: BulletSpecOptions): Mark {\n\tconst solidColor = getColorValue('gray-900', bulletOptions.colorScheme);\n\n\tconst bulletMarkTargetValueLabel: Mark = {\n\t\tname: `${bulletOptions.name}TargetValueLabel`,\n\t\tdescription: `${bulletOptions.name}TargetValueLabel`,\n\t\ttype: 'text',\n\t\tfrom: { data: 'bulletGroups' },\n\t\tencode: {\n\t\t\tenter: {\n\t\t\t\ttext: {\n\t\t\t\t\tsignal: `datum.${bulletOptions.target} != null ? 'Target: ' + format(datum.${bulletOptions.target}, '$,.2f') : 'No Target'`,\n\t\t\t\t},\n\t\t\t\talign: { value: 'center' },\n\t\t\t\tbaseline: { value: 'top' },\n\t\t\t\tfill: { value: `${solidColor}` },\n\t\t\t},\n\t\t\tupdate: {\n\t\t\t\tx: { scale: 'xscale', field: `${bulletOptions.target}` },\n\t\t\t\ty: { signal: 'bulletGroupHeight - targetValueLabelHeight + 6' },\n\t\t\t},\n\t\t},\n\t};\n\n\treturn bulletMarkTargetValueLabel;\n}\n\nexport function getBulletMarkThreshold(bulletOptions: BulletSpecOptions): Mark {\n\t// Vertically center the threshold bar by offsetting from bulletGroupHeight.\n\t// Subtract 3 for alignment and targetValueLabelHeight if the label is shown.\n\tconst baseHeightSignal = 'bulletGroupHeight - 3 - bulletThresholdHeight';\n\tconst encodeUpdateYSignal =\n\t\tbulletOptions.showTarget && bulletOptions.showTargetValue\n\t\t\t? `${baseHeightSignal} - targetValueLabelHeight`\n\t\t\t: baseHeightSignal;\n\n\tconst bulletMarkThreshold: Mark = {\n\t\tname: `${bulletOptions.name}Threshold`,\n\t\tdescription: `${bulletOptions.name}Threshold`,\n\t\ttype: 'rect',\n\t\tfrom: { data: 'thresholds' },\n\t\tclip: true,\n\t\tencode: {\n\t\t\tenter: {\n\t\t\t\tcornerRadiusTopLeft: [\n\t\t\t\t\t{ test: `!isDefined(datum.thresholdMin) && domain('xscale')[0] !== 0`, value: 3 },\n\t\t\t\t],\n\t\t\t\tcornerRadiusBottomLeft: [\n\t\t\t\t\t{ test: `!isDefined(datum.thresholdMin) && domain('xscale')[0] !== 0`, value: 3 },\n\t\t\t\t],\n\t\t\t\tcornerRadiusTopRight: [\n\t\t\t\t\t{ test: `!isDefined(datum.thresholdMax) && domain('xscale')[1] !== 0`, value: 3 },\n\t\t\t\t],\n\t\t\t\tcornerRadiusBottomRight: [\n\t\t\t\t\t{ test: `!isDefined(datum.thresholdMax) && domain('xscale')[1] !== 0`, value: 3 },\n\t\t\t\t],\n\t\t\t\tfill: { field: 'fill' },\n\t\t\t\tfillOpacity: { value: 0.2 },\n\t\t\t},\n\t\t\tupdate: {\n\t\t\t\tx: {\n\t\t\t\t\tsignal: \"isDefined(datum.thresholdMin) ? scale('xscale', datum.thresholdMin) : 0\",\n\t\t\t\t},\n\t\t\t\tx2: {\n\t\t\t\t\tsignal: \"isDefined(datum.thresholdMax) ? scale('xscale', datum.thresholdMax) : width\",\n\t\t\t\t},\n\t\t\t\theight: { signal: 'bulletThresholdHeight' },\n\t\t\t\ty: { signal: encodeUpdateYSignal },\n\t\t\t},\n\t\t},\n\t};\n\treturn bulletMarkThreshold;\n}\n\nexport function getBulletTrack(bulletOptions: BulletSpecOptions): Mark {\n\tconst trackColor = getColorValue('gray-200', bulletOptions.colorScheme);\n\tconst trackWidth = bulletOptions.direction === 'column' ? 'width' : 'bulletGroupWidth';\n\t// Subtracting 20 accounts for the space used by the target value label\n\tconst trackY =\n\t\tbulletOptions.showTarget && bulletOptions.showTargetValue\n\t\t\t? 'bulletGroupHeight - 3 - 2 * bulletHeight - 20'\n\t\t\t: 'bulletGroupHeight - 3 - 2 * bulletHeight';\n\n\tconst bulletTrack: Mark = {\n\t\tname: `${bulletOptions.name}Track`,\n\t\tdescription: `${bulletOptions.name}Track`,\n\t\ttype: 'rect',\n\t\tfrom: { data: 'bulletGroups' },\n\t\tencode: {\n\t\t\tenter: {\n\t\t\t\tfill: { value: trackColor },\n\t\t\t\tcornerRadiusTopRight: [{ test: \"domain('xscale')[1] !== 0\", value: 3 }],\n\t\t\t\tcornerRadiusBottomRight: [{ test: \"domain('xscale')[1] !== 0\", value: 3 }],\n\t\t\t\tcornerRadiusTopLeft: [{ test: \"domain('xscale')[0] !== 0\", value: 3 }],\n\t\t\t\tcornerRadiusBottomLeft: [{ test: \"domain('xscale')[0] !== 0\", value: 3 }],\n\t\t\t},\n\t\t\tupdate: {\n\t\t\t\tx: { value: 0 },\n\t\t\t\twidth: { signal: trackWidth },\n\t\t\t\theight: { signal: 'bulletHeight' },\n\t\t\t\ty: { signal: trackY },\n\t\t\t},\n\t\t},\n\t};\n\n\treturn bulletTrack;\n}\n\nexport function getBulletLabelAxesLeft(labelOffset): Axis {\n\treturn {\n\t\tscale: 'groupScale',\n\t\torient: 'left',\n\t\ttickSize: 0,\n\t\tlabelOffset: labelOffset,\n\t\tlabelPadding: 10,\n\t\tlabelColor: '#797979',\n\t\tdomain: false,\n\t};\n}\n\nexport function getBulletLabelAxesRight(bulletOptions: BulletSpecOptions, labelOffset): Axis {\n\treturn {\n\t\tscale: 'groupScale',\n\t\torient: 'right',\n\t\ttickSize: 0,\n\t\tlabelOffset: labelOffset,\n\t\tlabelPadding: 10,\n\t\tdomain: false,\n\t\tencode: {\n\t\t\tlabels: {\n\t\t\t\tupdate: {\n\t\t\t\t\ttext: {\n\t\t\t\t\t\tsignal: `info(data('table')[datum.index * (length(data('table')) - 1)].${\n\t\t\t\t\t\t\tbulletOptions.metric\n\t\t\t\t\t\t}) != null ? format(info(data('table')[datum.index * (length(data('table')) - 1)].${\n\t\t\t\t\t\t\tbulletOptions.metric\n\t\t\t\t\t\t}), '${bulletOptions.numberFormat || ''}') : ''`,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t};\n}\n\nexport function getBulletScaleAxes(): Axis {\n\treturn {\n\t\tlabelOffset: 2,\n\t\tscale: 'xscale',\n\t\torient: 'bottom',\n\t\tticks: false,\n\t\tlabelColor: 'gray',\n\t\tdomain: false,\n\t\ttickCount: 5,\n\t\toffset: { signal: 'axisOffset' },\n\t};\n}\n\nexport const addAxes = produce<Axis[], [BulletSpecOptions]>((axes, bulletOptions) => {\n\tif (bulletOptions.metricAxis && bulletOptions.direction === 'column' && !bulletOptions.showTargetValue) {\n\t\taxes.push(getBulletScaleAxes());\n\t}\n\n\tif (bulletOptions.labelPosition === 'side' && bulletOptions.direction === 'column') {\n\t\tconst labelOffset = bulletOptions.showTargetValue && bulletOptions.showTarget ? -8 : 2;\n\t\taxes.push(getBulletLabelAxesLeft(labelOffset));\n\t\taxes.push(getBulletLabelAxesRight(bulletOptions, labelOffset));\n\t}\n});\n","/*\n * Copyright 2025 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport { produce } from 'immer';\nimport { Data, Scale, Signal, Spec } from 'vega';\n\nimport {\n\tDEFAULT_BULLET_DIRECTION,\n\tDEFAULT_COLOR_SCHEME,\n\tDEFAULT_LABEL_POSITION,\n\tDEFAULT_SCALE_TYPE,\n\tDEFAULT_SCALE_VALUE,\n} from '@spectrum-charts/constants';\nimport { getColorValue, spectrumColors } from '@spectrum-charts/themes';\nimport { toCamelCase } from '@spectrum-charts/utils';\n\nimport { BulletOptions, BulletSpecOptions, ColorScheme } from '../types';\nimport { getBulletTableData, getBulletTransforms } from './bulletDataUtils';\nimport { addAxes, addMarks } from './bulletMarkUtils';\n\nconst DEFAULT_COLOR = spectrumColors.light['static-blue'];\n\nexport const addBullet = produce<Spec, [BulletOptions & { colorScheme?: ColorScheme; index?: number; idKey: string }]>(\n\t(\n\t\tspec,\n\t\t{\n\t\t\tcolorScheme = DEFAULT_COLOR_SCHEME,\n\t\t\tindex = 0,\n\t\t\tname,\n\t\t\tmetric,\n\t\t\tdimension,\n\t\t\ttarget,\n\t\t\tcolor = DEFAULT_COLOR,\n\t\t\tdirection = DEFAULT_BULLET_DIRECTION,\n\t\t\tnumberFormat,\n\t\t\tshowTarget = true,\n\t\t\tshowTargetValue = false,\n\t\t\tlabelPosition = DEFAULT_LABEL_POSITION,\n\t\t\tscaleType = DEFAULT_SCALE_TYPE,\n\t\t\tmaxScaleValue = DEFAULT_SCALE_VALUE,\n\t\t\tthresholds = [],\n\t\t\ttrack = false,\n\t\t\tthresholdBarColor = false,\n\t\t\tmetricAxis = false,\n\t\t\t...options\n\t\t}\n\t) => {\n\t\tconst bulletOptions: BulletSpecOptions = {\n\t\t\tcolorScheme: colorScheme,\n\t\t\tindex,\n\t\t\tcolor: getColorValue(color, colorScheme),\n\t\t\tmetric: metric ?? 'currentAmount',\n\t\t\tdimension: dimension ?? 'graphLabel',\n\t\t\ttarget: target ?? 'target',\n\t\t\tname: toCamelCase(name ?? `bullet${index}`),\n\t\t\tdirection: direction,\n\t\t\tnumberFormat: numberFormat ?? '',\n\t\t\tshowTarget: showTarget,\n\t\t\tshowTargetValue: showTargetValue,\n\t\t\tlabelPosition: labelPosition,\n\t\t\tscaleType: scaleType,\n\t\t\tmaxScaleValue: maxScaleValue,\n\t\t\ttrack: track,\n\t\t\tthresholds: thresholds,\n\t\t\tthresholdBarColor: thresholdBarColor,\n\t\t\tmetricAxis: metricAxis,\n\t\t\t...options,\n\t\t};\n\n\t\tspec.data = addData(spec.data ?? [], bulletOptions);\n\t\tspec.marks = addMarks(spec.marks ?? [], bulletOptions);\n\t\tspec.scales = addScales(spec.scales ?? [], bulletOptions);\n\t\tspec.signals = addSignals(spec.signals ?? [], bulletOptions);\n\t\tspec.axes = addAxes(spec.axes ?? [], bulletOptions);\n\t}\n);\n\nexport const addScales = produce<Scale[], [BulletSpecOptions]>((scales, options) => {\n\tconst groupScaleRangeSignal = options.direction === 'column' ? 'bulletChartHeight' : 'width';\n\tconst xRange = options.direction === 'column' ? 'width' : [0, { signal: 'bulletGroupWidth' }];\n\tlet domainFields;\n\n\tif (options.scaleType === 'flexible' && options.maxScaleValue > 0) {\n\t\tdomainFields = { data: 'table', fields: ['xPaddingForTarget', options.metric, 'flexibleScaleValue'] };\n\t} else if (options.scaleType === 'fixed' && options.maxScaleValue > 0) {\n\t\tdomainFields = [0, `${options.maxScaleValue}`];\n\t} else {\n\t\tdomainFields = { data: 'table', fields: ['xPaddingForTarget', options.metric] };\n\t}\n\n\tscales.push(\n\t\t{\n\t\t\tname: 'groupScale',\n\t\t\ttype: 'band',\n\t\t\tdomain: { data: 'table', field: options.dimension },\n\t\t\trange: [0, { signal: groupScaleRangeSignal }],\n\t\t\tpaddingInner: { signal: 'paddingRatio' },\n\t\t},\n\t\t{\n\t\t\tname: 'xscale',\n\t\t\ttype: 'linear',\n\t\t\tdomain: domainFields,\n\t\t\trange: xRange,\n\t\t\tround: true,\n\t\t\tclamp: true,\n\t\t\tzero: true,\n\t\t}\n\t);\n});\n\nexport const addSignals = produce<Signal[], [BulletSpecOptions]>((signals, options) => {\n\tsignals.push({ name: 'gap', value: 12 });\n\tsignals.push({ name: 'bulletHeight', value: 8 });\n\tsignals.push({ name: 'bulletThresholdHeight', update: 'bulletHeight * 3' });\n\tsignals.push({ name: 'targetHeight', update: 'bulletThresholdHeight + 6' });\n\n\tif (options.showTargetValue && options.showTarget) {\n\t\tsignals.push({ name: 'targetValueLabelHeight', update: '20' });\n\t}\n\n\tsignals.push({\n\t\tname: 'bulletGroupHeight',\n\t\tupdate: getBulletGroupHeightExpression(options),\n\t});\n\n\tif (options.direction === 'column') {\n\t\tsignals.push({ name: 'paddingRatio', update: 'gap / (gap + bulletGroupHeight)' });\n\n\t\tif (options.metricAxis && !options.showTargetValue) {\n\t\t\tsignals.push({\n\t\t\t\tname: 'bulletChartHeight',\n\t\t\t\tupdate: \"length(data('table')) * bulletGroupHeight + (length(data('table')) - 1) * gap + 10\",\n\t\t\t});\n\t\t\tsignals.push({\n\t\t\t\tname: 'axisOffset',\n\t\t\t\tupdate: 'bulletChartHeight - height - 10',\n\t\t\t});\n\t\t} else {\n\t\t\tsignals.push({\n\t\t\t\tname: 'bulletChartHeight',\n\t\t\t\tupdate: \"length(data('table')) * bulletGroupHeight + (length(data('table')) - 1) * gap\",\n\t\t\t});\n\t\t}\n\t} else {\n\t\tsignals.push({ name: 'bulletGroupWidth', update: \"(width / length(data('table'))) - gap\" });\n\t\tsignals.push({ name: 'paddingRatio', update: 'gap / (gap + bulletGroupWidth)' });\n\t\tsignals.push({ name: 'bulletChartHeight', update: 'bulletGroupHeight' });\n\t}\n});\n\n/**\n * Returns the height of the bullet group based on the options\n * @param options the bullet spec options\n * @returns the height of the bullet group\n */\nfunction getBulletGroupHeightExpression(options: BulletSpecOptions): string {\n\tif (options.showTargetValue && options.showTarget) {\n\t\treturn options.labelPosition === 'side' && options.direction === 'column'\n\t\t\t? 'bulletThresholdHeight + targetValueLabelHeight + 10'\n\t\t\t: 'bulletThresholdHeight + targetValueLabelHeight + 24';\n\t} else if (options.labelPosition === 'side' && options.direction === 'column') {\n\t\treturn 'bulletThresholdHeight + 10';\n\t}\n\treturn 'bulletThresholdHeight + 24';\n}\n\nexport const addData = produce<Data[], [BulletSpecOptions]>((data, options) => {\n\tconst tableData = getBulletTableData(data);\n\ttableData.transform = getBulletTransforms(options);\n});\n","/*\n * Copyright 2024 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport { Data, FormulaTransform, SourceData } from 'vega';\n\nimport { FILTERED_TABLE, SELECTED_GROUP, SERIES_ID } from '@spectrum-charts/constants';\n\nimport { getFilteredTableData } from '../data/dataUtils';\nimport {\n\tAreaSpecOptions,\n\tBarSpecOptions,\n\tChartPopoverOptions,\n\tChartPopoverSpecOptions,\n\tDonutSpecOptions,\n\tLineSpecOptions,\n\tScatterSpecOptions,\n} from '../types';\n\ntype PopoverParentOptions = AreaSpecOptions | BarSpecOptions | DonutSpecOptions | LineSpecOptions | ScatterSpecOptions;\n\n/**\n * gets all the popovers\n * @param markOptions\n * @returns\n */\nexport const getPopovers = (chartPopovers: ChartPopoverOptions[], markName: string): ChartPopoverSpecOptions[] => {\n\treturn chartPopovers.map((chartPopover) => applyPopoverPropDefaults(chartPopover, markName));\n};\n\n/**\n * Applies all defaults to ChartPopoverOptions\n * @param chartPopoverOptions\n * @returns ChartPopoverSpecOptions\n */\nexport const applyPopoverPropDefaults = (\n\t{ UNSAFE_highlightBy = 'item', ...options }: ChartPopoverOptions,\n\tmarkName: string\n): ChartPopoverSpecOptions => {\n\treturn {\n\t\tUNSAFE_highlightBy,\n\t\tmarkName,\n\t\t...options,\n\t};\n};\n\n/**\n * Sets all the data needed for popovers\n *\n * NOTE: this function mutates the data object so it should only be called from a produce function\n * @param data\n * @param markOptions\n */\nexport const addPopoverData = (data: Data[], markOptions: PopoverParentOptions, addHighlightedData = true) => {\n\tconst popovers = getPopovers(markOptions.chartPopovers, markOptions.name);\n\n\tfor (const { UNSAFE_highlightBy, markName } of popovers) {\n\t\tconst filteredTable = getFilteredTableData(data);\n\t\tif (!filteredTable.transform) {\n\t\t\tfilteredTable.transform = [];\n\t\t}\n\t\tif (UNSAFE_highlightBy === 'dimension' && markOptions.markType !== 'donut') {\n\t\t\tfilteredTable.transform.push(getGroupIdTransform([markOptions.dimension], markName));\n\t\t} else if (UNSAFE_highlightBy === 'series') {\n\t\t\tfilteredTable.transform.push(getGroupIdTransform([SERIES_ID], markName));\n\t\t} else if (Array.isArray(UNSAFE_highlightBy)) {\n\t\t\tfilteredTable.transform.push(getGroupIdTransform(UNSAFE_highlightBy, markName));\n\t\t} else {\n\t\t\tfilteredTable.transform.push(getGroupIdTransform([markOptions.idKey], markName));\n\t\t}\n\n\t\tif (addHighlightedData) {\n\t\t\tdata.push(getMarkSelectedData(markName));\n\t\t}\n\t}\n};\n\n/**\n * Gets the group id transform\n * @param highlightBy\n * @param markName\n * @returns FormulaTransform\n */\nexport const getGroupIdTransform = (highlightBy: string[], markName: string): FormulaTransform => {\n\treturn {\n\t\ttype: 'formula',\n\t\tas: `${markName}_selectedGroupId`,\n\t\texpr: highlightBy.map((facet) => `datum.${facet}`).join(' + \" | \" + '),\n\t};\n};\n\n/**\n * Gets the selected data for a mark\n * @param markName\n * @returns\n */\nconst getMarkSelectedData = (markName: string): SourceData => ({\n\tname: `${markName}_selectedData`,\n\tsource: FILTERED_TABLE,\n\ttransform: [\n\t\t{\n\t\t\ttype: 'filter',\n\t\t\texpr: `${SELECTED_GROUP} === datum.${markName}_selectedGroupId`,\n\t\t},\n\t],\n});\n","/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport { produce } from 'immer';\nimport { Data, LinearScale, OrdinalScale, PointScale, Scale, Signal, Spec } from 'vega';\n\nimport {\n\tBACKGROUND_COLOR,\n\tDEFAULT_BACKGROUND_COLOR,\n\tDEFAULT_COLOR_SCHEME,\n\tDEFAULT_LINE_TYPES,\n\tFILTERED_TABLE,\n\tHIGHLIGHTED_GROUP,\n\tHIGHLIGHTED_ITEM,\n\tHIGHLIGHTED_SERIES,\n\tLINEAR_COLOR_SCALE,\n\tLINE_TYPE_SCALE,\n\tLINE_WIDTH_SCALE,\n\tMARK_ID,\n\tOPACITY_SCALE,\n\tSELECTED_GROUP,\n\tSELECTED_ITEM,\n\tSELECTED_SERIES,\n\tSERIES_ID,\n\tSYMBOL_PATH_WIDTH_SCALE,\n\tSYMBOL_SHAPE_SCALE,\n\tSYMBOL_SIZE_SCALE,\n\tTABLE,\n} from '@spectrum-charts/constants';\nimport { colorSchemes, getColorValue } from '@spectrum-charts/themes';\n\nimport { addArea } from './area/areaSpecBuilder';\nimport { addAxis } from './axis/axisSpecBuilder';\nimport { addBar } from './bar/barSpecBuilder';\nimport { addBullet } from './bullet/bulletSpecBuilder';\nimport { addCombo } from './combo/comboSpecBuilder';\nimport { getSeriesIdTransform } from './data/dataUtils';\nimport { addDonut } from './donut/donutSpecBuilder';\nimport { setHoverOpacityForMarks } from './legend/legendHighlightUtils';\nimport { addLegend } from './legend/legendSpecBuilder';\nimport { addLine } from './line/lineSpecBuilder';\nimport { getOrdinalScale } from './scale/scaleSpecBuilder';\nimport { addScatter } from './scatter/scatterSpecBuilder';\nimport { getGenericValueSignal } from './signal/signalSpecBuilder';\nimport {\n\tgetFacetsFromScales,\n\tgetLineWidthPixelsFromLineWidth,\n\tgetPathFromSymbolShape,\n\tgetStrokeDashFromLineType,\n\tgetSymbolWidthFromRscSymbolSize,\n\tgetVegaSymbolSizeFromRscSymbolSize,\n\tinitializeSpec,\n} from './specUtils';\nimport { addTitle } from './title/titleSpecBuilder';\nimport {\n\tChartColors,\n\tChartOptions,\n\tChartSpecOptions,\n\tChartSymbolShape,\n\tColorScale,\n\tColorScheme,\n\tColors,\n\tLineType,\n\tLineTypes,\n\tLineWidth,\n\tOpacities,\n\tSymbolShapes,\n\tSymbolSize,\n} from './types';\n\nexport interface ChartSpecBuilder {\n\tbuildSpec: (options: ChartOptions) => Spec;\n}\n\nexport function buildSpec({\n\taxes = [],\n\tbackgroundColor = DEFAULT_BACKGROUND_COLOR,\n\tcolors = 'categorical12',\n\tcolorScheme = DEFAULT_COLOR_SCHEME,\n\tdescription,\n\thiddenSeries = [],\n\thighlightedItem,\n\thighlightedSeries,\n\tidKey = MARK_ID,\n\tlegends = [],\n\tlineTypes = DEFAULT_LINE_TYPES as LineType[],\n\tlineWidths = ['M'],\n\tmarks = [],\n\topacities,\n\tsymbolShapes = ['rounded-square'],\n\tsymbolSizes = ['XS', 'XL'],\n\ttitle,\n\ttitles = [],\n}: ChartOptions) {\n\tconst options: ChartSpecOptions = {\n\t\taxes,\n\t\tbackgroundColor,\n\t\tcolors,\n\t\tcolorScheme,\n\t\tdescription,\n\t\thiddenSeries,\n\t\thighlightedItem,\n\t\thighlightedSeries,\n\t\tidKey,\n\t\tlegends,\n\t\tlineTypes,\n\t\tlineWidths,\n\t\tmarks,\n\t\topacities,\n\t\tsymbolShapes,\n\t\tsymbolSizes,\n\t\ttitle,\n\t\ttitles,\n\t};\n\tlet spec = initializeSpec(null, { backgroundColor, colorScheme, description, title });\n\tspec.signals = getDefaultSignals(options);\n\tspec.scales = getDefaultScales(colors, colorScheme, lineTypes, lineWidths, opacities, symbolShapes, symbolSizes);\n\n\tlet { areaCount, barCount, bulletCount, comboCount, donutCount, lineCount, scatterCount } =\n\t\tinitializeComponentCounts();\n\tconst specOptions = { colorScheme, idKey, highlightedItem };\n\tspec = [...marks].reduce((acc: Spec, mark) => {\n\t\tswitch (mark.markType) {\n\t\t\tcase 'area':\n\t\t\t\tareaCount++;\n\t\t\t\treturn addArea(acc, { ...mark, ...specOptions, index: areaCount });\n\t\t\tcase 'bar':\n\t\t\t\tbarCount++;\n\t\t\t\treturn addBar(acc, { ...mark, ...specOptions, index: barCount });\n\t\t\tcase 'bullet':\n\t\t\t\tbulletCount++;\n\t\t\t\treturn addBullet(acc, { ...mark, ...specOptions, index: bulletCount });\n\t\t\tcase 'combo':\n\t\t\t\tcomboCount++;\n\t\t\t\treturn addCombo(acc, { ...mark, ...specOptions, index: comboCount });\n\t\t\tcase 'donut':\n\t\t\t\tdonutCount++;\n\t\t\t\treturn addDonut(acc, { ...mark, ...specOptions, index: donutCount });\n\t\t\tcase 'line':\n\t\t\t\tlineCount++;\n\t\t\t\treturn addLine(acc, { ...mark, ...specOptions, index: lineCount });\n\t\t\tcase 'scatter':\n\t\t\t\tscatterCount++;\n\t\t\t\treturn addScatter(acc, { ...mark, ...specOptions, index: scatterCount });\n\t\t\tcase 'bigNumber':\n\t\t\t\t// Do nothing and do not throw an error\n\t\t\t\treturn acc;\n\t\t\tdefault:\n\t\t\t\tconsole.error(`Invalid component type: ${mark} is not a supported chart mark option child`);\n\t\t\t\treturn acc;\n\t\t}\n\t}, spec);\n\n\tspec = [...legends].reduce((acc: Spec, legend, index) => {\n\t\treturn addLegend(acc, {\n\t\t\t...legend,\n\t\t\t...specOptions,\n\t\t\tindex,\n\t\t\thiddenSeries,\n\t\t\thighlightedSeries,\n\t\t});\n\t}, spec);\n\n\tspec = [...axes].reduce((acc: Spec, axis, index) => {\n\t\treturn addAxis(acc, {\n\t\t\t...axis,\n\t\t\t...specOptions,\n\t\t\tindex,\n\t\t});\n\t}, spec);\n\n\tif (titles.length) {\n\t\tspec = addTitle(spec, titles[0]);\n\t}\n\n\t// copy the spec so we don't mutate the original\n\tspec = JSON.parse(JSON.stringify(spec));\n\tspec.data = addData(spec.data ?? [], { facets: getFacetsFromScales(spec.scales) });\n\n\t// add signals and update marks for controlled highlighting if there isn't a legend with highlight enabled\n\tif (highlightedSeries) {\n\t\tsetHoverOpacityForMarks(spec.marks ?? []);\n\t}\n\n\t// clear out all scales that don't have any fields on the domain\n\tspec = removeUnusedScales(spec);\n\n\treturn spec;\n}\n\nexport const removeUnusedScales = produce<Spec>((spec) => {\n\tspec.scales = spec.scales?.filter((scale) => {\n\t\treturn !('domain' in scale && scale.domain && 'fields' in scale.domain && scale.domain.fields.length === 0);\n\t});\n});\n\nconst initializeComponentCounts = () => {\n\treturn {\n\t\tareaCount: -1,\n\t\tbarCount: -1,\n\t\tcomboCount: -1,\n\t\tdonutCount: -1,\n\t\tbulletCount: -1,\n\t\tlineCount: -1,\n\t\tscatterCount: -1,\n\t};\n};\n\nexport const getDefaultSignals = ({\n\tbackgroundColor,\n\tcolors,\n\tcolorScheme,\n\tlineTypes,\n\topacities,\n\thiddenSeries,\n\thighlightedItem,\n\thighlightedSeries,\n}: ChartSpecOptions): Signal[] => {\n\t// if the background color is transparent, then we want to set the signal background color to gray-50\n\t// if the signal background color were transparent then backgroundMarks and annotation fill would also be transparent\n\tconst signalBackgroundColor = backgroundColor === 'transparent' ? 'gray-50' : backgroundColor;\n\treturn [\n\t\tgetGenericValueSignal(BACKGROUND_COLOR, getColorValue(signalBackgroundColor, colorScheme)),\n\t\tgetGenericValueSignal('colors', getTwoDimensionalColorScheme(colors, colorScheme)),\n\t\tgetGenericValueSignal('lineTypes', getTwoDimensionalLineTypes(lineTypes)),\n\t\tgetGenericValueSignal('opacities', getTwoDimensionalOpacities(opacities)),\n\t\tgetGenericValueSignal('hiddenSeries', hiddenSeries ?? []),\n\t\tgetGenericValueSignal(HIGHLIGHTED_ITEM, highlightedItem),\n\t\tgetGenericValueSignal(HIGHLIGHTED_GROUP),\n\t\tgetGenericValueSignal(HIGHLIGHTED_SERIES, highlightedSeries),\n\t\tgetGenericValueSignal(SELECTED_ITEM),\n\t\tgetGenericValueSignal(SELECTED_SERIES),\n\t\tgetGenericValueSignal(SELECTED_GROUP),\n\t];\n};\n\nexport const getTwoDimensionalColorScheme = (colors: ChartColors, colorScheme: ColorScheme): string[][] => {\n\tif (isColors(colors)) {\n\t\treturn getColors(colors, colorScheme).map((color) => [color]);\n\t}\n\treturn colors.map((color) => getColors(color, colorScheme));\n};\n\nexport const getTwoDimensionalLineTypes = (lineTypes: LineTypes): number[][][] => {\n\t// 1D array of line types\n\tif (isLineTypeArray(lineTypes)) {\n\t\treturn getStrokeDashesFromLineTypes(lineTypes).map((strokeDash) => [strokeDash]);\n\t}\n\t// 2D array of line types\n\treturn lineTypes.map((lineTypeArray) => getStrokeDashesFromLineTypes(lineTypeArray));\n};\n\nexport const getTwoDimensionalOpacities = (opacities: Opacities | undefined): number[][] => {\n\tif (!opacities) return [[1]];\n\t// 1D array of line types\n\tif (isNumberArray(opacities)) {\n\t\treturn opacities.map((opacity) => [opacity]);\n\t}\n\t// 2D array of line types\n\treturn opacities;\n};\n\nconst getDefaultScales = (\n\tcolors: ChartColors,\n\tcolorScheme: ColorScheme,\n\tlineTypes: LineTypes,\n\tlineWidths: LineWidth[],\n\topacities: Opacities | undefined,\n\tsymbolShapes: SymbolShapes,\n\tsymbolSizes: [SymbolSize, SymbolSize]\n): Scale[] => [\n\tgetColorScale(colors, colorScheme),\n\tgetLinearColorScale(colors, colorScheme),\n\tgetLineTypeScale(lineTypes),\n\tgetLineWidthScale(lineWidths),\n\tgetOpacityScale(opacities),\n\tgetSymbolShapeScale(symbolShapes),\n\tgetSymbolSizeScale(symbolSizes),\n\tgetSymbolPathWidthScale(symbolSizes),\n];\n\nexport const getColorScale = (colors: ChartColors, colorScheme: ColorScheme): OrdinalScale => {\n\t// if a two dimensional scale was provided, then just grab the first color in each scale and set that as the scale range\n\tconst range = isColors(colors) ? getColors(colors, colorScheme) : colors.map((c) => getColors(c, colorScheme)[0]);\n\treturn getOrdinalScale('color', range);\n};\n\nexport const getLinearColorScale = (colors: ChartColors, colorScheme: ColorScheme): LinearScale => {\n\t// if a two dimensional scale was provided, then just grab the first color in each scale and set that as the scale range\n\tconst range = isColors(colors) ? getColors(colors, colorScheme) : colors.map((c) => getColors(c, colorScheme)[0]);\n\treturn {\n\t\tname: LINEAR_COLOR_SCALE,\n\t\ttype: 'linear',\n\t\trange,\n\t\tdomain: { data: TABLE, fields: [] },\n\t};\n};\n\nexport const getLineTypeScale = (lineTypes: LineTypes): OrdinalScale => {\n\t// if a two dimensional scale was provided, then just grab the first color in each scale and set that as the scale range\n\tconst range = isLineTypeArray(lineTypes)\n\t\t? getStrokeDashesFromLineTypes(lineTypes)\n\t\t: lineTypes.map((lineTypesArray) => getStrokeDashFromLineType(lineTypesArray[0]));\n\treturn getOrdinalScale(LINE_TYPE_SCALE, range);\n};\n\nexport const getSymbolShapeScale = (symbolShapes: SymbolShapes): OrdinalScale => {\n\t// if a two dimensional scale was provided, then just grab the first color in each scale and set that as the scale range\n\tconst range = isSymbolShapeArray(symbolShapes)\n\t\t? getPathsFromSymbolShapes(symbolShapes)\n\t\t: symbolShapes.map((symbolShape) => getPathFromSymbolShape(symbolShape[0]));\n\treturn getOrdinalScale(SYMBOL_SHAPE_SCALE, range);\n};\n\n/**\n * returns the symbol size scale\n * @param symbolSizes\n * @returns LinearScale\n */\nexport const getSymbolSizeScale = (symbolSizes: [SymbolSize, SymbolSize]): LinearScale => ({\n\tname: SYMBOL_SIZE_SCALE,\n\ttype: 'linear',\n\tzero: false,\n\trange: symbolSizes.map((symbolSize) => getVegaSymbolSizeFromRscSymbolSize(symbolSize)),\n\tdomain: { data: TABLE, fields: [] },\n});\n\n/**\n * returns the path width scale\n * @param symbolSizes\n * @returns LinearScale\n */\nexport const getSymbolPathWidthScale = (symbolSizes: [SymbolSize, SymbolSize]): LinearScale => ({\n\tname: SYMBOL_PATH_WIDTH_SCALE,\n\ttype: 'linear',\n\tzero: false,\n\trange: symbolSizes.map((symbolSize) => getSymbolWidthFromRscSymbolSize(symbolSize)),\n\tdomain: { data: TABLE, fields: [] },\n});\n\nexport const getLineWidthScale = (lineWidths: LineWidth[]): OrdinalScale => {\n\tconst range = lineWidths.map((lineWidth) => getLineWidthPixelsFromLineWidth(lineWidth));\n\treturn getOrdinalScale(LINE_WIDTH_SCALE, range);\n};\n\nexport const getOpacityScale = (opacities?: Opacities): OrdinalScale | PointScale => {\n\tif (opacities?.length) {\n\t\tconst range = isNumberArray(opacities) ? opacities : opacities.map((opacityArray) => opacityArray[0]);\n\t\treturn getOrdinalScale(OPACITY_SCALE, range);\n\t}\n\treturn {\n\t\tname: OPACITY_SCALE,\n\t\ttype: 'point',\n\t\trange: [1, 0],\n\t\tpadding: 1,\n\t\talign: 1,\n\t\tdomain: { data: TABLE, fields: [] },\n\t};\n};\n\nfunction getColors(colors: Colors, colorScheme: ColorScheme): string[] {\n\tif (Array.isArray(colors)) {\n\t\treturn colors.map((color: string) => getColorValue(color, colorScheme));\n\t}\n\treturn colorSchemes[colors];\n}\n\nfunction getStrokeDashesFromLineTypes(lineTypes: LineType[]): number[][] {\n\treturn lineTypes.map((lineType) => getStrokeDashFromLineType(lineType));\n}\n\nfunction getPathsFromSymbolShapes(symbolShapes: ChartSymbolShape[]) {\n\treturn symbolShapes.map((symbolShape) => getPathFromSymbolShape(symbolShape));\n}\n\n/**\n * Adds a formula transform to the TABLE data that combines all the facets into a single key\n */\nexport const addData = produce<Data[], [{ facets: string[] }]>((data, { facets }) => {\n\tif (facets.length === 0) return;\n\tdata[0]?.transform?.push(...getSeriesIdTransform(facets));\n\n\t// add a filter transform to the TABLE data that filters out any hidden series\n\tconst index = data.findIndex((datum) => datum.name === FILTERED_TABLE);\n\tif (index !== -1) {\n\t\tdata[index].transform = [\n\t\t\t{ type: 'filter', expr: `indexof(hiddenSeries, datum.${SERIES_ID}) === -1` },\n\t\t\t...(data[index].transform ?? []),\n\t\t];\n\t}\n});\n\nexport const isColorScale = (colors: ChartColors): colors is ColorScale => {\n\treturn Boolean(!Array.isArray(colors) && colors in colorSchemes);\n};\n\nexport const isColors = (colors: ChartColors): colors is Colors => {\n\treturn isColorScale(colors) || colors.some((color) => !isColorScale(color) && typeof color === 'string');\n};\n\nexport const isLineTypeArray = (lineTypes: LineTypes): lineTypes is LineType[] => {\n\treturn lineTypes.some((lineType) => typeof lineType === 'string' || isStrokeDashArray(lineType));\n};\n\nexport const isStrokeDashArray = (lineType: LineType | LineType[]): lineType is number[] => {\n\treturn Array.isArray(lineType) && !lineType.some((value) => typeof value !== 'number');\n};\n\nexport const isNumberArray = (opacities: Opacities): opacities is number[] => {\n\treturn !opacities.some((opacity) => Array.isArray(opacity));\n};\n\nexport const isSymbolShapeArray = (symbolShapes: SymbolShapes): symbolShapes is ChartSymbolShape[] => {\n\treturn !symbolShapes.some((symbolShape) => Array.isArray(symbolShape));\n};\n","/*\n * Copyright 2024 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport { Data, FormulaTransform, NumericValueRef, Signal, SourceData } from 'vega';\n\nimport {\n\tDEFAULT_OPACITY_RULE,\n\tFILTERED_TABLE,\n\tHIGHLIGHTED_GROUP,\n\tHIGHLIGHTED_ITEM,\n\tHIGHLIGHT_CONTRAST_RATIO,\n\tINTERACTION_MODE,\n\tSERIES_ID,\n} from '@spectrum-charts/constants';\n\nimport { getFilteredTableData } from '../data/dataUtils';\nimport { getHoverMarkNames } from '../marks/markUtils';\nimport {\n\tAreaSpecOptions,\n\tBarSpecOptions,\n\tChartTooltipOptions,\n\tChartTooltipSpecOptions,\n\tDonutSpecOptions,\n\tLineSpecOptions,\n\tScatterSpecOptions,\n} from '../types';\n\ntype TooltipParentOptions = AreaSpecOptions | BarSpecOptions | DonutSpecOptions | LineSpecOptions | ScatterSpecOptions;\n\n/**\n * gets all the tooltips\n * @param markOptions\n * @returns\n */\nexport const getTooltips = (markOptions: TooltipParentOptions): ChartTooltipSpecOptions[] => {\n\treturn markOptions.chartTooltips.map((chartTooltip) => applyTooltipPropDefaults(chartTooltip, markOptions.name));\n};\n\n/**\n * Applies all defaults to ChartTooltipOptions\n * @param chartTooltipOptions\n * @returns ChartTooltipSpecOptions\n */\nexport const applyTooltipPropDefaults = (\n\t{ highlightBy = 'item', ...options }: ChartTooltipOptions,\n\tmarkName: string\n): ChartTooltipSpecOptions => {\n\treturn {\n\t\thighlightBy,\n\t\tmarkName,\n\t\t...options,\n\t};\n};\n\n/**\n * Sets all the data needed for tooltips\n *\n * NOTE: this function mutates the data object so it should only be called from a produce function\n * @param data\n * @param chartTooltipOptions\n */\nexport const addTooltipData = (data: Data[], markOptions: TooltipParentOptions, addHighlightedData = true) => {\n\tconst tooltips = getTooltips(markOptions);\n\tfor (const { highlightBy, markName } of tooltips) {\n\t\tif (highlightBy === 'item') return;\n\t\tconst filteredTable = getFilteredTableData(data);\n\t\tif (!filteredTable.transform) {\n\t\t\tfilteredTable.transform = [];\n\t\t}\n\t\tif (highlightBy === 'dimension' && markOptions.markType !== 'donut') {\n\t\t\tfilteredTable.transform.push(getGroupIdTransform([markOptions.dimension], markName));\n\t\t} else if (highlightBy === 'series') {\n\t\t\tfilteredTable.transform.push(getGroupIdTransform([SERIES_ID], markName));\n\t\t} else if (Array.isArray(highlightBy)) {\n\t\t\tfilteredTable.transform.push(getGroupIdTransform(highlightBy, markName));\n\t\t}\n\n\t\tif (addHighlightedData) {\n\t\t\tdata.push(getMarkHighlightedData(markName));\n\t\t}\n\t}\n};\n\n/**\n * Gets the group id transform\n * @param highlightBy\n * @param markName\n * @returns FormulaTransform\n */\nexport const getGroupIdTransform = (highlightBy: string[], markName: string): FormulaTransform => {\n\treturn {\n\t\ttype: 'formula',\n\t\tas: `${markName}_highlightGroupId`,\n\t\texpr: highlightBy.map((facet) => `datum.${facet}`).join(' + \" | \" + '),\n\t};\n};\n\n/**\n * Gets the highlighted data for a mark\n * @param markName\n * @returns\n */\nconst getMarkHighlightedData = (markName: string): SourceData => ({\n\tname: `${markName}_highlightedData`,\n\tsource: FILTERED_TABLE,\n\ttransform: [\n\t\t{\n\t\t\ttype: 'filter',\n\t\t\texpr: `${HIGHLIGHTED_GROUP} === datum.${markName}_highlightGroupId`,\n\t\t},\n\t],\n});\n\nexport const isHighlightedByGroup = (markOptions: TooltipParentOptions) => {\n\tconst tooltips = getTooltips(markOptions);\n\treturn tooltips.some(({ highlightBy }) => highlightBy && highlightBy !== 'item');\n};\n\n/**\n * Tooltip highlights by item or dimension\n * @param markOptions\n * @returns\n */\nexport const isHighlightedByDimension = (markOptions: TooltipParentOptions) => {\n\tconst tooltips = getTooltips(markOptions);\n\treturn tooltips.some(\n\t\t({ highlightBy }) => typeof highlightBy === 'string' && ['dimension', 'item'].includes(highlightBy)\n\t);\n};\n\n/**\n * adds the appropriate signals for tooltips\n *\n * NOTE: this function mutates the signals array so it should only be called from a produce function\n * @param signals\n * @param markOptions\n */\nexport const addTooltipSignals = (signals: Signal[], markOptions: TooltipParentOptions) => {\n\tif (isHighlightedByGroup(markOptions)) {\n\t\tconst highlightedGroupSignal = signals.find((signal) => signal.name === HIGHLIGHTED_GROUP) as Signal;\n\n\t\tlet markName = markOptions.name;\n\t\tlet update = `datum.${markName}_highlightGroupId`;\n\n\t\tif ('interactionMode' in markOptions && markOptions.interactionMode === INTERACTION_MODE.ITEM) {\n\t\t\tgetHoverMarkNames(markName).forEach((name) => {\n\t\t\t\taddMouseEvents(highlightedGroupSignal, name, update);\n\t\t\t});\n\t\t}\n\n\t\tif (['scatter', 'line'].includes(markOptions.markType)) {\n\t\t\tupdate = `datum.${update}`;\n\t\t\tmarkName += '_voronoi';\n\t\t}\n\n\t\taddMouseEvents(highlightedGroupSignal, markName, update);\n\t}\n};\n\nconst addMouseEvents = (highlightedGroupSignal: Signal, markName: string, update: string) => {\n\tif (highlightedGroupSignal.on === undefined) {\n\t\thighlightedGroupSignal.on = [];\n\t}\n\thighlightedGroupSignal.on.push(\n\t\t...[\n\t\t\t{\n\t\t\t\tevents: `@${markName}:mouseover`,\n\t\t\t\tupdate,\n\t\t\t},\n\t\t\t{ events: `@${markName}:mouseout`, update: 'null' },\n\t\t]\n\t);\n};\n\n/**\n * Adds the appropriate opacity rules to the beginning of the opacityRules array\n *\n * NOTE: this function mutates the opacityRules array so it should only be called from a produce function\n * @param opacityRules\n * @param markOptions\n */\nexport const addHighlightMarkOpacityRules = (\n\topacityRules: ({ test?: string } & NumericValueRef)[],\n\tmarkOptions: TooltipParentOptions\n) => {\n\topacityRules.unshift(\n\t\t{\n\t\t\ttest: `isArray(${HIGHLIGHTED_ITEM}) && length(${HIGHLIGHTED_ITEM}) > 0 && indexof(${HIGHLIGHTED_ITEM}, datum.${markOptions.idKey}) === -1`,\n\t\t\tvalue: 1 / HIGHLIGHT_CONTRAST_RATIO,\n\t\t},\n\t\t{\n\t\t\ttest: `!isArray(${HIGHLIGHTED_ITEM}) && isValid(${HIGHLIGHTED_ITEM}) && ${HIGHLIGHTED_ITEM} !== datum.${markOptions.idKey}`,\n\t\t\tvalue: 1 / HIGHLIGHT_CONTRAST_RATIO,\n\t\t}\n\t);\n\tif (isHighlightedByGroup(markOptions)) {\n\t\tconst { name: markName } = markOptions;\n\t\topacityRules.unshift({\n\t\t\ttest: `${HIGHLIGHTED_GROUP} === datum.${markName}_highlightGroupId`,\n\t\t\t...DEFAULT_OPACITY_RULE,\n\t\t});\n\t}\n};\n","/*\n * Copyright 2024 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport { produce } from 'immer';\nimport { Spec } from 'vega';\n\nimport { DEFAULT_COLOR_SCHEME, DEFAULT_TIME_DIMENSION } from '@spectrum-charts/constants';\nimport { combineNames, toCamelCase } from '@spectrum-charts/utils';\n\nimport { addBar } from '../bar/barSpecBuilder';\nimport { addLine } from '../line/lineSpecBuilder';\nimport { BarOptions, ColorScheme, ComboOptions, HighlightedItem, LineOptions } from '../types';\n\nexport const addCombo = produce<\n\tSpec,\n\t[ComboOptions & { colorScheme?: ColorScheme; highlightedItem?: HighlightedItem; index?: number; idKey: string }]\n>(\n\t(\n\t\tspec,\n\t\t{\n\t\t\tcolorScheme = DEFAULT_COLOR_SCHEME,\n\t\t\thighlightedItem,\n\t\t\tidKey,\n\t\t\tindex = 0,\n\t\t\tname,\n\t\t\tmarks = [],\n\t\t\tdimension = DEFAULT_TIME_DIMENSION,\n\t\t}\n\t) => {\n\t\tlet { barCount, lineCount } = initializeComponentCounts();\n\t\tconst comboName = toCamelCase(name || `combo${index}`);\n\n\t\tspec = [...marks].reduce((acc: Spec, mark) => {\n\t\t\tswitch (mark.markType) {\n\t\t\t\tcase 'bar':\n\t\t\t\t\tbarCount++;\n\t\t\t\t\treturn addBar(acc, {\n\t\t\t\t\t\t...mark,\n\t\t\t\t\t\tcolorScheme,\n\t\t\t\t\t\thighlightedItem,\n\t\t\t\t\t\tidKey,\n\t\t\t\t\t\tindex: barCount,\n\t\t\t\t\t\tname: getComboMarkName(mark, comboName, barCount),\n\t\t\t\t\t\tdimension: getDimension(mark, dimension),\n\t\t\t\t\t});\n\t\t\t\tcase 'line':\n\t\t\t\tdefault:\n\t\t\t\t\tlineCount++;\n\t\t\t\t\treturn addLine(acc, {\n\t\t\t\t\t\t...mark,\n\t\t\t\t\t\tcolorScheme,\n\t\t\t\t\t\thighlightedItem,\n\t\t\t\t\t\tidKey,\n\t\t\t\t\t\tindex: lineCount,\n\t\t\t\t\t\tname: getComboMarkName(mark, comboName, lineCount),\n\t\t\t\t\t\tdimension: getDimension(mark, dimension),\n\t\t\t\t\t});\n\t\t\t}\n\t\t}, spec);\n\n\t\treturn spec;\n\t}\n);\n\nconst initializeComponentCounts = () => {\n\treturn { barCount: -1, lineCount: -1 };\n};\n\nexport const getComboMarkName = (mark: BarOptions | LineOptions, comboName: string, index: number) => {\n\tif (mark.name) {\n\t\treturn mark.name;\n\t}\n\tconst displayName = getDisplayName(mark.markType);\n\treturn combineNames(comboName, `${displayName}${index}`);\n};\n\nconst getDisplayName = (markType: string): string => {\n\tif (!markType) return '';\n\treturn markType.charAt(0).toUpperCase() + markType.slice(1);\n};\n\nconst getDimension = (mark: BarOptions | LineOptions, dimension?: string) => mark.dimension ?? dimension;\n","/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport { produce } from 'immer';\nimport { Compare, Data, FormulaTransform, SourceData, Transforms, ValuesData } from 'vega';\n\nimport {\n\tDEFAULT_TIME_DIMENSION,\n\tDEFAULT_TRANSFORMED_TIME_DIMENSION,\n\tFILTERED_TABLE,\n\tSERIES_ID,\n\tTABLE,\n} from '@spectrum-charts/constants';\n\nimport { ChartTooltipOptions } from '../types';\n\nexport const addTimeTransform = produce<Transforms[], [string]>((transforms, dimension) => {\n\tif (transforms.findIndex((transform) => transform.type === 'timeunit') === -1) {\n\t\ttransforms.push({\n\t\t\ttype: 'formula',\n\t\t\texpr: `toDate(datum[\"${dimension}\"])`,\n\t\t\tas: dimension,\n\t\t});\n\t\ttransforms.push({\n\t\t\ttype: 'timeunit',\n\t\t\tfield: dimension,\n\t\t\tunits: ['year', 'month', 'date', 'hours', 'minutes'],\n\t\t\tas: [DEFAULT_TRANSFORMED_TIME_DIMENSION, `${DEFAULT_TIME_DIMENSION}1`],\n\t\t});\n\t}\n});\n\nexport const getTransformSort = (order?: string): Compare | undefined => {\n\tif (order) {\n\t\treturn { field: order };\n\t}\n};\n\n/**\n * gets the table data from the data array\n * @param data\n * @returns\n */\nexport const getTableData = (data: Data[]): ValuesData => {\n\t// ok to cast this here because we know that the data array will always have table data of type ValuesData\n\treturn data.find((d) => d.name === TABLE) as ValuesData;\n};\n/**\n * gets the filtered table data from the data array\n * @param data\n * @returns\n */\nexport const getFilteredTableData = (data: Data[]): SourceData => {\n\t// ok to cast this here because we know that the data array will always have table data of type SourceData\n\treturn data.find((d) => d.name === FILTERED_TABLE) as SourceData;\n};\n\nexport const getSeriesIdTransform = (facets: string[]): FormulaTransform[] => {\n\tif (facets.length === 0) return [];\n\tconst expr = facets.map((facet) => `datum.${facet}`).join(' + \" | \" + ');\n\treturn [\n\t\t{\n\t\t\ttype: 'formula',\n\t\t\tas: SERIES_ID,\n\t\t\texpr,\n\t\t},\n\t];\n};\n\n/**\n * @param children\n * @returns spec data that filters out items where the `excludeDataKey` is true\n */\nexport const getFilteredTooltipData = (chartTooltips: ChartTooltipOptions[]) => {\n\tconst excludeDataKeys = chartTooltips[0]?.excludeDataKeys;\n\tconst transform: { type: 'filter'; expr: string }[] | undefined = excludeDataKeys?.map((excludeDataKey) => ({\n\t\ttype: 'filter',\n\t\texpr: `!datum.${excludeDataKey}`,\n\t}));\n\n\treturn {\n\t\tname: `${FILTERED_TABLE}ForTooltip`,\n\t\tsource: FILTERED_TABLE,\n\t\ttransform,\n\t};\n};\n","/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport { produce } from 'immer';\nimport { Data, FormulaTransform, Mark, PieTransform, Scale, Signal, Spec } from 'vega';\n\nimport {\n\tCOLOR_SCALE,\n\tDEFAULT_COLOR,\n\tDEFAULT_COLOR_SCHEME,\n\tDEFAULT_METRIC,\n\tFILTERED_TABLE,\n} from '@spectrum-charts/constants';\nimport { toCamelCase } from '@spectrum-charts/utils';\n\nimport { isInteractive } from '../marks/markUtils';\nimport { addFieldToFacetScaleDomain } from '../scale/scaleSpecBuilder';\nimport { addHighlightedItemSignalEvents } from '../signal/signalSpecBuilder';\nimport { ColorScheme, DonutOptions, DonutSpecOptions, HighlightedItem } from '../types';\nimport {\n\tgetDonutSummaryData,\n\tgetDonutSummaryMarks,\n\tgetDonutSummaryScales,\n\tgetDonutSummarySignals,\n} from './donutSummaryUtils';\nimport { getArcMark } from './donutUtils';\nimport { getSegmentLabelMarks } from './segmentLabelUtils';\n\nexport const addDonut = produce<\n\tSpec,\n\t[DonutOptions & { colorScheme?: ColorScheme; highlightedItem?: HighlightedItem; index?: number; idKey: string }]\n>(\n\t(\n\t\tspec,\n\t\t{\n\t\t\tchartPopovers = [],\n\t\t\tchartTooltips = [],\n\t\t\tcolor = DEFAULT_COLOR,\n\t\t\tcolorScheme = DEFAULT_COLOR_SCHEME,\n\t\t\tdonutSummaries = [],\n\t\t\tindex = 0,\n\t\t\tmetric = DEFAULT_METRIC,\n\t\t\tname,\n\t\t\tstartAngle = 0,\n\t\t\tholeRatio = 0.85,\n\t\t\tisBoolean = false,\n\t\t\tsegmentLabels = [],\n\t\t\t...options\n\t\t}\n\t) => {\n\t\t// put options back together now that all defaults are set\n\t\tconst donutOptions: DonutSpecOptions = {\n\t\t\tchartPopovers,\n\t\t\tchartTooltips,\n\t\t\tcolor,\n\t\t\tcolorScheme,\n\t\t\tdonutSummaries,\n\t\t\tholeRatio,\n\t\t\tindex,\n\t\t\tisBoolean,\n\t\t\tmetric,\n\t\t\tname: toCamelCase(name ?? `donut${index}`),\n\t\t\tsegmentLabels,\n\t\t\tstartAngle,\n\t\t\t...options,\n\t\t};\n\n\t\tspec.data = addData(spec.data ?? [], donutOptions);\n\t\tspec.scales = addScales(spec.scales ?? [], donutOptions);\n\t\tspec.marks = addMarks(spec.marks ?? [], donutOptions);\n\t\tspec.signals = addSignals(spec.signals ?? [], donutOptions);\n\t}\n);\n\nexport const addData = produce<Data[], [DonutSpecOptions]>((data, options) => {\n\tconst { name, isBoolean } = options;\n\tconst filteredTableIndex = data.findIndex((d) => d.name === FILTERED_TABLE);\n\n\t//set up transform\n\tdata[filteredTableIndex].transform = data[filteredTableIndex].transform ?? [];\n\tdata[filteredTableIndex].transform?.push(...getPieTransforms(options));\n\n\tif (isBoolean) {\n\t\t//select first data point for our boolean value\n\t\tdata.push({\n\t\t\tname: `${name}_booleanData`,\n\t\t\tsource: FILTERED_TABLE,\n\t\t\ttransform: [\n\t\t\t\t{\n\t\t\t\t\ttype: 'window',\n\t\t\t\t\tops: ['row_number'],\n\t\t\t\t\tas: [`${name}_rscRowIndex`],\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\ttype: 'filter',\n\t\t\t\t\texpr: `datum.${name}_rscRowIndex === 1`, // Keep only the first row\n\t\t\t\t},\n\t\t\t],\n\t\t});\n\t}\n\tdata.push(...getDonutSummaryData(options));\n});\n\nconst getPieTransforms = ({ startAngle, metric, name }: DonutSpecOptions): (FormulaTransform | PieTransform)[] => [\n\t{\n\t\ttype: 'pie',\n\t\tfield: metric,\n\t\tstartAngle,\n\t\tendAngle: { signal: `${startAngle} + 2 * PI` },\n\t\tas: [`${name}_startAngle`, `${name}_endAngle`],\n\t},\n\t{\n\t\ttype: 'formula',\n\t\tas: `${name}_arcTheta`,\n\t\texpr: `(datum['${name}_startAngle'] + datum['${name}_endAngle']) / 2`,\n\t},\n\t{\n\t\ttype: 'formula',\n\t\tas: `${name}_arcLength`,\n\t\texpr: `datum['${name}_endAngle'] - datum['${name}_startAngle']`,\n\t},\n\t{\n\t\ttype: 'formula',\n\t\tas: `${name}_arcPercent`,\n\t\texpr: `datum['${name}_arcLength'] / (2 * PI)`,\n\t},\n];\n\nexport const addScales = produce<Scale[], [DonutSpecOptions]>((scales, options) => {\n\tconst { color } = options;\n\taddFieldToFacetScaleDomain(scales, COLOR_SCALE, color);\n\tscales.push(...getDonutSummaryScales(options));\n});\n\nexport const addMarks = produce<Mark[], [DonutSpecOptions]>((marks, options) => {\n\tmarks.push(getArcMark(options));\n\tmarks.push(...getDonutSummaryMarks(options));\n\tmarks.push(...getSegmentLabelMarks(options));\n});\n\nexport const addSignals = produce<Signal[], [DonutSpecOptions]>((signals, options) => {\n\tconst { chartTooltips, idKey, name } = options;\n\tsignals.push(...getDonutSummarySignals(options));\n\tif (!isInteractive(options)) return;\n\taddHighlightedItemSignalEvents(signals, name, idKey, 1, chartTooltips[0]?.excludeDataKeys);\n});\n","/*\n * Copyright 2024 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport {\n\tEncodeEntryName,\n\tGroupMark,\n\tMark,\n\tNumericValueRef,\n\tProductionRule,\n\tSignal,\n\tSourceData,\n\tTextBaselineValueRef,\n\tTextEncodeEntry,\n\tTextValueRef,\n\tThresholdScale,\n} from 'vega';\n\nimport {\n\tDONUT_RADIUS,\n\tDONUT_SUMMARY_FONT_SIZE_RATIO,\n\tDONUT_SUMMARY_MIN_RADIUS,\n\tFILTERED_TABLE,\n} from '@spectrum-charts/constants';\n\nimport { getTextNumberFormat } from '../textUtils';\nimport { DonutSpecOptions, DonutSummaryOptions, DonutSummarySpecOptions } from '../types';\n\n/**\n * Gets the DonutSummary component from the children if one exists\n * @param donutOptions\n * @returns\n */\nconst getDonutSummary = (options: DonutSpecOptions): DonutSummarySpecOptions | undefined => {\n\tif (!options.donutSummaries.length) {\n\t\treturn;\n\t}\n\treturn applyDonutSummaryPropDefaults(options.donutSummaries[0], options);\n};\n\n/**\n * Applies all default options, converting DonutSummaryOptions into DonutSummarySpecOptions\n * @param donutSummaryOptions\n * @param donutOptions\n * @returns\n */\nconst applyDonutSummaryPropDefaults = (\n\t{ numberFormat = 'shortNumber', ...options }: DonutSummaryOptions,\n\tdonutOptions: DonutSpecOptions\n): DonutSummarySpecOptions => ({\n\tdonutOptions,\n\tnumberFormat,\n\t...options,\n});\n\n/**\n * Gets the data for the donut summary\n * @param donutOptions\n * @returns SourceData[]\n */\nexport const getDonutSummaryData = (donutOptions: DonutSpecOptions): SourceData[] => {\n\tconst donutSummary = getDonutSummary(donutOptions);\n\tif (!donutSummary || donutOptions.isBoolean) {\n\t\treturn [];\n\t}\n\treturn [\n\t\t{\n\t\t\tname: `${donutOptions.name}_summaryData`,\n\t\t\tsource: FILTERED_TABLE,\n\t\t\ttransform: [\n\t\t\t\t{\n\t\t\t\t\ttype: 'aggregate',\n\t\t\t\t\tfields: [donutOptions.metric],\n\t\t\t\t\tops: ['sum'],\n\t\t\t\t\tas: ['sum'],\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t];\n};\n\n/**\n * Gets the required scales for the donut summary\n * @param donutOptions\n * @returns ThresholdScale[]\n */\nexport const getDonutSummaryScales = (donutOptions: DonutSpecOptions): ThresholdScale[] => {\n\tconst donutSummary = getDonutSummary(donutOptions);\n\tif (!donutSummary) {\n\t\treturn [];\n\t}\n\treturn [\n\t\t// This scale will snap the fontsize to the spectrum font sizes L - XXXXL\n\t\t// 28 is the min, 60 is the max.\n\t\t{\n\t\t\tname: `${donutOptions.name}_summaryFontSizeScale`,\n\t\t\ttype: 'threshold',\n\t\t\tdomain: [32, 36, 40, 45, 50, 60],\n\t\t\trange: [28, 32, 36, 40, 45, 50, 60],\n\t\t},\n\t];\n};\n\n/**\n * Gets the signals for the donut summary\n * @param donutOptions\n * @returns Signal[]\n */\nexport const getDonutSummarySignals = (donutOptions: DonutSpecOptions): Signal[] => {\n\tconst donutSummary = getDonutSummary(donutOptions);\n\tif (!donutSummary) {\n\t\treturn [];\n\t}\n\tconst { name: donutName, holeRatio } = donutOptions;\n\treturn [\n\t\t{\n\t\t\tname: `${donutName}_summaryFontSize`,\n\t\t\tupdate: `scale('${donutName}_summaryFontSizeScale', ${DONUT_RADIUS} * ${holeRatio} * ${DONUT_SUMMARY_FONT_SIZE_RATIO})`,\n\t\t},\n\t];\n};\n\n/**\n * Gets all the marks for the donut summary\n * @param donutOptions\n * @returns GroupMark[]\n */\nexport const getDonutSummaryMarks = (options: DonutSpecOptions): GroupMark[] => {\n\tconst donutSummary = getDonutSummary(options);\n\tif (!donutSummary) {\n\t\treturn [];\n\t}\n\tconst marks: GroupMark[] = [];\n\tif (options.isBoolean) {\n\t\tmarks.push(getBooleanDonutSummaryGroupMark(donutSummary));\n\t} else {\n\t\tmarks.push(getDonutSummaryGroupMark(donutSummary));\n\t}\n\treturn marks;\n};\n\n/**\n * Gets the group mark for the donut summary\n * @param donutSummaryOptions\n * @returns GorupMark\n */\nexport const getDonutSummaryGroupMark = (options: DonutSummarySpecOptions): GroupMark => {\n\tconst { donutOptions, label } = options;\n\tconst groupMark: Mark = {\n\t\ttype: 'group',\n\t\tname: `${donutOptions.name}_summaryGroup`,\n\t\tmarks: [\n\t\t\t{\n\t\t\t\ttype: 'text',\n\t\t\t\tname: `${donutOptions.name}_summaryValue`,\n\t\t\t\tfrom: { data: `${donutOptions.name}_summaryData` },\n\t\t\t\tencode: getSummaryValueEncode(options),\n\t\t\t},\n\t\t],\n\t};\n\tif (label) {\n\t\tgroupMark.marks?.push({\n\t\t\ttype: 'text',\n\t\t\tname: `${donutOptions.name}_summaryLabel`,\n\t\t\tfrom: { data: `${donutOptions.name}_summaryData` },\n\t\t\tencode: getSummaryLabelEncode({ ...options, label }),\n\t\t});\n\t}\n\treturn groupMark;\n};\n\n/**\n * Gets the group mark for a boolean donut summary\n * @param donutSummaryOptions\n * @returns GroupMark\n */\nexport const getBooleanDonutSummaryGroupMark = (options: DonutSummarySpecOptions): GroupMark => {\n\tconst { donutOptions, label } = options;\n\tconst groupMark: Mark = {\n\t\ttype: 'group',\n\t\tname: `${donutOptions.name}_percentText`,\n\t\tmarks: [\n\t\t\t{\n\t\t\t\ttype: 'text',\n\t\t\t\tname: `${donutOptions.name}_booleanSummaryValue`,\n\t\t\t\tfrom: { data: `${donutOptions.name}_booleanData` },\n\t\t\t\tencode: getSummaryValueEncode(options),\n\t\t\t},\n\t\t],\n\t};\n\tif (label) {\n\t\tgroupMark.marks?.push({\n\t\t\ttype: 'text',\n\t\t\tname: `${donutOptions.name}_booleanSummaryLabel`,\n\t\t\tfrom: { data: `${donutOptions.name}_booleanData` },\n\t\t\tencode: getSummaryLabelEncode({ ...options, label }),\n\t\t});\n\t}\n\treturn groupMark;\n};\n\n/**\n * Gets the encode for the summary value\n * @param donutSummaryOptions\n * @returns encode\n */\nconst getSummaryValueEncode = (options: DonutSummarySpecOptions): Partial<Record<EncodeEntryName, TextEncodeEntry>> => {\n\tconst { donutOptions, label } = options;\n\treturn {\n\t\tupdate: {\n\t\t\tx: { signal: 'width / 2' },\n\t\t\ty: { signal: 'height / 2' },\n\t\t\ttext: getSummaryValueText(options),\n\t\t\tfontSize: [\n\t\t\t\t{ test: `${DONUT_RADIUS} * ${donutOptions.holeRatio} < ${DONUT_SUMMARY_MIN_RADIUS}`, value: 0 },\n\t\t\t\t{ signal: `${donutOptions.name}_summaryFontSize` },\n\t\t\t],\n\t\t\talign: { value: 'center' },\n\t\t\tbaseline: getSummaryValueBaseline(label),\n\t\t\tlimit: getSummaryValueLimit(options),\n\t\t},\n\t};\n};\n\n/**\n * Gets the text value for the summary value\n * @param donutSummaryOptions\n * @returns TextValueref\n */\nexport const getSummaryValueText = ({\n\tdonutOptions,\n\tnumberFormat,\n}: DonutSummarySpecOptions): ProductionRule<TextValueRef> => {\n\tif (donutOptions.isBoolean) {\n\t\treturn { signal: `format(datum['${donutOptions.metric}'], '.0%')` };\n\t}\n\treturn [...getTextNumberFormat(numberFormat, 'sum'), { field: 'sum' }];\n};\n\n/**\n * Gets the baseline for the summary value\n * @param label\n * @returns TextBaselineValueRef\n */\nexport const getSummaryValueBaseline = (label?: string): TextBaselineValueRef => {\n\tif (label) {\n\t\treturn { value: 'alphabetic' };\n\t}\n\t// If there isn't a label, the text should be vertically centered\n\treturn { value: 'middle' };\n};\n\n/**\n * Gets the limit for the summary value\n * @param donutSummaryOptions\n * @returns NumericValueRef\n */\nexport const getSummaryValueLimit = ({ donutOptions, label }: DonutSummarySpecOptions): NumericValueRef => {\n\tconst { holeRatio, name } = donutOptions;\n\t// if there isn't a label, the height of the font from the center of the donut is 1/2 the font size\n\tconst fontHeight = label ? `${name}_summaryFontSize` : `${name}_summaryFontSize * 0.5`;\n\tconst donutInnerRadius = `${DONUT_RADIUS} * ${holeRatio}`;\n\n\treturn {\n\t\t// This is the max length of the text that can be displayed in the donut summary\n\t\t// If the text is longer than this, it will be truncated\n\t\t// It is calculated using the Pythagorean theorem\n\t\tsignal: `2 * sqrt(pow(${donutInnerRadius}, 2) - pow(${fontHeight}, 2))`,\n\t};\n};\n\n/**\n * Gets the encode for the metric label\n * @param donutSummaryOptions\n * @returns encode\n */\nexport const getSummaryLabelEncode = ({\n\tdonutOptions,\n\tlabel,\n}: DonutSummarySpecOptions & { label: string }): Partial<Record<EncodeEntryName, TextEncodeEntry>> => {\n\treturn {\n\t\tupdate: {\n\t\t\tx: { signal: 'width / 2' },\n\t\t\ty: { signal: 'height / 2' },\n\t\t\tdy: { signal: `ceil(${donutOptions.name}_summaryFontSize * 0.25)` },\n\t\t\ttext: { value: label },\n\t\t\tfontSize: [\n\t\t\t\t{ test: `${DONUT_RADIUS} * ${donutOptions.holeRatio} < ${DONUT_SUMMARY_MIN_RADIUS}`, value: 0 },\n\t\t\t\t{ signal: `ceil(${donutOptions.name}_summaryFontSize * 0.5)` },\n\t\t\t],\n\t\t\talign: { value: 'center' },\n\t\t\tbaseline: { value: 'top' },\n\t\t\tlimit: {\n\t\t\t\tsignal: `2 * sqrt(pow(${DONUT_RADIUS} * ${donutOptions.holeRatio}, 2) - pow(${donutOptions.name}_summaryFontSize * 0.75, 2))`,\n\t\t\t},\n\t\t},\n\t};\n};\n","/*\n * Copyright 2024 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport { ArcMark } from 'vega';\n\nimport { DONUT_RADIUS, FILTERED_TABLE, SELECTED_ITEM } from '@spectrum-charts/constants';\nimport { getColorValue } from '@spectrum-charts/themes';\n\nimport { getColorProductionRule, getCursor, getMarkOpacity, getTooltip } from '../marks/markUtils';\nimport { DonutSpecOptions } from '../types';\n\nexport const getArcMark = (options: DonutSpecOptions): ArcMark => {\n\tconst { chartPopovers, chartTooltips, color, colorScheme, holeRatio, idKey, name } = options;\n\treturn {\n\t\ttype: 'arc',\n\t\tname,\n\t\tdescription: name,\n\t\tfrom: { data: FILTERED_TABLE },\n\t\tencode: {\n\t\t\tenter: {\n\t\t\t\tfill: getColorProductionRule(color, colorScheme),\n\t\t\t\tx: { signal: 'width / 2' },\n\t\t\t\ty: { signal: 'height / 2' },\n\t\t\t\ttooltip: getTooltip(chartTooltips, name),\n\t\t\t\tstroke: { value: getColorValue('static-blue', colorScheme) },\n\t\t\t},\n\t\t\tupdate: {\n\t\t\t\tstartAngle: { field: `${name}_startAngle` },\n\t\t\t\tendAngle: { field: `${name}_endAngle` },\n\t\t\t\tpadAngle: { value: 0.01 },\n\t\t\t\tinnerRadius: { signal: `${holeRatio} * ${DONUT_RADIUS}` },\n\t\t\t\touterRadius: { signal: DONUT_RADIUS },\n\t\t\t\topacity: getMarkOpacity(options),\n\t\t\t\tcursor: getCursor(chartPopovers),\n\t\t\t\tstrokeWidth: [{ test: `${SELECTED_ITEM} === datum.${idKey}`, value: 2 }, { value: 0 }],\n\t\t\t},\n\t\t},\n\t};\n};\n","/*\n * Copyright 2024 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport { GroupMark, NumericValueRef, ProductionRule, TextEncodeEntry, TextMark, TextValueRef } from 'vega';\n\nimport { DONUT_RADIUS, DONUT_SEGMENT_LABEL_MIN_ANGLE, FILTERED_TABLE } from '@spectrum-charts/constants';\n\nimport { getTextNumberFormat } from '../textUtils';\nimport { DonutSpecOptions, SegmentLabelOptions, SegmentLabelSpecOptions } from '../types';\n\n/**\n * Gets the SegmentLabel component from the children if one exists\n * @param donutOptions\n * @returns segmentLabelOptions\n */\nconst getSegmentLabel = (options: DonutSpecOptions): SegmentLabelSpecOptions | undefined => {\n\tif (!options.segmentLabels.length) {\n\t\treturn;\n\t}\n\treturn applySegmentLabelPropDefaults(options.segmentLabels[0], options);\n};\n\n/**\n * Applies all default options, converting SegmentLabelOptions into SegmentLabelSpecOptions\n * @param segmentLabelOptions\n * @param donutOptions\n * @returns SegmentLabelSpecOptions\n */\nconst applySegmentLabelPropDefaults = (\n\t{ percent = false, value = false, valueFormat = 'standardNumber', ...options }: SegmentLabelOptions,\n\tdonutOptions: DonutSpecOptions\n): SegmentLabelSpecOptions => ({\n\tdonutOptions,\n\tpercent,\n\tvalue,\n\tvalueFormat,\n\t...options,\n});\n\n/**\n * Gets the marks for the segment label. If there isn't a segment label, an empty array is returned.\n * @param donutOptions\n * @returns GroupMark[]\n */\nexport const getSegmentLabelMarks = (donutOptions: DonutSpecOptions): GroupMark[] => {\n\tconst { isBoolean, name } = donutOptions;\n\t// segment labels are not supported for boolean variants\n\tif (isBoolean) return [];\n\n\tconst segmentLabel = getSegmentLabel(donutOptions);\n\t// if there isn't a segment label, we don't need to do anything\n\tif (!segmentLabel) return [];\n\n\treturn [\n\t\t{\n\t\t\tname: `${name}_segmentLabelGroup`,\n\t\t\ttype: 'group',\n\t\t\tmarks: [getSegmentLabelTextMark(segmentLabel), ...getSegmentLabelValueTextMark(segmentLabel)],\n\t\t},\n\t];\n};\n\n/**\n * Gets the text mark for the segment label\n * @param segmentLabelOptions\n * @returns TextMark\n */\nexport const getSegmentLabelTextMark = ({\n\tlabelKey,\n\tvalue,\n\tpercent,\n\tdonutOptions,\n}: SegmentLabelSpecOptions): TextMark => {\n\tconst { name, color } = donutOptions;\n\treturn {\n\t\ttype: 'text',\n\t\tname: `${name}_segmentLabel`,\n\t\tfrom: { data: FILTERED_TABLE },\n\t\tencode: {\n\t\t\tenter: {\n\t\t\t\t...getBaseSegmentLabelEnterEncode(name),\n\t\t\t\ttext: { field: labelKey ?? color },\n\t\t\t\tfontWeight: { value: 'bold' },\n\t\t\t\tdy:\n\t\t\t\t\tvalue || percent\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tsignal: `datum['${name}_arcTheta'] <= 0.5 * PI || datum['${name}_arcTheta'] >= 1.5 * PI ? -16 : 0`,\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t: undefined,\n\t\t\t},\n\t\t\tupdate: positionEncodings,\n\t\t},\n\t};\n};\n\n/**\n * Gets the text mark for the segment label values (percent and/or value)\n * @param segmentLabelOptions\n * @returns TextMark[]\n */\nexport const getSegmentLabelValueTextMark = (options: SegmentLabelSpecOptions): TextMark[] => {\n\tif (!options.value && !options.percent) return [];\n\tconst { donutOptions } = options;\n\n\treturn [\n\t\t{\n\t\t\ttype: 'text',\n\t\t\tname: `${donutOptions.name}_segmentLabelValue`,\n\t\t\tfrom: { data: FILTERED_TABLE },\n\t\t\tencode: {\n\t\t\t\tenter: {\n\t\t\t\t\t...getBaseSegmentLabelEnterEncode(donutOptions.name),\n\t\t\t\t\ttext: getSegmentLabelValueText(options),\n\t\t\t\t\tdy: {\n\t\t\t\t\t\tsignal: `datum['${donutOptions.name}_arcTheta'] <= 0.5 * PI || datum['${donutOptions.name}_arcTheta'] >= 1.5 * PI ? 0 : 16`,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tupdate: positionEncodings,\n\t\t\t},\n\t\t},\n\t];\n};\n\n/**\n * Gets all the standard entry encodes for segment label text marks\n * @param name\n * @returns TextEncodeEntry\n */\nconst getBaseSegmentLabelEnterEncode = (name: string): TextEncodeEntry => ({\n\tradius: { signal: `${DONUT_RADIUS} + 6` },\n\ttheta: { field: `${name}_arcTheta` },\n\tfontSize: getSegmentLabelFontSize(name),\n\talign: {\n\t\tsignal: `datum['${name}_arcTheta'] <= PI ? 'left' : 'right'`,\n\t},\n\tbaseline: {\n\t\t// if the center of the arc is in the top half of the donut, the text baseline should be bottom, else top\n\t\tsignal: `datum['${name}_arcTheta'] <= 0.5 * PI || datum['${name}_arcTheta'] >= 1.5 * PI ? 'bottom' : 'top'`,\n\t},\n});\n/**\n * position encodings\n */\nconst positionEncodings: TextEncodeEntry = {\n\tx: { signal: 'width / 2' },\n\ty: { signal: 'height / 2' },\n};\n\n/**\n * Gets the text value ref for the segment label values (percent and/or value)\n * @param segmentLabelOptions\n * @returns TextValueRef\n */\nexport const getSegmentLabelValueText = ({\n\tdonutOptions,\n\tpercent,\n\tvalue,\n\tvalueFormat,\n}: SegmentLabelSpecOptions): ProductionRule<TextValueRef> | undefined => {\n\tconst percentSignal = `format(datum['${donutOptions.name}_arcPercent'], '.0%')`;\n\tif (value) {\n\t\t// to support `shortNumber` and `shortCurrency` we need to use the consistent logic\n\t\tconst rules = getTextNumberFormat(valueFormat, donutOptions.metric) as { test?: string; signal: string }[];\n\t\tif (percent) {\n\t\t\t// rules will be an array so we need to add the percent to each signal\n\t\t\treturn rules.map((rule) => ({\n\t\t\t\t...rule,\n\t\t\t\tsignal: `${percentSignal} + \"\\\\u00a0\\\\u00a0\" + ${rule.signal}`,\n\t\t\t}));\n\t\t}\n\t\treturn rules;\n\t}\n\n\tif (percent) {\n\t\treturn { signal: percentSignal };\n\t}\n};\n\n/**\n * Gets the font size for the segment label based on the arc length\n * If the arc length is less than 0.3 radians, the font size is 0\n * @param name\n * @returns NumericValueRef\n */\nconst getSegmentLabelFontSize = (name: string): ProductionRule<NumericValueRef> => {\n\t// need to use radians for this. 0.3 radians is about 17 degrees\n\t// if we used arc length, then showing a label could shrink the overall donut size which could make the arc to small\n\t// that would hide the label which would make the arc bigger which would show the label and so on\n\treturn [{ test: `datum['${name}_arcLength'] < ${DONUT_SEGMENT_LABEL_MIN_ANGLE}`, value: 0 }, { value: 14 }];\n};\n","/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport * from './chartSpecBuilder';\nexport * from './specUtils';\nexport * from './types';\n","/*\n * Copyright 2024 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport { Scale, ScaleMultiFieldsRef } from 'vega';\n\nimport {\n\tCOLOR_SCALE,\n\tLINEAR_COLOR_SCALE,\n\tLINE_TYPE_SCALE,\n\tOPACITY_SCALE,\n\tSYMBOL_SHAPE_SCALE,\n\tSYMBOL_SIZE_SCALE,\n} from '@spectrum-charts/constants';\n\nimport { FacetType, SecondaryFacetType } from '../types';\nimport { Facet } from './legendUtils';\n\n/**\n * These are all the scale names that are used for facets\n */\nconst facetScaleNames: (FacetType | SecondaryFacetType)[] = [\n\tCOLOR_SCALE,\n\tLINE_TYPE_SCALE,\n\tLINEAR_COLOR_SCALE,\n\tOPACITY_SCALE,\n\t'secondaryColor',\n\t'secondaryLineType',\n\t'secondaryOpacity',\n\t'secondarySymbolShape',\n\tSYMBOL_SHAPE_SCALE,\n\tSYMBOL_SIZE_SCALE,\n];\n\n/**\n * Goes through all the scales and finds all the facets that are used\n * A facet is a key in the data that is used to differentiate the data\n * Examples are color based on 'operatingSystem', size based on 'weight', lineType based on 'timePeriod' etc.\n * @param scales\n * @returns Factes\n */\nexport const getFacets = (scales: Scale[]): { ordinalFacets: Facet[]; continuousFacets: Facet[] } => {\n\tconst ordinalFacets: Facet[] = [];\n\tconst continuousFacets: Facet[] = [];\n\n\tscales.forEach((scale) => {\n\t\tif (\n\t\t\tfacetScaleNames.includes(scale.name as FacetType) &&\n\t\t\tisScaleWithMultiFields(scale) &&\n\t\t\tscale.domain.fields.length\n\t\t) {\n\t\t\tif (scale.type === 'ordinal' || scale.type === 'point') {\n\t\t\t\tordinalFacets.push({\n\t\t\t\t\tfacetType: scale.name as FacetType,\n\t\t\t\t\tfield: scale.domain.fields[0].toString(),\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tcontinuousFacets.push({ facetType: scale.name as FacetType, field: scale.domain.fields[0].toString() });\n\t\t\t}\n\t\t}\n\t});\n\treturn { ordinalFacets, continuousFacets };\n};\n\n/**\n * This function goes through all the scales and finds the scales that use the provided keys\n * Example: if the keys are ['segment', 'event'], this function will find all the scales that use either of those fields so that they can be used to generate the legend\n * @param keys\n * @param scales\n * @returns\n */\nexport const getFacetsFromKeys = (\n\tkeys: string[],\n\tscales: Scale[]\n): { ordinalFacets: Facet[]; continuousFacets: Facet[] } => {\n\tconst ordinalFacets: Facet[] = [];\n\tconst continuousFacets: Facet[] = [];\n\tscales.forEach((scale) => {\n\t\tif (isScaleWithMultiFields(scale) && scaleHasKey(scale, keys)) {\n\t\t\tif (scale.type === 'ordinal' || scale.type === 'point') {\n\t\t\t\tordinalFacets.push({\n\t\t\t\t\tfacetType: scale.name as FacetType,\n\t\t\t\t\tfield: scale.domain.fields.find((field) => keys.includes(field.toString()))?.toString() as string,\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tcontinuousFacets.push({\n\t\t\t\t\tfacetType: scale.name as FacetType,\n\t\t\t\t\tfield: scale.domain.fields.find((field) => keys.includes(field.toString()))?.toString() as string,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t});\n\treturn { ordinalFacets, continuousFacets };\n};\n\n/**\n * Checks if the scale has any of the provided keys\n * @param scale\n * @param keys\n * @returns boolean\n */\nconst scaleHasKey = (scale: ScaleWithMultiFields, keys: string[]): boolean =>\n\tscale.domain.fields.some((field) => keys.includes(field.toString()));\n\ntype ScaleWithMultiFields = Scale & { domain: ScaleMultiFieldsRef };\n\n/**\n * Checks that the scale has a domain with a fields array\n * @param scale\n * @returns\n */\nconst isScaleWithMultiFields = (scale: Scale): scale is ScaleWithMultiFields => {\n\treturn Boolean('domain' in scale && scale.domain && 'fields' in scale.domain);\n};\n","/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport { GroupMark, Mark, NumericValueRef } from 'vega';\n\nimport {\n\tCOLOR_SCALE,\n\tHIGHLIGHTED_GROUP,\n\tHIGHLIGHTED_SERIES,\n\tHIGHLIGHT_CONTRAST_RATIO,\n\tSERIES_ID,\n} from '@spectrum-charts/constants';\n\n/**\n * Adds opacity tests for the fill and stroke of marks that use the color scale to set the fill or stroke value.\n */\nexport const setHoverOpacityForMarks = (marks: Mark[], keys?: string[], name?: string) => {\n\tif (!marks.length) return;\n\tconst flatMarks = flattenMarks(marks);\n\tconst seriesMarks = flatMarks.filter(markUsesSeriesColorScale);\n\tseriesMarks.forEach((mark) => {\n\t\t// need to drill down to the prop we need to set and add missing properties if needed\n\t\tif (!mark.encode) {\n\t\t\tmark.encode = { update: {} };\n\t\t}\n\t\tif (!mark.encode.update) {\n\t\t\tmark.encode.update = {};\n\t\t}\n\t\tconst { update } = mark.encode;\n\t\tconst { opacity } = update;\n\n\t\tif (opacity !== undefined) {\n\t\t\t// the new production rule for highlighting\n\t\t\tconst highlightOpacityRule = getHighlightOpacityRule(keys, name);\n\n\t\t\tif (!Array.isArray(update.opacity)) {\n\t\t\t\tupdate.opacity = [];\n\t\t\t}\n\t\t\t// need to insert the new test in the second to last slot\n\t\t\tconst opacityRuleInsertIndex = Math.max(update.opacity.length - 1, 0);\n\t\t\tupdate.opacity.splice(opacityRuleInsertIndex, 0, highlightOpacityRule);\n\t\t}\n\t});\n};\n\nexport const getHighlightOpacityRule = (keys?: string[], name?: string): { test?: string } & NumericValueRef => {\n\tlet test = `isValid(${HIGHLIGHTED_SERIES}) && ${HIGHLIGHTED_SERIES} !== datum.${SERIES_ID}`;\n\tif (keys?.length) {\n\t\ttest = `isValid(${HIGHLIGHTED_GROUP}) && ${HIGHLIGHTED_GROUP} !== datum.${name}_highlightGroupId`;\n\t}\n\treturn { test, value: 1 / HIGHLIGHT_CONTRAST_RATIO };\n};\n\n/**\n * Determines if the supplied mark uses the color scale to set the fill or stroke value.\n * This is used to determine if we need to set the opacity for the mark when it is hovered\n * @param mark\n * @returns boolean\n */\nexport const markUsesSeriesColorScale = (mark: Mark): boolean => {\n\tconst enter = mark.encode?.enter;\n\tif (!enter) return false;\n\tconst { fill, stroke } = enter;\n\tif (fill && 'scale' in fill && fill.scale === COLOR_SCALE) {\n\t\treturn true;\n\t}\n\t// some marks use a 2d color scale, these will use a signal expression to get the color for that series\n\tif (fill && 'signal' in fill && fill.signal.includes(\"scale('colors',\")) {\n\t\treturn true;\n\t}\n\tif (stroke && 'scale' in stroke && stroke.scale === COLOR_SCALE) {\n\t\treturn true;\n\t}\n\treturn false;\n};\n\n/**\n * Recursively flattens all nested marks into a flat array\n * @param marks\n * @returns\n */\nexport const flattenMarks = (marks: Mark[]): Mark[] => {\n\tlet result = marks;\n\tfor (const mark of marks) {\n\t\tif (isGroupMark(mark) && mark.marks) {\n\t\t\tresult = [...result, ...flattenMarks(mark.marks)];\n\t\t}\n\t}\n\treturn result;\n};\n\nconst isGroupMark = (mark: Mark): mark is GroupMark => {\n\treturn mark.type === 'group';\n};\n","/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport { produce } from 'immer';\nimport { Data, Legend, Mark, Scale, Signal, Spec } from 'vega';\n\nimport {\n\tCOLOR_SCALE,\n\tDEFAULT_COLOR_SCHEME,\n\tLINEAR_COLOR_SCALE,\n\tLINE_TYPE_SCALE,\n\tOPACITY_SCALE,\n\tSYMBOL_SHAPE_SCALE,\n\tSYMBOL_SIZE_SCALE,\n} from '@spectrum-charts/constants';\nimport { getColorValue } from '@spectrum-charts/themes';\n\nimport { getTableData } from '../data/dataUtils';\nimport { addFieldToFacetScaleDomain } from '../scale/scaleSpecBuilder';\nimport { addHighlighSignalLegendHoverEvents, getGenericValueSignal } from '../signal/signalSpecBuilder';\nimport { getLineWidthPixelsFromLineWidth, getPathFromSymbolShape, getStrokeDashFromLineType } from '../specUtils';\nimport {\n\tColorFacet,\n\tColorScheme,\n\tFacetRef,\n\tLegendOptions,\n\tLegendSpecOptions,\n\tLineTypeFacet,\n\tLineWidthFacet,\n\tSymbolShapeFacet,\n} from '../types';\nimport { getFacets, getFacetsFromKeys } from './legendFacetUtils';\nimport { setHoverOpacityForMarks } from './legendHighlightUtils';\nimport { Facet, getColumns, getEncodings, getHiddenEntriesFilter, getSymbolType } from './legendUtils';\n\nexport const addLegend = produce<\n\tSpec,\n\t[\n\t\tLegendOptions & {\n\t\t\tcolorScheme?: ColorScheme;\n\t\t\tindex?: number;\n\t\t\thiddenSeries?: string[];\n\t\t\thighlightedSeries?: string | number;\n\t\t}\n\t]\n>(\n\t(\n\t\tspec,\n\t\t{\n\t\t\tcolor,\n\t\t\thasMouseInteraction = false,\n\t\t\thasOnClick = false,\n\t\t\thiddenEntries = [],\n\t\t\thiddenSeries = [],\n\t\t\thighlight = false,\n\t\t\thighlightedSeries,\n\t\t\tindex = 0,\n\t\t\tisToggleable = false,\n\t\t\tlineType,\n\t\t\tlineWidth,\n\t\t\tposition = 'bottom',\n\t\t\tsymbolShape,\n\t\t\ttitle,\n\t\t\tcolorScheme = DEFAULT_COLOR_SCHEME,\n\t\t\t...options\n\t\t}\n\t) => {\n\t\tconst { formattedColor, formattedLineType, formattedLineWidth, formattedSymbolShape } =\n\t\t\tformatFacetRefsWithPresets(color, lineType, lineWidth, symbolShape, colorScheme);\n\n\t\tconst name = `legend${index}`;\n\n\t\t// put options back together now that all defaults are set\n\t\tconst legendOptions: LegendSpecOptions = {\n\t\t\tcolor: formattedColor,\n\t\t\thasMouseInteraction,\n\t\t\thasOnClick,\n\t\t\thiddenEntries,\n\t\t\thiddenSeries,\n\t\t\thighlight,\n\t\t\thighlightedSeries,\n\t\t\tindex,\n\t\t\tisToggleable,\n\t\t\tlineType: formattedLineType,\n\t\t\tlineWidth: formattedLineWidth,\n\t\t\tname,\n\t\t\tposition,\n\t\t\tsymbolShape: formattedSymbolShape,\n\t\t\ttitle,\n\t\t\tcolorScheme,\n\t\t\t...options,\n\t\t};\n\n\t\t// Order matters here. Facets rely on the scales being set up.\n\t\tspec.scales = addScales(spec.scales ?? [], legendOptions);\n\n\t\t// get the keys and facet types that are used to divide the data for this visualization\n\t\tconst { ordinalFacets, continuousFacets } = options.keys\n\t\t\t? getFacetsFromKeys(options.keys, spec.scales ?? [])\n\t\t\t: getFacets(spec.scales ?? []);\n\n\t\tconst legends: Legend[] = [];\n\n\t\t// if there are any categorical facets, add the legend and supporting data, signals and marks\n\t\tif (ordinalFacets.length) {\n\t\t\t// add the legendEntries scale\n\t\t\t// this scale is used to generate every combination of the catergorical facets\n\t\t\tspec.scales.push({\n\t\t\t\tname: `${name}Entries`,\n\t\t\t\ttype: 'ordinal',\n\t\t\t\tdomain: { data: `${name}Aggregate`, field: `${name}Entries` },\n\t\t\t});\n\n\t\t\t// just want the unique fields\n\t\t\tconst uniqueFacetFields = [...new Set(ordinalFacets.map((facet) => facet.field))];\n\n\t\t\tspec.data = addData(spec.data ?? [], { ...legendOptions, facets: uniqueFacetFields });\n\t\t\tspec.signals = addSignals(spec.signals ?? [], legendOptions);\n\t\t\tspec.marks = addMarks(spec.marks ?? [], legendOptions);\n\n\t\t\t// add the legend\n\t\t\tlegends.push(getCategoricalLegend(ordinalFacets, legendOptions));\n\t\t}\n\n\t\t// continuous legends cannot be combined with any other legends\n\t\tcontinuousFacets.forEach((facet) => {\n\t\t\t// add the legend\n\t\t\tlegends.push(getContinuousLegend(facet, legendOptions));\n\t\t});\n\n\t\t// if legends is undefined, initialize it as an empty array\n\t\tif (typeof spec.legends === 'undefined') {\n\t\t\tspec.legends = [];\n\t\t}\n\t\tspec.legends.push(...legends);\n\t}\n);\n\n/**\n * converts facets that could reference preset values to the actual vega supported value\n * Example {value: 'L'} => {value: 3}\n * @param color\n * @param lineType\n * @param lineWidth\n * @param colorScheme\n */\nexport const formatFacetRefsWithPresets = (\n\tcolor: ColorFacet | undefined,\n\tlineType: LineTypeFacet | undefined,\n\tlineWidth: LineWidthFacet | undefined,\n\tsymbolShape: SymbolShapeFacet | undefined,\n\tcolorScheme: ColorScheme\n) => {\n\tlet formattedColor: FacetRef<string> | undefined;\n\tif (color && typeof color === 'object') {\n\t\tformattedColor = { value: getColorValue(color.value, colorScheme) };\n\t} else {\n\t\tformattedColor = color;\n\t}\n\n\tlet formattedLineType: FacetRef<number[]> | undefined;\n\tif (lineType && typeof lineType === 'object') {\n\t\tformattedLineType = { value: getStrokeDashFromLineType(lineType.value) };\n\t} else {\n\t\tformattedLineType = lineType;\n\t}\n\n\tlet formattedLineWidth: FacetRef<number> | undefined;\n\tif (lineWidth && typeof lineWidth === 'object') {\n\t\tformattedLineWidth = { value: getLineWidthPixelsFromLineWidth(lineWidth.value) };\n\t} else {\n\t\tformattedLineWidth = lineWidth;\n\t}\n\n\tlet formattedSymbolShape: FacetRef<string> | undefined;\n\tif (symbolShape && typeof symbolShape === 'object') {\n\t\tformattedSymbolShape = { value: getPathFromSymbolShape(symbolShape.value) };\n\t} else {\n\t\tformattedSymbolShape = symbolShape;\n\t}\n\treturn { formattedColor, formattedLineType, formattedLineWidth, formattedSymbolShape };\n};\n\n/**\n * gets the legend for all the categorical facets\n * @param facets\n * @param options\n * @returns\n */\nconst getCategoricalLegend = (facets: Facet[], options: LegendSpecOptions): Legend => {\n\tconst { name, position, title, labelLimit } = options;\n\treturn {\n\t\tfill: `${name}Entries`,\n\t\tdirection: ['top', 'bottom'].includes(position) ? 'horizontal' : 'vertical',\n\t\torient: position,\n\t\ttitle,\n\t\tencode: getEncodings(facets, options),\n\t\tcolumns: getColumns(position),\n\t\tlabelLimit,\n\t};\n};\n\n/**\n * gets the legend for a continuous facet\n * currently just setup to handle symbolSize since that is the only supported continuous facet\n * @param _facet\n * @param options\n * @returns\n */\nexport const getContinuousLegend = (facet: Facet, options: LegendSpecOptions): Legend => {\n\tconst { symbolShape } = options;\n\t// add a switch statement here for the different types of continuous legends\n\tif (facet.facetType === SYMBOL_SIZE_SCALE) {\n\t\treturn {\n\t\t\tsize: SYMBOL_SIZE_SCALE,\n\t\t\t...getLegendLayout(options),\n\t\t\tsymbolType: getSymbolType(symbolShape),\n\t\t};\n\t}\n\treturn {\n\t\tfill: LINEAR_COLOR_SCALE,\n\t\tgradientThickness: 10,\n\t\t...getLegendLayout(options),\n\t};\n};\n\nconst getLegendLayout = ({ position, title }: LegendSpecOptions): Partial<Legend> => {\n\treturn { direction: ['top', 'bottom'].includes(position) ? 'horizontal' : 'vertical', orient: position, title };\n};\n\n/**\n * Adds a new scale that is used to create the legend entries\n */\nconst addScales = produce<Scale[], [LegendSpecOptions]>((scales, { color, lineType, opacity, symbolShape }) => {\n\t// it is possible to define fields to facet the data off of on the legend\n\t// if these fields are not already defined on the scales, we need to add them\n\taddFieldToFacetScaleDomain(scales, COLOR_SCALE, color);\n\taddFieldToFacetScaleDomain(scales, LINE_TYPE_SCALE, lineType);\n\taddFieldToFacetScaleDomain(scales, OPACITY_SCALE, opacity);\n\taddFieldToFacetScaleDomain(scales, SYMBOL_SHAPE_SCALE, symbolShape);\n});\n\nconst addMarks = produce<Mark[], [LegendSpecOptions]>((marks, { highlight, keys, name }) => {\n\tif (highlight) {\n\t\tsetHoverOpacityForMarks(marks, keys, name);\n\t}\n});\n\n/**\n * Adds a new data set that aggregates the data off of the facet fields\n * This creates a row for every unique combination of the facets in the data\n * Each unique combination gets joined with a pipe to create a single string to use as legend entries\n */\nexport const addData = produce<Data[], [LegendSpecOptions & { facets: string[] }]>(\n\t(data, { facets, hiddenEntries, keys, name }) => {\n\t\t// expression for combining all the facets into a single key\n\t\tconst expr = facets.map((facet) => `datum.${facet}`).join(' + \" | \" + ');\n\t\tdata.push({\n\t\t\tname: `${name}Aggregate`,\n\t\t\tsource: 'table',\n\t\t\ttransform: [\n\t\t\t\t{\n\t\t\t\t\ttype: 'aggregate',\n\t\t\t\t\tgroupby: facets,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\ttype: 'formula',\n\t\t\t\t\tas: `${name}Entries`,\n\t\t\t\t\texpr,\n\t\t\t\t},\n\t\t\t\t...getHiddenEntriesFilter(hiddenEntries, name),\n\t\t\t],\n\t\t});\n\n\t\tif (keys?.length) {\n\t\t\tconst tableData = getTableData(data);\n\t\t\tif (!tableData.transform) {\n\t\t\t\ttableData.transform = [];\n\t\t\t}\n\t\t\ttableData.transform.push({\n\t\t\t\ttype: 'formula',\n\t\t\t\tas: `${name}_highlightGroupId`,\n\t\t\t\texpr: keys.map((key) => `datum.${key}`).join(' + \" | \" + '),\n\t\t\t});\n\t\t}\n\t}\n);\n\nexport const addSignals = produce<Signal[], [LegendSpecOptions]>(\n\t(signals, { hiddenSeries, highlight, isToggleable, keys, legendLabels, name }) => {\n\t\tif (highlight) {\n\t\t\taddHighlighSignalLegendHoverEvents(signals, name, Boolean(isToggleable || hiddenSeries), keys);\n\t\t}\n\n\t\tif (legendLabels) {\n\t\t\tsignals.push(getGenericValueSignal(`${name}_labels`, legendLabels));\n\t\t}\n\t}\n);\n","/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport merge from 'deepmerge';\nimport {\n\tBaseValueRef,\n\tColor,\n\tColorValueRef,\n\tFilterTransform,\n\tGuideEncodeEntry,\n\tLegendEncode,\n\tNumericValueRef,\n\tProductionRule,\n\tSignalRef,\n\tSymbolEncodeEntry,\n} from 'vega';\n\nimport {\n\tCOLOR_SCALE,\n\tCOMPONENT_NAME,\n\tDEFAULT_OPACITY_RULE,\n\tFILTERED_TABLE,\n\tHIGHLIGHTED_GROUP,\n\tHIGHLIGHTED_SERIES,\n\tHIGHLIGHT_CONTRAST_RATIO,\n\tLINE_TYPE_SCALE,\n\tLINE_WIDTH_SCALE,\n\tOPACITY_SCALE,\n\tSYMBOL_SHAPE_SCALE,\n\tSYMBOL_SIZE_SCALE,\n} from '@spectrum-charts/constants';\nimport { getColorValue, spectrumColors } from '@spectrum-charts/themes';\n\nimport { getPathFromSymbolShape } from '../specUtils';\nimport {\n\tColorValueV6,\n\tFacetRef,\n\tFacetType,\n\tLegendDescription,\n\tLegendLabel,\n\tLegendSpecOptions,\n\tPosition,\n\tSecondaryFacetType,\n} from '../types';\n\nexport interface Facet {\n\tfacetType: FacetType | SecondaryFacetType;\n\tfield: string;\n}\n\n/**\n * Get the number of columns for the legend\n * @param position\n * @returns\n */\nexport const getColumns = (position: Position): SignalRef | undefined => {\n\tif (['left', 'right'].includes(position)) return;\n\treturn { signal: 'floor(width / 220)' };\n};\n\n/**\n * Gets the filter transform for hidden entries\n * @param hiddenEntries\n * @returns\n */\nexport const getHiddenEntriesFilter = (hiddenEntries: string[], name: string): FilterTransform[] => {\n\tif (!hiddenEntries.length) return [];\n\treturn [\n\t\t{\n\t\t\ttype: 'filter',\n\t\t\texpr: `indexof(${JSON.stringify(hiddenEntries)}, datum.${name}Entries) === -1`,\n\t\t},\n\t];\n};\n\n/**\n * Get the legend encodings\n * @param facets\n * @param legendOptions\n * @returns\n */\nexport const getEncodings = (facets: Facet[], legendOptions: LegendSpecOptions): LegendEncode => {\n\tconst symbolEncodings = getSymbolEncodings(facets, legendOptions);\n\tconst hoverEncodings = getHoverEncodings(facets, legendOptions);\n\tconst legendLabelsEncodings = getLegendLabelsEncodings(legendOptions.name, legendOptions.legendLabels);\n\tconst showHideEncodings = getShowHideEncodings(legendOptions);\n\t// merge the encodings together\n\treturn mergeLegendEncodings([symbolEncodings, legendLabelsEncodings, hoverEncodings, showHideEncodings]);\n};\n\nconst getLegendLabelsEncodings = (name: string, legendLabels: LegendLabel[] | undefined): LegendEncode => {\n\tif (legendLabels) {\n\t\treturn {\n\t\t\tlabels: {\n\t\t\t\tupdate: {\n\t\t\t\t\ttext: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Test whether a legendLabel exists for the seriesName, if not use the seriesName\n\t\t\t\t\t\t\ttest: `indexof(pluck(${name}_labels, 'seriesName'), datum.value) > -1`,\n\t\t\t\t\t\t\tsignal: `${name}_labels[indexof(pluck(${name}_labels, 'seriesName'), datum.value)].label`,\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{ signal: 'datum.value' },\n\t\t\t\t\t],\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\t}\n\treturn {};\n};\n\nconst getHoverEncodings = (facets: Facet[], options: LegendSpecOptions): LegendEncode => {\n\tconst { highlight, highlightedSeries, name, hasMouseInteraction, descriptions } = options;\n\tif (highlight || highlightedSeries || descriptions) {\n\t\treturn {\n\t\t\tentries: {\n\t\t\t\tname: `${name}_legendEntry`,\n\t\t\t\tinteractive: true,\n\t\t\t\tenter: {\n\t\t\t\t\ttooltip: getTooltip(descriptions, name), // only add tooltip if descriptions exist\n\t\t\t\t},\n\t\t\t\tupdate: {\n\t\t\t\t\tfill: { value: 'transparent' }, // need something here to trigger the tooltip\n\t\t\t\t},\n\t\t\t},\n\t\t\tlabels: {\n\t\t\t\tupdate: {\n\t\t\t\t\topacity: getOpacityEncoding(options),\n\t\t\t\t},\n\t\t\t},\n\t\t\tsymbols: {\n\t\t\t\tupdate: {\n\t\t\t\t\topacity: getOpacityEncoding(options),\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\t} else if (hasMouseInteraction) {\n\t\treturn {\n\t\t\tentries: {\n\t\t\t\tname: `${name}_legendEntry`,\n\t\t\t\tinteractive: true,\n\t\t\t\tenter: {\n\t\t\t\t\tfill: { value: 'transparent' },\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\t}\n\n\treturn {};\n};\n\nconst getTooltip = (descriptions: LegendDescription[] | undefined, name: string) => {\n\tif (descriptions?.length) {\n\t\treturn { signal: `merge(datum, {'${COMPONENT_NAME}': '${name}'})` };\n\t}\n\treturn undefined;\n};\n\n/**\n * simple opacity encoding for legend labels and the symbol stroke opacity\n * @param legendOptions\n * @returns opactiy encoding\n */\nexport const getOpacityEncoding = ({\n\thighlight,\n\thighlightedSeries,\n\tkeys,\n}: LegendSpecOptions): ProductionRule<NumericValueRef> | undefined => {\n\tconst highlightSignalName = keys?.length ? HIGHLIGHTED_GROUP : HIGHLIGHTED_SERIES;\n\t// only add symbol opacity if highlight is true or highlightedSeries is defined\n\tif (highlight || highlightedSeries) {\n\t\treturn [\n\t\t\t{\n\t\t\t\ttest: `isValid(${highlightSignalName}) && datum.value !== ${highlightSignalName}`,\n\t\t\t\tvalue: 1 / HIGHLIGHT_CONTRAST_RATIO,\n\t\t\t},\n\t\t\tDEFAULT_OPACITY_RULE,\n\t\t];\n\t}\n\treturn undefined;\n};\n\nexport const getSymbolEncodings = (facets: Facet[], options: LegendSpecOptions): LegendEncode => {\n\tconst { color, lineType, lineWidth, name, opacity, symbolShape, colorScheme } = options;\n\tconst enter: SymbolEncodeEntry = {\n\t\tfillOpacity: getSymbolFacetEncoding<number>({ facets, facetType: OPACITY_SCALE, customValue: opacity, name }),\n\t\tshape: getSymbolFacetEncoding<string>({\n\t\t\tfacets,\n\t\t\tfacetType: SYMBOL_SHAPE_SCALE,\n\t\t\tcustomValue: symbolShape,\n\t\t\tname,\n\t\t}),\n\t\tsize: getSymbolFacetEncoding<number>({ facets, facetType: SYMBOL_SIZE_SCALE, name }),\n\t\tstrokeDash: getSymbolFacetEncoding<number[]>({\n\t\t\tfacets,\n\t\t\tfacetType: LINE_TYPE_SCALE,\n\t\t\tcustomValue: lineType,\n\t\t\tname,\n\t\t}),\n\t\tstrokeWidth: getSymbolFacetEncoding<number>({\n\t\t\tfacets,\n\t\t\tfacetType: LINE_WIDTH_SCALE,\n\t\t\tcustomValue: lineWidth,\n\t\t\tname,\n\t\t}),\n\t};\n\tconst update: SymbolEncodeEntry = {\n\t\tfill: [\n\t\t\t...getHiddenSeriesColorRule(options, 'gray-300'),\n\t\t\tgetSymbolFacetEncoding<Color>({ facets, facetType: COLOR_SCALE, customValue: color, name }) ?? {\n\t\t\t\tvalue: spectrumColors[colorScheme]['categorical-100'],\n\t\t\t},\n\t\t],\n\t\tstroke: [\n\t\t\t...getHiddenSeriesColorRule(options, 'gray-300'),\n\t\t\tgetSymbolFacetEncoding<Color>({ facets, facetType: COLOR_SCALE, customValue: color, name }) ?? {\n\t\t\t\tvalue: spectrumColors[colorScheme]['categorical-100'],\n\t\t\t},\n\t\t],\n\t};\n\t// Remove undefined values\n\tconst symbols: GuideEncodeEntry<SymbolEncodeEntry> = JSON.parse(JSON.stringify({ enter, update }));\n\treturn {\n\t\tentries: {\n\t\t\tname: `${name}_legendEntry`,\n\t\t},\n\t\tsymbols,\n\t};\n};\n\nconst getSymbolFacetEncoding = <T>({\n\tcustomValue,\n\tfacets,\n\tfacetType,\n\tname,\n}: {\n\tcustomValue?: FacetRef<T>;\n\tfacets?: Facet[];\n\tfacetType: FacetType;\n\tname: string;\n}): BaseValueRef<T> | undefined => {\n\tif (customValue) {\n\t\tif (typeof customValue === 'string') {\n\t\t\treturn { signal: `scale('${facetType}', data('${name}Aggregate')[datum.index].${customValue})` };\n\t\t}\n\t\treturn { value: customValue.value };\n\t}\n\n\tif (!facets) return;\n\n\tconst secondaryFacetMapping: { [key in FacetType]: { scale: SecondaryFacetType; signal: string } } = {\n\t\tcolor: { scale: 'secondaryColor', signal: 'colors' },\n\t\tlinearColor: { scale: 'secondaryColor', signal: 'colors' },\n\t\tlineType: { scale: 'secondaryLineType', signal: 'lineTypes' },\n\t\tlineWidth: { scale: 'secondaryLineWidth', signal: 'lineWidths' },\n\t\topacity: { scale: 'secondaryOpacity', signal: 'opacities' },\n\t\tsymbolShape: { scale: 'secondarySymbolShape', signal: 'symbolShapes' },\n\t\tsymbolSize: { scale: 'secondarySymbolSize', signal: 'symbolSizes' },\n\t\tsymbolPathWidth: { scale: 'secondarySymbolPathWidth', signal: 'symbolPathWidths' },\n\t};\n\n\tconst facet = facets.find((f) => f.facetType === facetType);\n\tif (!facet) return;\n\tconst secondaryFacet = facets.find((f) => f.facetType === secondaryFacetMapping[facetType].scale);\n\tif (secondaryFacet) {\n\t\tconst { scale, signal } = secondaryFacetMapping[facetType];\n\t\treturn {\n\t\t\tsignal: `scale('${signal}', data('${name}Aggregate')[datum.index].${facet.field})[indexof(domain('${scale}'), data('${name}Aggregate')[datum.index].${secondaryFacet.field})% length(scale('${signal}', data('${name}Aggregate')[datum.index].${facet.field}))]`,\n\t\t};\n\t}\n\n\treturn { signal: `scale('${facetType}', data('${name}Aggregate')[datum.index].${facet.field})` };\n};\n\nexport const getHiddenSeriesColorRule = (\n\t{ colorScheme, hiddenSeries, isToggleable, keys, name }: LegendSpecOptions,\n\tcolorValue: ColorValueV6\n): ({\n\ttest?: string;\n} & ColorValueRef)[] => {\n\tif (!isToggleable && !hiddenSeries.length) return [];\n\tif (keys?.length) {\n\t\treturn [\n\t\t\t{\n\t\t\t\ttest: `indexof(pluck(data('${FILTERED_TABLE}'), '${name}_highlightGroupId'), datum.value) === -1`,\n\t\t\t\tvalue: getColorValue(colorValue, colorScheme),\n\t\t\t},\n\t\t];\n\t}\n\treturn [{ test: 'indexof(hiddenSeries, datum.value) !== -1', value: getColorValue(colorValue, colorScheme) }];\n};\n\n/**\n * Gets the required encondings for show/hide toggleable legends\n * @param isToggleable\n * @returns\n */\nexport const getShowHideEncodings = (options: LegendSpecOptions): LegendEncode => {\n\tconst { colorScheme, hiddenSeries, isToggleable, keys, name, hasOnClick } = options;\n\tlet hiddenSeriesEncode: LegendEncode = {};\n\t// if the legend supports hide/show and doesn't have custom keys, add the hidden series encodings\n\tif (hiddenSeries || isToggleable) {\n\t\thiddenSeriesEncode = {\n\t\t\tlabels: {\n\t\t\t\tupdate: {\n\t\t\t\t\tfill: [\n\t\t\t\t\t\t...getHiddenSeriesColorRule(options, 'gray-500'),\n\t\t\t\t\t\t{ value: getColorValue('gray-700', colorScheme) },\n\t\t\t\t\t],\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\t}\n\n\tlet clickEncode: LegendEncode = {};\n\tif ((isToggleable && !keys) || hasOnClick) {\n\t\tclickEncode = {\n\t\t\tentries: {\n\t\t\t\tname: `${name}_legendEntry`,\n\t\t\t\tinteractive: true,\n\t\t\t\tenter: {\n\t\t\t\t\tfill: { value: 'transparent' },\n\t\t\t\t\tcursor: { value: 'pointer' },\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\t}\n\treturn mergeLegendEncodings([hiddenSeriesEncode, clickEncode]);\n};\n\n/**\n * Merge multiple vega spec legend encodings\n * @param encodings\n * @returns\n */\nexport const mergeLegendEncodings = (encodings: LegendEncode[]): LegendEncode => {\n\tlet mergedEncodings = {};\n\tfor (const encoding of encodings) {\n\t\tmergedEncodings = merge(mergedEncodings, encoding);\n\t}\n\treturn mergedEncodings;\n};\n\n/**\n * Gets the symbol type (shape) for the legend\n * @param symbolShape\n * @returns symbolShape\n */\nexport const getSymbolType = (symbolShape: FacetRef<string> | undefined): string => {\n\tif (symbolShape && typeof symbolShape === 'object' && 'value' in symbolShape)\n\t\treturn getPathFromSymbolShape(symbolShape.value);\n\treturn 'circle';\n};\n","/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport { SourceData } from 'vega';\n\nimport { HIGHLIGHTED_GROUP, HIGHLIGHTED_ITEM, SELECTED_ITEM } from '@spectrum-charts/constants';\n\n/**\n * gets the data used for highlighting hovered data points\n * @param name\n * @param source\n * @returns\n */\nexport const getLineHighlightedData = (\n\tname: string,\n\tidKey: string,\n\tsource: string,\n\thasPopover: boolean,\n\thasGroupId: boolean\n): SourceData => {\n\tconst highlightedExpr = hasGroupId\n\t\t? `${HIGHLIGHTED_GROUP} === datum.${name}_highlightGroupId`\n\t\t: `isArray(${HIGHLIGHTED_ITEM}) && indexof(${HIGHLIGHTED_ITEM}, datum.${idKey}) > -1  || ${HIGHLIGHTED_ITEM} === datum.${idKey}`;\n\tconst expr = hasPopover\n\t\t? `${SELECTED_ITEM} && ${SELECTED_ITEM} === datum.${idKey} || !${SELECTED_ITEM} && ${highlightedExpr}`\n\t\t: highlightedExpr;\n\treturn {\n\t\tname: `${name}_highlightedData`,\n\t\tsource,\n\t\ttransform: [\n\t\t\t{\n\t\t\t\ttype: 'filter',\n\t\t\t\texpr,\n\t\t\t},\n\t\t],\n\t};\n};\n\n/**\n * gets the data used for displaying points\n * @param name\n * @param staticPoint\n * @param source\n * @param isSparkline\n * @param isMethodLast\n * @returns\n */\nexport const getLineStaticPointData = (\n\tname: string,\n\tstaticPoint: string | undefined,\n\tsource: string,\n\tisSparkline: boolean | undefined,\n\tisMethodLast: boolean | undefined\n): SourceData => {\n\tconst expr =\n\t\tisSparkline && isMethodLast\n\t\t\t? \"datum === data('table')[data('table').length - 1]\"\n\t\t\t: `datum.${staticPoint} === true`;\n\treturn {\n\t\tname: `${name}_staticPointData`,\n\t\tsource,\n\t\ttransform: [\n\t\t\t{\n\t\t\t\ttype: 'filter',\n\t\t\t\texpr,\n\t\t\t},\n\t\t],\n\t};\n};\n","/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport { LineMark, Mark, NumericValueRef, ProductionRule, RuleMark } from 'vega';\n\nimport {\n\tDEFAULT_INTERACTION_MODE,\n\tDEFAULT_OPACITY_RULE,\n\tHIGHLIGHTED_SERIES,\n\tHIGHLIGHT_CONTRAST_RATIO,\n\tSELECTED_SERIES,\n\tSERIES_ID,\n} from '@spectrum-charts/constants';\n\nimport { getPopovers } from '../chartPopover/chartPopoverUtils';\nimport {\n\tgetColorProductionRule,\n\tgetItemHoverArea,\n\tgetLineWidthProductionRule,\n\tgetOpacityProductionRule,\n\tgetPointsForVoronoi,\n\tgetStrokeDashProductionRule,\n\tgetVoronoiPath,\n\tgetXProductionRule,\n\tgetYProductionRule,\n\thasPopover,\n} from '../marks/markUtils';\nimport { ScaleType } from '../types';\nimport {\n\tgetHighlightBackgroundPoint,\n\tgetHighlightPoint,\n\tgetSecondaryHighlightPoint,\n\tgetSelectRingPoint,\n\tgetSelectionPoint,\n} from './linePointUtils';\nimport { LineMarkOptions } from './lineUtils';\n\n/**\n * generates a line mark\n * @param lineOptions\n * @param dataSource\n * @returns LineMark\n */\nexport const getLineMark = (lineMarkOptions: LineMarkOptions, dataSource: string): LineMark => {\n\tconst {\n\t\tchartPopovers,\n\t\tcolor,\n\t\tcolorScheme,\n\t\tdimension,\n\t\tlineType,\n\t\tlineWidth,\n\t\tmetric,\n\t\tmetricAxis,\n\t\tname,\n\t\topacity,\n\t\tscaleType,\n\t} = lineMarkOptions;\n\tconst popovers = getPopovers(chartPopovers ?? [], name);\n\tconst popoverWithDimensionHighlightExists = popovers.some(\n\t\t({ UNSAFE_highlightBy }) => UNSAFE_highlightBy === 'dimension'\n\t);\n\n\treturn {\n\t\tname,\n\t\tdescription: name,\n\t\ttype: 'line',\n\t\tfrom: { data: dataSource },\n\t\tinteractive: false,\n\t\tencode: {\n\t\t\tenter: {\n\t\t\t\ty: getYProductionRule(metricAxis, metric),\n\t\t\t\tstroke: getColorProductionRule(color, colorScheme),\n\t\t\t\tstrokeDash: getStrokeDashProductionRule(lineType),\n\t\t\t\tstrokeOpacity: getOpacityProductionRule(opacity),\n\t\t\t\tstrokeWidth: getLineWidthProductionRule(lineWidth),\n\t\t\t},\n\t\t\tupdate: {\n\t\t\t\t// this has to be in update because when you resize the window that doesn't rebuild the spec\n\t\t\t\t// but it may change the x position if it causes the chart to resize\n\t\t\t\tx: getXProductionRule(scaleType, dimension),\n\t\t\t\t...(popoverWithDimensionHighlightExists ? {} : { opacity: getLineOpacity(lineMarkOptions) }),\n\t\t\t},\n\t\t},\n\t};\n};\n\nexport const getLineOpacity = ({\n\tdisplayOnHover,\n\tinteractiveMarkName,\n\tpopoverMarkName,\n\tisHighlightedByGroup,\n\thighlightedItem,\n}: LineMarkOptions): ProductionRule<NumericValueRef> => {\n\tif ((!interactiveMarkName || displayOnHover) && highlightedItem === undefined) return [DEFAULT_OPACITY_RULE];\n\tconst strokeOpacityRules: ProductionRule<NumericValueRef> = [];\n\n\tif (isHighlightedByGroup) {\n\t\tstrokeOpacityRules.push({\n\t\t\ttest: `indexof(pluck(data('${interactiveMarkName}_highlightedData'), '${SERIES_ID}'), datum.${SERIES_ID}) !== -1`,\n\t\t\tvalue: 1,\n\t\t});\n\t}\n\n\t// add a rule that will lower the opacity of the line if there is a hovered series, but this line is not the one hovered\n\tstrokeOpacityRules.push(\n\t\t{\n\t\t\ttest: `isValid(${HIGHLIGHTED_SERIES}) && ${HIGHLIGHTED_SERIES} !== datum.${SERIES_ID}`,\n\t\t\tvalue: 1 / HIGHLIGHT_CONTRAST_RATIO,\n\t\t},\n\t\t{\n\t\t\ttest: `length(data('${interactiveMarkName}_highlightedData')) > 0 && indexof(pluck(data('${interactiveMarkName}_highlightedData'), '${SERIES_ID}'), datum.${SERIES_ID}) === -1`,\n\t\t\tvalue: 1 / HIGHLIGHT_CONTRAST_RATIO,\n\t\t}\n\t);\n\n\tif (popoverMarkName) {\n\t\tstrokeOpacityRules.push({\n\t\t\ttest: `isValid(${SELECTED_SERIES}) && ${SELECTED_SERIES} !== datum.${SERIES_ID}`,\n\t\t\tvalue: 1 / HIGHLIGHT_CONTRAST_RATIO,\n\t\t});\n\t}\n\t// This allows us to only show the metric range when hovering over the parent line component.\n\tstrokeOpacityRules.push(DEFAULT_OPACITY_RULE);\n\n\treturn strokeOpacityRules;\n};\n\n/**\n * All the marks that get displayed when hovering or selecting a point on a line\n * @param lineMarkOptions\n * @param dataSource\n * @param secondaryHighlightedMetric\n * @returns\n */\nexport const getLineHoverMarks = (\n\tlineOptions: LineMarkOptions,\n\tdataSource: string,\n\tsecondaryHighlightedMetric?: string\n): Mark[] => {\n\tconst { dimension, name, scaleType } = lineOptions;\n\treturn [\n\t\t// vertical rule shown for the hovered or selected point\n\t\tgetHoverRule(dimension, name, scaleType),\n\t\t// point behind the hovered or selected point used to prevent bacgorund elements from being visible through low opacity point\n\t\tgetHighlightBackgroundPoint(lineOptions),\n\t\t// if has popover, add selection ring and selection point\n\t\t...(hasPopover(lineOptions) ? [getSelectRingPoint(lineOptions), getSelectionPoint(lineOptions)] : []),\n\t\t// hover or select point\n\t\tgetHighlightPoint(lineOptions),\n\t\t// additional point that gets highlighted like the trendline or raw line point\n\t\t...(secondaryHighlightedMetric ? [getSecondaryHighlightPoint(lineOptions, secondaryHighlightedMetric)] : []),\n\t\t// get interactive marks for the line\n\t\t...getInteractiveMarks(dataSource, lineOptions),\n\t];\n};\n\nconst getHoverRule = (dimension: string, name: string, scaleType: ScaleType): RuleMark => {\n\treturn {\n\t\tname: `${name}_hoverRule`,\n\t\tdescription: `${name}_hoverRule`,\n\t\ttype: 'rule',\n\t\tfrom: { data: `${name}_highlightedData` },\n\t\tinteractive: false,\n\t\tencode: {\n\t\t\tenter: {\n\t\t\t\ty: { value: 0 },\n\t\t\t\ty2: { signal: 'height' },\n\t\t\t\tstrokeWidth: { value: 1 },\n\t\t\t},\n\t\t\tupdate: {\n\t\t\t\tx: getXProductionRule(scaleType, dimension),\n\t\t\t\topacity: { signal: `length(data('${name}_selectedData')) > 0 ? 0 : 1` },\n\t\t\t},\n\t\t},\n\t};\n};\n\nconst getInteractiveMarks = (dataSource: string, lineOptions: LineMarkOptions): Mark[] => {\n\tconst { interactionMode = DEFAULT_INTERACTION_MODE } = lineOptions;\n\n\tconst tooltipMarks = {\n\t\tnearest: getVoronoiMarks,\n\t\titem: getItemHoverMarks,\n\t};\n\n\treturn tooltipMarks[interactionMode](lineOptions, dataSource);\n};\n\nconst getVoronoiMarks = (lineOptions: LineMarkOptions, dataSource: string): Mark[] => {\n\tconst { dimension, metric, metricAxis, name, scaleType } = lineOptions;\n\n\treturn [\n\t\t// points used for the voronoi transform\n\t\tgetPointsForVoronoi(dataSource, dimension, metric, name, scaleType, metricAxis),\n\t\t// voronoi transform used to get nearest point paths\n\t\tgetVoronoiPath(lineOptions, `${name}_pointsForVoronoi`),\n\t];\n};\n\nconst getItemHoverMarks = (lineOptions: LineMarkOptions, dataSource: string): Mark[] => {\n\tconst { chartTooltips = [], dimension, metric, metricAxis, name, scaleType } = lineOptions;\n\n\treturn [\n\t\t// area around item that triggers hover\n\t\tgetItemHoverArea(chartTooltips, dataSource, dimension, metric, name, scaleType, metricAxis),\n\t];\n};\n","/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport { ColorValueRef, NumericValueRef, SymbolMark } from 'vega';\n\nimport {\n\tBACKGROUND_COLOR,\n\tDEFAULT_SYMBOL_SIZE,\n\tDEFAULT_SYMBOL_STROKE_WIDTH,\n\tSELECTED_GROUP,\n\tSELECTED_ITEM,\n} from '@spectrum-charts/constants';\nimport { getColorValue } from '@spectrum-charts/themes';\n\nimport {\n\tgetColorProductionRule,\n\tgetHighlightOpacityValue,\n\tgetOpacityProductionRule,\n\tgetXProductionRule,\n\tgetYProductionRule,\n\thasPopover,\n} from '../marks/markUtils';\nimport { LineSpecOptions, ProductionRuleTests } from '../types';\nimport { LineMarkOptions } from './lineUtils';\n\nconst staticPointTest = (staticPoint: string) => `datum.${staticPoint} && datum.${staticPoint} === true`;\nconst getSelectedTest = (name: string, idKey: string) =>\n\t`(${SELECTED_ITEM} && ${SELECTED_ITEM} === datum.${idKey}) || (${SELECTED_GROUP} && ${SELECTED_GROUP} === datum.${name}_selectedGroupId)`;\n\n/**\n * Gets the point mark for static points on a line chart.\n * @param lineMarkOptions\n * @returns SymbolMark\n */\nexport const getLineStaticPoint = ({\n\tname,\n\tmetric,\n\tmetricAxis,\n\tcolor,\n\tcolorScheme,\n\tscaleType,\n\tdimension,\n\tisSparkline,\n\tpointSize = 125,\n}: LineSpecOptions): SymbolMark => {\n\treturn {\n\t\tname: `${name}_staticPoints`,\n\t\tdescription: `${name}_staticPoints`,\n\t\ttype: 'symbol',\n\t\tfrom: { data: `${name}_staticPointData` },\n\t\tinteractive: false,\n\t\tencode: {\n\t\t\tenter: {\n\t\t\t\tsize: { value: pointSize },\n\t\t\t\tfill: isSparkline ? { signal: BACKGROUND_COLOR } : getColorProductionRule(color, colorScheme),\n\t\t\t\tstroke: isSparkline ? getColorProductionRule(color, colorScheme) : { signal: BACKGROUND_COLOR },\n\t\t\t\ty: getYProductionRule(metricAxis, metric),\n\t\t\t},\n\t\t\tupdate: {\n\t\t\t\tx: getXProductionRule(scaleType, dimension),\n\t\t\t},\n\t\t},\n\t};\n};\n\n/**\n * Gets a background to points to prevent opacity from displaying elements behind the point.\n * @param lineMarkOptions\n * @returns SymbolMark\n */\nexport const getHighlightBackgroundPoint = (lineOptions: LineMarkOptions): SymbolMark => {\n\tconst { dimension, metric, metricAxis, name, scaleType } = lineOptions;\n\treturn {\n\t\tname: `${name}_pointBackground`,\n\t\tdescription: `${name}_pointBackground`,\n\t\ttype: 'symbol',\n\t\tfrom: { data: `${name}_highlightedData` },\n\t\tinteractive: false,\n\t\tencode: {\n\t\t\tenter: {\n\t\t\t\ty: getYProductionRule(metricAxis, metric),\n\t\t\t\tfill: { signal: BACKGROUND_COLOR },\n\t\t\t\tstroke: { signal: BACKGROUND_COLOR },\n\t\t\t},\n\t\t\tupdate: {\n\t\t\t\tsize: getHighlightPointSize(lineOptions),\n\t\t\t\tstrokeWidth: getHighlightPointStrokeWidth(lineOptions),\n\t\t\t\tx: getXProductionRule(scaleType, dimension),\n\t\t\t},\n\t\t},\n\t};\n};\n\nconst getHighlightOrSelectionPoint = (lineOptions: LineMarkOptions, useHighlightedData = true): SymbolMark => {\n\tconst { color, colorScheme, dimension, metric, metricAxis, name, scaleType } = lineOptions;\n\treturn {\n\t\tname: `${name}_point_${useHighlightedData ? 'highlight' : 'select'}`,\n\t\ttype: 'symbol',\n\t\tfrom: { data: `${name}${useHighlightedData ? '_highlightedData' : '_selectedData'}` },\n\t\tinteractive: false,\n\t\tencode: {\n\t\t\tenter: {\n\t\t\t\ty: getYProductionRule(metricAxis, metric),\n\t\t\t\tstroke: getColorProductionRule(color, colorScheme),\n\t\t\t},\n\t\t\tupdate: {\n\t\t\t\tfill: getHighlightPointFill(lineOptions),\n\t\t\t\tsize: getHighlightPointSize(lineOptions),\n\t\t\t\tstroke: getHighlightPointStroke(lineOptions),\n\t\t\t\tstrokeOpacity: getHighlightPointStrokeOpacity(lineOptions),\n\t\t\t\tstrokeWidth: getHighlightPointStrokeWidth(lineOptions),\n\t\t\t\tx: getXProductionRule(scaleType, dimension),\n\t\t\t},\n\t\t},\n\t};\n};\n\n/**\n * Displays a point on hover on the line.\n * @param lineMarkOptions\n * @returns SymbolMark\n */\nexport const getHighlightPoint = (lineOptions: LineMarkOptions): SymbolMark => {\n\treturn getHighlightOrSelectionPoint(lineOptions, true);\n};\n\n/**\n * Displays a point on select on the line.\n * @param lineMarkOptions\n * @returns SymbolMark\n */\nexport const getSelectionPoint = (lineOptions: LineMarkOptions): SymbolMark => {\n\treturn getHighlightOrSelectionPoint(lineOptions, false);\n};\n\n/**\n * Displays a secondary highlight point on hover or select on the line.\n * @param lineMarkOptions\n * @param secondaryHighlightedMetric\n * @returns SymbolMark\n */\nexport const getSecondaryHighlightPoint = (\n\tlineOptions: LineMarkOptions,\n\tsecondaryHighlightedMetric: string\n): SymbolMark => {\n\tconst { color, colorScheme, dimension, metricAxis, name, scaleType } = lineOptions;\n\treturn {\n\t\tname: `${name}_secondaryPoint`,\n\t\ttype: 'symbol',\n\t\tfrom: { data: `${name}_highlightedData` },\n\t\tinteractive: false,\n\t\tencode: {\n\t\t\tenter: {\n\t\t\t\ty: getYProductionRule(metricAxis, secondaryHighlightedMetric),\n\t\t\t\tfill: { signal: BACKGROUND_COLOR },\n\t\t\t\tstroke: getColorProductionRule(color, colorScheme),\n\t\t\t},\n\t\t\tupdate: {\n\t\t\t\tx: getXProductionRule(scaleType, dimension),\n\t\t\t},\n\t\t},\n\t};\n};\n\n/**\n * gets the fill color for the highlighted point\n * @param lineMarkOptions\n * @returns fill rule\n */\nexport const getHighlightPointFill = (markOptions: LineMarkOptions): ProductionRuleTests<ColorValueRef> => {\n\tconst { color, colorScheme, idKey, name, staticPoint } = markOptions;\n\tconst fillRules: ProductionRuleTests<ColorValueRef> = [];\n\tconst selectedTest = getSelectedTest(name, idKey);\n\n\tif (staticPoint) {\n\t\tfillRules.push({ test: staticPointTest(staticPoint), ...getColorProductionRule(color, colorScheme) });\n\t}\n\tif (hasPopover(markOptions)) {\n\t\tfillRules.push({ test: selectedTest, ...getColorProductionRule(color, colorScheme) });\n\t}\n\treturn [...fillRules, { signal: BACKGROUND_COLOR }];\n};\n\n/**\n * gets the stroke color for the highlighted point\n * @param lineMarkOptions\n * @returns stroke rule\n */\nexport const getHighlightPointStroke = (markOptions: LineMarkOptions): ProductionRuleTests<ColorValueRef> => {\n\tconst { color, colorScheme, idKey, name, staticPoint } = markOptions;\n\tconst strokeRules: ProductionRuleTests<ColorValueRef> = [];\n\tconst selectedTest = getSelectedTest(name, idKey);\n\n\tif (staticPoint) {\n\t\tstrokeRules.push({ test: staticPointTest(staticPoint), ...getColorProductionRule(color, colorScheme) });\n\t}\n\tif (hasPopover(markOptions)) {\n\t\tstrokeRules.push({ test: selectedTest, signal: BACKGROUND_COLOR });\n\t}\n\n\treturn [...strokeRules, getColorProductionRule(color, colorScheme)];\n};\n\n/**\n * gets the stroke opacity for the highlighted point\n * @param lineMarkOptions\n * @returns stroke opacity rule\n */\nexport const getHighlightPointStrokeOpacity = ({\n\topacity,\n\tstaticPoint,\n}: LineMarkOptions): ProductionRuleTests<NumericValueRef> => {\n\tconst baseOpacityRule = getOpacityProductionRule(opacity);\n\tconst strokeOpacityRules: ProductionRuleTests<NumericValueRef> = [];\n\tif (staticPoint) {\n\t\tstrokeOpacityRules.push({\n\t\t\ttest: staticPointTest(staticPoint),\n\t\t\t...getHighlightOpacityValue(baseOpacityRule),\n\t\t});\n\t}\n\treturn [...strokeOpacityRules, baseOpacityRule];\n};\n\n/**\n * gets the size for the highlighted point\n * @param lineMarkOptions\n * @returns size rule\n */\nexport const getHighlightPointSize = ({ staticPoint }: LineMarkOptions): ProductionRuleTests<NumericValueRef> => {\n\tconst sizeRules: ProductionRuleTests<NumericValueRef> = [];\n\tif (staticPoint) {\n\t\tsizeRules.push({\n\t\t\t// if this is a static point, reduce the size since we are increasing the stroke width\n\t\t\ttest: staticPointTest(staticPoint),\n\t\t\tvalue: 64,\n\t\t});\n\t}\n\treturn [...sizeRules, { value: DEFAULT_SYMBOL_SIZE }];\n};\n\n/**\n * gets the stroke width for the highlighted point\n * @param lineMarkOptions\n * @returns stroke width rule\n */\nexport const getHighlightPointStrokeWidth = ({\n\tstaticPoint,\n}: LineMarkOptions): ProductionRuleTests<NumericValueRef> => {\n\tconst strokeWidthRules: ProductionRuleTests<NumericValueRef> = [];\n\tif (staticPoint) {\n\t\tstrokeWidthRules.push({\n\t\t\t// if the point is static, increase the stroke width\n\t\t\ttest: staticPointTest(staticPoint),\n\t\t\tvalue: 6,\n\t\t});\n\t}\n\treturn [...strokeWidthRules, { value: DEFAULT_SYMBOL_STROKE_WIDTH }];\n};\n\n/**\n * Gets point that is used for the selection ring.\n * @param lineMarkOptions\n * @returns SymbolMark\n */\nexport const getSelectRingPoint = (lineOptions: LineMarkOptions): SymbolMark => {\n\tconst { colorScheme, dimension, idKey, metric, metricAxis, name, scaleType } = lineOptions;\n\tconst selectedTest = getSelectedTest(name, idKey);\n\n\treturn {\n\t\tname: `${name}_pointSelectRing`,\n\t\ttype: 'symbol',\n\t\tfrom: { data: `${name}_selectedData` },\n\t\tinteractive: false,\n\t\tencode: {\n\t\t\tenter: {\n\t\t\t\ty: getYProductionRule(metricAxis, metric),\n\t\t\t\tfill: { signal: BACKGROUND_COLOR },\n\t\t\t\tstroke: { value: getColorValue('static-blue', colorScheme) },\n\t\t\t},\n\t\t\tupdate: {\n\t\t\t\tsize: [{ test: selectedTest, value: 196 }, { value: 0 }],\n\t\t\t\tstrokeWidth: [{ test: selectedTest, value: DEFAULT_SYMBOL_STROKE_WIDTH }, { value: 0 }],\n\t\t\t\tx: getXProductionRule(scaleType, dimension),\n\t\t\t},\n\t\t},\n\t};\n};\n","/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport { produce } from 'immer';\nimport { Data, Mark, Scale, Signal, Spec } from 'vega';\n\nimport {\n\tCOLOR_SCALE,\n\tDEFAULT_COLOR_SCHEME,\n\tDEFAULT_METRIC,\n\tDEFAULT_TIME_DIMENSION,\n\tFILTERED_TABLE,\n\tINTERACTION_MODE,\n\tLINE_TYPE_SCALE,\n\tOPACITY_SCALE,\n} from '@spectrum-charts/constants';\nimport { toCamelCase } from '@spectrum-charts/utils';\n\nimport { addPopoverData } from '../chartPopover/chartPopoverUtils';\nimport { addTooltipData, addTooltipSignals, isHighlightedByGroup } from '../chartTooltip/chartTooltipUtils';\nimport { addTimeTransform, getFilteredTooltipData, getTableData } from '../data/dataUtils';\nimport { getHoverMarkNames, getInteractiveMarkName, hasPopover, isInteractive } from '../marks/markUtils';\nimport {\n\tgetMetricRangeData,\n\tgetMetricRangeGroupMarks,\n\tgetMetricRangeSignals,\n\tgetMetricRanges,\n} from '../metricRange/metricRangeUtils';\nimport { addContinuousDimensionScale, addFieldToFacetScaleDomain, addMetricScale } from '../scale/scaleSpecBuilder';\nimport { addHighlightedItemSignalEvents, addHighlightedSeriesSignalEvents } from '../signal/signalSpecBuilder';\nimport { getFacetsFromOptions } from '../specUtils';\nimport { addTrendlineData, getTrendlineMarks, getTrendlineScales, setTrendlineSignals } from '../trendline';\nimport { ColorScheme, HighlightedItem, LineOptions, LineSpecOptions } from '../types';\nimport { getLineHighlightedData, getLineStaticPointData } from './lineDataUtils';\nimport { getLineHoverMarks, getLineMark } from './lineMarkUtils';\nimport { getLineStaticPoint } from './linePointUtils';\nimport { getPopoverMarkName } from './lineUtils';\n\nexport const addLine = produce<\n\tSpec,\n\t[LineOptions & { colorScheme?: ColorScheme; highlightedItem?: HighlightedItem; index?: number; idKey: string }]\n>(\n\t(\n\t\tspec,\n\t\t{\n\t\t\tchartPopovers = [],\n\t\t\tchartTooltips = [],\n\t\t\tcolor = { value: 'categorical-100' },\n\t\t\tcolorScheme = DEFAULT_COLOR_SCHEME,\n\t\t\tdimension = DEFAULT_TIME_DIMENSION,\n\t\t\thasOnClick = false,\n\t\t\tindex = 0,\n\t\t\tlineType = { value: 'solid' },\n\t\t\tmetric = DEFAULT_METRIC,\n\t\t\tmetricAxis,\n\t\t\tmetricRanges = [],\n\t\t\tname,\n\t\t\topacity = { value: 1 },\n\t\t\tscaleType = 'time',\n\t\t\ttrendlines = [],\n\t\t\t...options\n\t\t}\n\t) => {\n\t\tconst lineName = toCamelCase(name || `line${index}`);\n\t\t// put options back together now that all defaults are set\n\t\tconst lineOptions: LineSpecOptions = {\n\t\t\tchartPopovers,\n\t\t\tchartTooltips,\n\t\t\tcolor,\n\t\t\tcolorScheme,\n\t\t\tdimension,\n\t\t\thasOnClick,\n\t\t\tindex,\n\t\t\tinteractiveMarkName: getInteractiveMarkName(\n\t\t\t\t{\n\t\t\t\t\tchartPopovers,\n\t\t\t\t\tchartTooltips,\n\t\t\t\t\thasOnClick,\n\t\t\t\t\thighlightedItem: options.highlightedItem,\n\t\t\t\t\tmetricRanges,\n\t\t\t\t\ttrendlines,\n\t\t\t\t},\n\t\t\t\tlineName\n\t\t\t),\n\t\t\tlineType,\n\t\t\tmetric,\n\t\t\tmetricAxis,\n\t\t\tmetricRanges,\n\t\t\tname: lineName,\n\t\t\topacity,\n\t\t\tpopoverMarkName: getPopoverMarkName(chartPopovers, lineName),\n\t\t\tscaleType,\n\t\t\ttrendlines,\n\t\t\t...options,\n\t\t};\n\t\tlineOptions.isHighlightedByGroup = isHighlightedByGroup(lineOptions);\n\n\t\tspec.data = addData(spec.data ?? [], lineOptions);\n\t\tspec.signals = addSignals(spec.signals ?? [], lineOptions);\n\t\tspec.scales = setScales(spec.scales ?? [], lineOptions);\n\t\tspec.marks = addLineMarks(spec.marks ?? [], lineOptions);\n\n\t\treturn spec;\n\t}\n);\n\nexport const addData = produce<Data[], [LineSpecOptions]>((data, options) => {\n\tconst { chartTooltips, dimension, highlightedItem, isSparkline, isMethodLast, name, scaleType, staticPoint } =\n\t\toptions;\n\tif (scaleType === 'time') {\n\t\tconst tableData = getTableData(data);\n\t\ttableData.transform = addTimeTransform(tableData.transform ?? [], dimension);\n\t}\n\tif (isInteractive(options) || highlightedItem !== undefined) {\n\t\tdata.push(\n\t\t\tgetLineHighlightedData(\n\t\t\t\tname,\n\t\t\t\toptions.idKey,\n\t\t\t\tFILTERED_TABLE,\n\t\t\t\thasPopover(options),\n\t\t\t\tisHighlightedByGroup(options)\n\t\t\t)\n\t\t);\n\t\tdata.push(getFilteredTooltipData(chartTooltips));\n\t}\n\tif (staticPoint || isSparkline)\n\t\tdata.push(getLineStaticPointData(name, staticPoint, FILTERED_TABLE, isSparkline, isMethodLast));\n\taddTrendlineData(data, options);\n\taddTooltipData(data, options, false);\n\taddPopoverData(data, options);\n\tdata.push(...getMetricRangeData(options));\n});\n\nexport const addSignals = produce<Signal[], [LineSpecOptions]>((signals, options) => {\n\tconst { idKey, name } = options;\n\tsetTrendlineSignals(signals, options);\n\tsignals.push(...getMetricRangeSignals(options));\n\n\tif (!isInteractive(options)) return;\n\taddHighlightedItemSignalEvents(signals, `${name}_voronoi`, idKey, 2);\n\taddHighlightedSeriesSignalEvents(signals, `${name}_voronoi`, 2);\n\taddHoverSignals(signals, options);\n\taddTooltipSignals(signals, options);\n});\n\nexport const setScales = produce<Scale[], [LineSpecOptions]>((scales, options) => {\n\tconst { metricAxis, dimension, color, lineType, opacity, padding, scaleType } = options;\n\t// add dimension scale\n\taddContinuousDimensionScale(scales, { scaleType, dimension, padding });\n\t// add color to the color domain\n\taddFieldToFacetScaleDomain(scales, COLOR_SCALE, color);\n\t// add lineType to the lineType domain\n\taddFieldToFacetScaleDomain(scales, LINE_TYPE_SCALE, lineType);\n\t// add opacity to the opacity domain\n\taddFieldToFacetScaleDomain(scales, OPACITY_SCALE, opacity);\n\t// find the linear scale and add our fields to it\n\taddMetricScale(scales, getMetricKeys(options));\n\t// add linear scale with custom name\n\tif (metricAxis) {\n\t\taddMetricScale(scales, getMetricKeys(options), 'y', metricAxis);\n\t}\n\t// add trendline scales\n\tscales.push(...getTrendlineScales(options));\n\treturn scales;\n});\n\n// The order that marks are added is important since it determines the draw order.\nexport const addLineMarks = produce<Mark[], [LineSpecOptions]>((marks, options) => {\n\tconst { color, highlightedItem, isSparkline, lineType, name, opacity, staticPoint } = options;\n\n\tconst { facets } = getFacetsFromOptions({ color, lineType, opacity });\n\n\tmarks.push({\n\t\tname: `${name}_group`,\n\t\ttype: 'group',\n\t\tfrom: {\n\t\t\tfacet: {\n\t\t\t\tname: `${name}_facet`,\n\t\t\t\tdata: FILTERED_TABLE,\n\t\t\t\tgroupby: facets,\n\t\t\t},\n\t\t},\n\t\tmarks: [getLineMark(options, `${name}_facet`)],\n\t});\n\tif (staticPoint || isSparkline) marks.push(getLineStaticPoint(options));\n\tmarks.push(...getMetricRangeGroupMarks(options));\n\tif (isInteractive(options) || highlightedItem !== undefined) {\n\t\tmarks.push(...getLineHoverMarks(options, `${FILTERED_TABLE}ForTooltip`));\n\t}\n\tmarks.push(...getTrendlineMarks(options));\n});\n\nconst getMetricKeys = (lineOptions: LineSpecOptions) => {\n\tconst metricKeys = [lineOptions.metric];\n\n\t// metric range fields should be added if metric-axis will be scaled to fit\n\tconst metricRanges = getMetricRanges(lineOptions);\n\tmetricRanges.forEach((metricRange) => {\n\t\tif (metricRange.scaleAxisToFit) metricKeys.push(metricRange.metricStart, metricRange.metricEnd);\n\t});\n\n\treturn metricKeys;\n};\n\nconst addHoverSignals = (signals: Signal[], options: LineSpecOptions) => {\n\tconst { idKey, interactionMode, name } = options;\n\tif (interactionMode !== INTERACTION_MODE.ITEM) return;\n\tgetHoverMarkNames(name).forEach((hoverMarkName) => {\n\t\taddHighlightedItemSignalEvents(signals, hoverMarkName, idKey, 1);\n\t\taddHighlightedSeriesSignalEvents(signals, hoverMarkName, 1);\n\t});\n};\n","/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport {\n\tBarAnnotationOptions,\n\tChartPopoverOptions,\n\tChartTooltipOptions,\n\tColorFacet,\n\tColorScheme,\n\tDonutSummaryOptions,\n\tHighlightedItem,\n\tInteractionMode,\n\tLineTypeFacet,\n\tLineWidthFacet,\n\tMetricRangeOptions,\n\tOpacityFacet,\n\tScaleType,\n\tScatterPathOptions,\n\tSegmentLabelOptions,\n\tTrendlineOptions,\n} from '../types';\n\nexport const getPopoverMarkName = (chartPopovers: ChartPopoverOptions[], lineName: string): string | undefined => {\n\t// if the line has a popover, this line is the target for the popover\n\tif (chartPopovers.length) {\n\t\treturn lineName;\n\t}\n};\n\nexport interface LineMarkOptions {\n\tbarAnnotations?: BarAnnotationOptions[];\n\tchartPopovers?: ChartPopoverOptions[];\n\tchartTooltips?: ChartTooltipOptions[];\n\tcolor: ColorFacet;\n\tcolorScheme: ColorScheme;\n\tdimension: string;\n\tdisplayOnHover?: boolean;\n\tdonutSummaries?: DonutSummaryOptions[];\n\thasOnClick?: boolean;\n\thighlightedItem?: HighlightedItem;\n\tidKey: string;\n\tinteractiveMarkName?: string; // optional name of the mark that is used for hover and click interactions\n\tinteractionMode?: InteractionMode;\n\tisHighlightedByDimension?: boolean;\n\tisHighlightedByGroup?: boolean;\n\tlineType: LineTypeFacet;\n\tlineWidth?: LineWidthFacet;\n\tmetric: string;\n\tmetricAxis?: string;\n\tmetricRanges?: MetricRangeOptions[];\n\tname: string;\n\topacity: OpacityFacet;\n\tpopoverMarkName?: string;\n\tscaleType: ScaleType;\n\tscatterPaths?: ScatterPathOptions[];\n\tsegmentLabels?: SegmentLabelOptions[];\n\tstaticPoint?: string;\n\ttrendlines?: TrendlineOptions[];\n}\n","/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport {\n\tAreaEncodeEntry,\n\tArrayValueRef,\n\tColorValueRef,\n\tEncodeEntry,\n\tGroupMark,\n\tNumericValueRef,\n\tPathMark,\n\tSignalRef,\n\tSymbolMark,\n} from 'vega';\n\nimport {\n\tBACKGROUND_COLOR,\n\tCOLOR_SCALE,\n\tCOMPONENT_NAME,\n\tDEFAULT_OPACITY_RULE,\n\tDEFAULT_TRANSFORMED_TIME_DIMENSION,\n\tHIGHLIGHT_CONTRAST_RATIO,\n\tHOVER_SHAPE,\n\tHOVER_SHAPE_COUNT,\n\tHOVER_SIZE,\n\tLINEAR_COLOR_SCALE,\n\tLINE_TYPE_SCALE,\n\tLINE_WIDTH_SCALE,\n\tOPACITY_SCALE,\n\tSELECTED_GROUP,\n\tSELECTED_ITEM,\n\tSYMBOL_SIZE_SCALE,\n} from '@spectrum-charts/constants';\nimport { getColorValue } from '@spectrum-charts/themes';\n\nimport { addHighlightMarkOpacityRules } from '../chartTooltip/chartTooltipUtils';\nimport { LineMarkOptions } from '../line/lineUtils';\nimport { getScaleName } from '../scale/scaleSpecBuilder';\nimport {\n\tgetLineWidthPixelsFromLineWidth,\n\tgetStrokeDashFromLineType,\n\tgetVegaSymbolSizeFromRscSymbolSize,\n} from '../specUtils';\nimport {\n\tBarSpecOptions,\n\tChartPopoverOptions,\n\tChartTooltipOptions,\n\tColorFacet,\n\tColorScheme,\n\tDonutSpecOptions,\n\tDualFacet,\n\tHighlightedItem,\n\tLineTypeFacet,\n\tLineWidthFacet,\n\tMetricRangeOptions,\n\tOpacityFacet,\n\tProductionRuleTests,\n\tScaleType,\n\tScatterSpecOptions,\n\tSymbolSizeFacet,\n\tTrendlineOptions,\n} from '../types';\n\n/**\n * If a popover or hasOnClick exists on the mark, then set the cursor to a pointer.\n * @param chartPopovers\n * @param hasOnClick\n * @returns cursor encoding\n */\nexport const getCursor = (chartPopovers: ChartPopoverOptions[], hasOnClick?: boolean): EncodeEntry['cursor'] => {\n\tif (hasOnClick || chartPopovers.length) {\n\t\treturn { value: 'pointer' };\n\t}\n};\n\n/**\n * If a tooltip exists on the mark, then set tooltip to true.\n */\nexport function getTooltip(\n\tchartTooltips: ChartTooltipOptions[],\n\tname: string,\n\tnestedDatum?: boolean\n): ProductionRuleTests<SignalRef> | SignalRef | undefined {\n\t// skip annotations\n\tif (chartTooltips.length) {\n\t\tconst defaultTooltip = {\n\t\t\tsignal: `merge(datum${nestedDatum ? '.datum' : ''}, {'${COMPONENT_NAME}': '${name}'})`,\n\t\t};\n\t\t// if the tooltip has an excludeDataKey option, then disable the tooltip where that key is present\n\t\tconst excludeDataKeys = chartTooltips[0].excludeDataKeys;\n\t\tif (excludeDataKeys?.length) {\n\t\t\treturn [\n\t\t\t\t...excludeDataKeys.map((excludeDataKey) => ({ test: `datum.${excludeDataKey}`, signal: 'false' })),\n\t\t\t\tdefaultTooltip,\n\t\t\t];\n\t\t}\n\n\t\treturn defaultTooltip;\n\t}\n}\n\n/**\n * returns the border stroke encodings for stacked bar/area\n */\nexport const getBorderStrokeEncodings = (isStacked: boolean, isArea = false): AreaEncodeEntry => {\n\tif (isStacked)\n\t\treturn {\n\t\t\tstroke: { signal: BACKGROUND_COLOR },\n\t\t\tstrokeWidth: { value: isArea ? 1.5 : 1 },\n\t\t\tstrokeJoin: { value: 'round' },\n\t\t};\n\treturn {};\n};\n\n/**\n * Checks if there are any tooltips or popovers on the mark\n * @param children\n * @returns\n */\nexport const isInteractive = (options: {\n\tchartPopovers?: ChartPopoverOptions[];\n\tchartTooltips?: ChartTooltipOptions[];\n\thasOnClick?: boolean;\n\tmetricRanges?: MetricRangeOptions[];\n\ttrendlines?: TrendlineOptions[];\n}): boolean => {\n\tconst hasOnClick = 'hasOnClick' in options && options.hasOnClick;\n\tconst metricRanges = ('metricRanges' in options && options.metricRanges) || [];\n\tconst trendlines = ('trendlines' in options && options.trendlines) || [];\n\n\treturn (\n\t\thasOnClick ||\n\t\thasPopover(options) ||\n\t\thasTooltip(options) ||\n\t\ttrendlines.some((trendline) => trendline.displayOnHover) ||\n\t\tmetricRanges.some((metricRange) => metricRange.displayOnHover)\n\t);\n};\n\nexport const hasPopover = (options: { chartPopovers?: ChartPopoverOptions[] }): boolean =>\n\tBoolean('chartPopovers' in options && options.chartPopovers?.length);\n\nexport const hasTooltip = (options: { chartTooltips?: ChartTooltipOptions[] }): boolean =>\n\tBoolean('chartTooltips' in options && options.chartTooltips?.length);\n\n/**\n * Gets the color encoding\n * @param color\n * @param colorScheme\n * @param colorScaleType\n * @returns ColorValueRef\n */\nexport const getColorProductionRule = (\n\tcolor: ColorFacet | DualFacet,\n\tcolorScheme: ColorScheme,\n\tcolorScaleType: 'linear' | 'ordinal' = 'ordinal'\n): ColorValueRef => {\n\tconst colorScaleName = colorScaleType === 'linear' ? LINEAR_COLOR_SCALE : COLOR_SCALE;\n\tif (Array.isArray(color)) {\n\t\treturn {\n\t\t\tsignal: `scale('colors', datum.${color[0]})[indexof(domain('secondaryColor'), datum.${color[1]})% length(scale('colors', datum.${color[0]}))]`,\n\t\t};\n\t}\n\tif (typeof color === 'string') {\n\t\treturn { scale: colorScaleName, field: color };\n\t}\n\treturn { value: getColorValue(color.value, colorScheme) };\n};\n\n/**\n * gets the color encoding in a signal string format\n * @param color\n * @param colorScheme\n * @param colorScaleType\n * @returns string\n */\nexport const getColorProductionRuleSignalString = (\n\tcolor: ColorFacet | DualFacet,\n\tcolorScheme: ColorScheme,\n\tcolorScaleType: 'linear' | 'ordinal' = 'ordinal'\n): string => {\n\tconst colorRule = getColorProductionRule(color, colorScheme, colorScaleType);\n\tif ('signal' in colorRule) {\n\t\treturn colorRule.signal;\n\t}\n\tif ('scale' in colorRule && 'field' in colorRule) {\n\t\treturn `scale('${colorRule.scale}', datum.${colorRule.field})`;\n\t}\n\tif ('value' in colorRule && colorRule.value) {\n\t\treturn `'${colorRule.value}'`;\n\t}\n\treturn '';\n};\n\nexport const getLineWidthProductionRule = (\n\tlineWidth: LineWidthFacet | DualFacet | undefined\n): NumericValueRef | undefined => {\n\tif (!lineWidth) return;\n\tif (Array.isArray(lineWidth)) {\n\t\t// 2d key reference for setting line width\n\t\treturn {\n\t\t\tsignal: `scale('lineWidths', datum.${lineWidth[0]})[indexof(domain('secondaryLineWidth'), datum.${lineWidth[1]})% length(scale('lineWidths', datum.${lineWidth[0]}))]`,\n\t\t};\n\t}\n\t// key reference for setting line width\n\tif (typeof lineWidth === 'string') {\n\t\treturn { scale: LINE_WIDTH_SCALE, field: lineWidth };\n\t}\n\t// static value for setting line width\n\treturn { value: getLineWidthPixelsFromLineWidth(lineWidth.value) };\n};\n\nexport const getOpacityProductionRule = (opacity: OpacityFacet | DualFacet): { signal: string } | { value: number } => {\n\tif (Array.isArray(opacity)) {\n\t\treturn {\n\t\t\tsignal: `scale('opacities', datum.${opacity[0]})[indexof(domain('secondaryOpacity'), datum.${opacity[1]})% length(scale('opacities', datum.${opacity[0]}))]`,\n\t\t};\n\t}\n\tif (typeof opacity === 'string') {\n\t\treturn { signal: `scale('${OPACITY_SCALE}', datum.${opacity})` };\n\t}\n\treturn { value: opacity.value };\n};\n\nexport const getSymbolSizeProductionRule = (symbolSize: SymbolSizeFacet): NumericValueRef => {\n\t// key reference for setting symbol size\n\tif (typeof symbolSize === 'string') {\n\t\treturn { scale: SYMBOL_SIZE_SCALE, field: symbolSize };\n\t}\n\t// static value for setting symbol size\n\treturn { value: getVegaSymbolSizeFromRscSymbolSize(symbolSize.value) };\n};\n\nexport const getStrokeDashProductionRule = (lineType: LineTypeFacet | DualFacet): ArrayValueRef => {\n\tif (Array.isArray(lineType)) {\n\t\treturn {\n\t\t\tsignal: `scale('lineTypes', datum.${lineType[0]})[indexof(domain('secondaryLineType'), datum.${lineType[1]})% length(scale('lineTypes', datum.${lineType[0]}))]`,\n\t\t};\n\t}\n\tif (typeof lineType === 'string') {\n\t\treturn { scale: LINE_TYPE_SCALE, field: lineType };\n\t}\n\treturn { value: getStrokeDashFromLineType(lineType.value) };\n};\n\nexport const getHighlightOpacityValue = (\n\topacityValue: { signal: string } | { value: number } = DEFAULT_OPACITY_RULE\n): NumericValueRef => {\n\tif ('signal' in opacityValue) {\n\t\treturn { signal: `${opacityValue.signal} / ${HIGHLIGHT_CONTRAST_RATIO}` };\n\t}\n\treturn { value: opacityValue.value / HIGHLIGHT_CONTRAST_RATIO };\n};\n\n/**\n * gets the correct x encoding for marks that support scaleType\n * @param scaleType\n * @param dimension\n * @returns x encoding\n */\nexport const getXProductionRule = (scaleType: ScaleType, dimension: string): NumericValueRef => {\n\tconst scale = getScaleName('x', scaleType);\n\tif (scaleType === 'time') {\n\t\treturn { scale, field: DEFAULT_TRANSFORMED_TIME_DIMENSION };\n\t}\n\treturn { scale, field: dimension };\n};\n\n/**\n * Gets the y encoding for marks\n * @param metricAxis\n * @param metric\n * @returns y encoding\n */\nexport const getYProductionRule = (metricAxis: string | undefined, metric: string): NumericValueRef => {\n\treturn { scale: metricAxis || 'yLinear', field: metric };\n};\n\n/**\n * Gets the points used for the voronoi calculation\n * @param dataSource the name of the data source that will be used in the voronoi calculation\n * @param dimension the dimension for the x encoding\n * @param metric the metric for the y encoding\n * @param name the name of the component the voronoi is associated with, i.e. `scatter0`\n * @param scaleType the scale type for the x encoding\n * @returns SymbolMark\n */\nexport const getPointsForVoronoi = (\n\tdataSource: string,\n\tdimension: string,\n\tmetric: string,\n\tname: string,\n\tscaleType: ScaleType,\n\tmetricAxis?: string\n): SymbolMark => {\n\treturn {\n\t\tname: `${name}_pointsForVoronoi`,\n\t\tdescription: `${name}_pointsForVoronoi`,\n\t\ttype: 'symbol',\n\t\tfrom: { data: dataSource },\n\t\tinteractive: false,\n\t\tencode: {\n\t\t\tenter: {\n\t\t\t\ty: getYProductionRule(metricAxis, metric),\n\t\t\t\tfill: { value: 'transparent' },\n\t\t\t\tstroke: { value: 'transparent' },\n\t\t\t},\n\t\t\tupdate: {\n\t\t\t\tx: getXProductionRule(scaleType, dimension),\n\t\t\t},\n\t\t},\n\t};\n};\n\n/**\n * Gets the voronoi path used for tooltips and popovers\n * @param markOptions\n * @param dataSource name of the point data source the voronoi is based on\n * @returns PathMark\n */\nexport const getVoronoiPath = (markOptions: LineMarkOptions | ScatterSpecOptions, dataSource: string): PathMark => {\n\tconst { chartPopovers, chartTooltips, name: markName } = markOptions;\n\tconst hasOnClick = 'hasOnClick' in markOptions && markOptions.hasOnClick;\n\treturn {\n\t\tname: `${markName}_voronoi`,\n\t\tdescription: `${markName}_voronoi`,\n\t\ttype: 'path',\n\t\tfrom: { data: dataSource },\n\t\tencode: {\n\t\t\tenter: {\n\t\t\t\tfill: { value: 'transparent' },\n\t\t\t\tstroke: { value: 'transparent' },\n\t\t\t\tisVoronoi: { value: true },\n\t\t\t\ttooltip: getTooltip(chartTooltips ?? [], markName, true),\n\t\t\t},\n\t\t\tupdate: {\n\t\t\t\tcursor: getCursor(chartPopovers ?? [], hasOnClick),\n\t\t\t},\n\t\t},\n\t\ttransform: [\n\t\t\t{\n\t\t\t\ttype: 'voronoi',\n\t\t\t\tx: `datum.x`,\n\t\t\t\ty: `datum.y`,\n\t\t\t\t// on initial render, width/height could be 0 which causes problems\n\t\t\t\tsize: [{ signal: 'max(width, 1)' }, { signal: 'max(height, 1)' }],\n\t\t\t},\n\t\t],\n\t};\n};\n\n/**\n * Gets the hover area for the mark\n * @param chartTooltips\n * @param dataSource the name of the data source that will be used in the hover area calculation\n * @param dimension the dimension for the x encoding\n * @param metric the metric for the y encoding\n * @param name the name of the component the hover area is associated with, i.e. `scatter0`\n * @param scaleType the scale type for the x encoding\n * @returns GroupMark\n */\nexport const getItemHoverArea = (\n\tchartTooltips: ChartTooltipOptions[],\n\tdataSource: string,\n\tdimension: string,\n\tmetric: string,\n\tname: string,\n\tscaleType: ScaleType,\n\tmetricAxis?: string\n): GroupMark => {\n\treturn {\n\t\tname: `${name}_hoverGroup`,\n\t\ttype: 'group',\n\t\tmarks: getHoverSizes().map((size, i) => ({\n\t\t\tname: getHoverMarkName(name, i),\n\t\t\ttype: 'symbol',\n\t\t\tfrom: { data: dataSource },\n\t\t\tencode: {\n\t\t\t\tenter: {\n\t\t\t\t\tshape: { value: HOVER_SHAPE },\n\t\t\t\t\ty: getYProductionRule(metricAxis, metric),\n\t\t\t\t\tfill: { value: 'transparent' },\n\t\t\t\t\tstroke: { value: 'transparent' },\n\t\t\t\t\ttooltip: getTooltip(chartTooltips, name, false),\n\t\t\t\t\tsize: getHoverSizeSignal(size),\n\t\t\t\t},\n\t\t\t\tupdate: {\n\t\t\t\t\tx: getXProductionRule(scaleType, dimension),\n\t\t\t\t},\n\t\t\t},\n\t\t})),\n\t};\n};\n\nexport const getHoverMarkName = (name: string, index: number): string => `${name}_hover${index}`;\n\nexport const getHoverSizes = (): number[] => [...new Array(HOVER_SHAPE_COUNT)].map((_, i) => HOVER_SIZE / 2 ** i);\n\nexport const getHoverMarkNames = (markName: string): string[] =>\n\t[...new Array(HOVER_SHAPE_COUNT)].map((_, i) => getHoverMarkName(markName, i));\n\nconst getHoverSizeSignal = (size: number): SignalRef => ({\n\tsignal: `${size} * max(width, 1) / 1000`,\n});\n\n/**\n * Gets the opacity for the mark (used to highlight marks).\n * This will take into account if there are any tooltips or popovers on the mark.\n * @param options\n * @returns\n */\nexport const getMarkOpacity = (options: BarSpecOptions | DonutSpecOptions): ({ test?: string } & NumericValueRef)[] => {\n\tconst { highlightedItem, idKey, name: markName } = options;\n\tconst rules: ({ test?: string } & NumericValueRef)[] = [DEFAULT_OPACITY_RULE];\n\t// if there aren't any interactive components, then we don't need to add special opacity rules\n\tif (!isInteractive(options) && highlightedItem === undefined) {\n\t\treturn rules;\n\t}\n\n\t// if a bar is hovered/selected, all other bars should have reduced opacity\n\taddHighlightMarkOpacityRules(rules, options);\n\tif (hasPopover(options)) {\n\t\treturn [\n\t\t\t{\n\t\t\t\ttest: `!isValid(${SELECTED_GROUP}) && ${SELECTED_ITEM} && ${SELECTED_ITEM} !== datum.${idKey}`,\n\t\t\t\tvalue: 1 / HIGHLIGHT_CONTRAST_RATIO,\n\t\t\t},\n\t\t\t{ test: `isValid(${SELECTED_ITEM}) && ${SELECTED_ITEM} === datum.${idKey}`, ...DEFAULT_OPACITY_RULE },\n\t\t\t{\n\t\t\t\ttest: `isValid(${SELECTED_GROUP}) && ${SELECTED_GROUP} === datum.${markName}_selectedGroupId`,\n\t\t\t\tvalue: 1,\n\t\t\t},\n\t\t\t{\n\t\t\t\ttest: `isValid(${SELECTED_GROUP}) && ${SELECTED_GROUP} !== datum.${markName}_selectedGroupId`,\n\t\t\t\tvalue: 1 / HIGHLIGHT_CONTRAST_RATIO,\n\t\t\t},\n\t\t\t...rules,\n\t\t];\n\t}\n\treturn rules;\n};\n\nexport const getInteractiveMarkName = (\n\toptions: {\n\t\tchartPopovers?: ChartPopoverOptions[];\n\t\tchartTooltips?: ChartTooltipOptions[];\n\t\thasOnClick?: boolean;\n\t\thighlightedItem?: HighlightedItem;\n\t\tmetricRanges?: MetricRangeOptions[];\n\t\ttrendlines?: TrendlineOptions[];\n\t},\n\tname: string\n): string | undefined => {\n\t// if the line has an interactive component, this line is the target for the interactive component\n\tif (isInteractive(options) || options.highlightedItem !== undefined) {\n\t\treturn name;\n\t}\n\t// if there is a trendline with an interactive component on the line, then the trendline is the target for the interactive component\n\tif ('trendlines' in options && options.trendlines?.some((trendline) => isInteractive(trendline))) {\n\t\treturn `${name}Trendline`;\n\t}\n};\n","/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport { AreaMark, GroupMark, LineMark, Signal, SourceData } from 'vega';\n\nimport {\n\tDEFAULT_METRIC,\n\tFILTERED_TABLE,\n\tHIGHLIGHTED_SERIES,\n\tSELECTED_SERIES,\n\tSERIES_ID,\n} from '@spectrum-charts/constants';\n\nimport { AreaMarkOptions, getAreaMark } from '../area/areaUtils';\nimport { getLineMark } from '../line/lineMarkUtils';\nimport { LineMarkOptions } from '../line/lineUtils';\nimport { addHighlightedSeriesSignalEvents } from '../signal/signalSpecBuilder';\nimport { getFacetsFromOptions } from '../specUtils';\nimport { LineSpecOptions, MetricRangeOptions, MetricRangeSpecOptions } from '../types';\n\nexport type MetricRangeParentOptions = LineSpecOptions;\n\nexport const getMetricRanges = (markOptions: MetricRangeParentOptions): MetricRangeSpecOptions[] => {\n\treturn markOptions.metricRanges.map((metricRange, index) =>\n\t\tapplyMetricRangeOptionDefaults(metricRange, markOptions.name, index)\n\t);\n};\n\nexport const applyMetricRangeOptionDefaults = (\n\t{\n\t\tchartTooltips = [],\n\t\tlineType = 'dashed',\n\t\tlineWidth = 'S',\n\t\trangeOpacity = 0.2,\n\t\tmetric = DEFAULT_METRIC,\n\t\tdisplayOnHover = false,\n\t\t...options\n\t}: MetricRangeOptions,\n\tmarkName: string,\n\tindex: number\n): MetricRangeSpecOptions => ({\n\tchartTooltips,\n\tlineType,\n\tlineWidth,\n\tname: `${markName}MetricRange${index}`,\n\trangeOpacity,\n\tmetric,\n\tdisplayOnHover,\n\t...options,\n});\n\n/**\n * gets the metric range group mark including the metric range line and area marks.\n * @param lineMarkOptions\n */\nexport const getMetricRangeGroupMarks = (lineMarkOptions: LineSpecOptions): GroupMark[] => {\n\tconst { color, lineType } = lineMarkOptions;\n\tconst { facets } = getFacetsFromOptions({ color, lineType });\n\n\tconst marks: GroupMark[] = [];\n\tconst metricRanges = getMetricRanges(lineMarkOptions);\n\n\tfor (const metricRangeOptions of metricRanges) {\n\t\tconst { displayOnHover, name } = metricRangeOptions;\n\t\t// if displayOnHover is true, use the highlightedData source, otherwise use the filtered table\n\t\tconst data = displayOnHover ? `${name}_highlightedData` : FILTERED_TABLE;\n\t\tmarks.push({\n\t\t\tname: `${name}_group`,\n\t\t\ttype: 'group',\n\t\t\tclip: true,\n\t\t\tfrom: {\n\t\t\t\tfacet: {\n\t\t\t\t\tname: `${name}_facet`,\n\t\t\t\t\tdata,\n\t\t\t\t\tgroupby: facets,\n\t\t\t\t},\n\t\t\t},\n\t\t\tmarks: getMetricRangeMark(lineMarkOptions, metricRangeOptions),\n\t\t});\n\t}\n\n\treturn marks;\n};\n\n/**\n * gets the area and line marks for the metric range by combining line and metric range options.\n * @param lineMarkOptions\n * @param metricRangeOptions\n */\nexport const getMetricRangeMark = (\n\tlineMarkOptions: LineSpecOptions,\n\tmetricRangeOptions: MetricRangeSpecOptions\n): (LineMark | AreaMark)[] => {\n\tconst areaOptions: AreaMarkOptions = {\n\t\tname: `${metricRangeOptions.name}_area`,\n\t\tcolor: lineMarkOptions.color,\n\t\tcolorScheme: lineMarkOptions.colorScheme,\n\t\topacity: metricRangeOptions.rangeOpacity,\n\t\tmetricStart: metricRangeOptions.metricStart,\n\t\tmetricEnd: metricRangeOptions.metricEnd,\n\t\tisStacked: false,\n\t\tscaleType: 'time',\n\t\tdimension: lineMarkOptions.dimension,\n\t\tisMetricRange: true,\n\t\tparentName: lineMarkOptions.name,\n\t\tdisplayOnHover: metricRangeOptions.displayOnHover,\n\t};\n\tconst lineOptions: LineMarkOptions = {\n\t\t...lineMarkOptions,\n\t\tname: `${metricRangeOptions.name}_line`,\n\t\tcolor: metricRangeOptions.color ? { value: metricRangeOptions.color } : lineMarkOptions.color,\n\t\tmetric: metricRangeOptions.metric,\n\t\tlineType: { value: metricRangeOptions.lineType },\n\t\tlineWidth: { value: metricRangeOptions.lineWidth },\n\t\tdisplayOnHover: metricRangeOptions.displayOnHover,\n\t};\n\n\tconst dataSource = `${metricRangeOptions.name}_facet`;\n\tconst lineMark = getLineMark(lineOptions, dataSource);\n\tconst areaMark = getAreaMark(areaOptions, dataSource);\n\n\treturn [lineMark, areaMark];\n};\n\n/**\n * gets the data source for the metricRange\n * @param markOptions\n */\nexport const getMetricRangeData = (markOptions: LineSpecOptions): SourceData[] => {\n\tconst data: SourceData[] = [];\n\tconst metricRanges = getMetricRanges(markOptions);\n\n\tfor (const metricRangeOptions of metricRanges) {\n\t\tconst { displayOnHover, name } = metricRangeOptions;\n\t\t// if displayOnHover is true, add a data source for the highlighted data\n\t\tif (displayOnHover) {\n\t\t\tdata.push({\n\t\t\t\tname: `${name}_highlightedData`,\n\t\t\t\tsource: FILTERED_TABLE,\n\t\t\t\ttransform: [\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: 'filter',\n\t\t\t\t\t\texpr: `isValid(${HIGHLIGHTED_SERIES}) && ${HIGHLIGHTED_SERIES} === datum.${SERIES_ID} || isValid(${SELECTED_SERIES}) && ${SELECTED_SERIES} === datum.${SERIES_ID}`,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t});\n\t\t}\n\t}\n\n\treturn data;\n};\n\n/**\n * gets the signals for the metricRange\n * @param markOptions\n */\nexport const getMetricRangeSignals = (markOptions: LineSpecOptions): Signal[] => {\n\tconst signals: Signal[] = [];\n\tconst { name: markName } = markOptions;\n\tconst metricRanges = getMetricRanges(markOptions);\n\n\tif (metricRanges.length) {\n\t\taddHighlightedSeriesSignalEvents(signals, `${markName}_voronoi`, 2);\n\t}\n\n\treturn signals;\n};\n","/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport { produce } from 'immer';\nimport { OrdinalScale, Scale, ScaleData, ScaleMultiFieldsRef, SignalRef } from 'vega';\n\nimport { DISCRETE_PADDING, FILTERED_TABLE, LINEAR_PADDING, PADDING_RATIO, TABLE } from '@spectrum-charts/constants';\nimport { toCamelCase } from '@spectrum-charts/utils';\n\nimport { getDimensionField } from '../specUtils';\nimport { DualFacet, FacetRef, FacetType, Orientation } from '../types';\n\ntype AxisType = 'x' | 'y';\ntype SupportedScaleType = 'linear' | 'point' | 'band' | 'time' | 'ordinal';\n\n/**\n * Gets the first index for the given scale type and axis.\n *\n * If the scale doesn't exist, it gets created and the index of the new scale is returned.\n *\n * NOTE: this should only be called from a 'produce' function since it mutates the scales\n */\nexport const getScaleIndexByType = (\n\tscales: Scale[],\n\ttype: SupportedScaleType,\n\taxis: AxisType,\n\tscaleName?: string\n): number => {\n\tconst name = scaleName || toCamelCase(`${axis} ${type}`);\n\tlet index = scales.findIndex((scale) => scale.name === name);\n\tif (index === -1) {\n\t\tindex = scales.length;\n\t\tscales.push(generateScale(type, axis, { name }));\n\t}\n\treturn index;\n};\n\n/**\n * Gets the first index for the given scale name.\n *\n * If the scale doesn't exist, it gets created and the index of the new scale is returned.\n *\n * NOTE: this should only be called from a 'produce' function since it mutates the scales\n */\nexport const getScaleIndexByName = (scales: Scale[], name: string, type?: SupportedScaleType): number => {\n\tlet index = scales.findIndex((scale) => scale.name === name);\n\tif (index === -1) {\n\t\tindex = scales.length;\n\t\tscales.push({ name, type });\n\t}\n\treturn index;\n};\n\nexport const addDomainFields = produce<Scale, [string[]]>((scale, values) => {\n\tvalues.forEach((value) => {\n\t\tif (isScaleMultiFieldsRef(scale.domain)) {\n\t\t\t// if a fields already exist but not this value field, push the value field onto it\n\t\t\tif (!scale.domain.fields.includes(value)) {\n\t\t\t\tscale.domain.fields.push(value);\n\t\t\t}\n\t\t} else {\n\t\t\t// if there isn't a domain yet, set it up\n\t\t\tscale.domain = {\n\t\t\t\tdata: TABLE,\n\t\t\t\tfields: [value],\n\t\t\t};\n\t\t}\n\t});\n\treturn scale;\n});\n\nexport const addContinuousDimensionScale = (\n\tscales: Scale[],\n\t{ scaleType, dimension, padding }: { scaleType: SupportedScaleType; dimension: string; padding?: number }\n) => {\n\tconst index = getScaleIndexByType(scales, scaleType, 'x');\n\tconst fields = [getDimensionField(dimension, scaleType)];\n\tscales[index] = addDomainFields(scales[index], fields);\n\tif (padding !== undefined) {\n\t\tscales[index] = overridePadding(scales[index], padding);\n\t}\n};\n\nconst overridePadding = produce<Scale, [number]>((scale, padding) => {\n\tif ('padding' in scale) {\n\t\tscale.padding = padding;\n\t}\n\tif ('paddingOuter' in scale) {\n\t\tscale.paddingOuter = padding;\n\t}\n});\n\n/**\n * Checks if the metric scale already exists\n * If it does, it adds the new metricKeys to the domain\n * If it doesn't, it creates a new scale and adds the metricKeys to the domain\n * @param scales\n * @param values\n * @param metricAxis\n * @param scaleName\n */\nexport const addMetricScale = (\n\tscales: Scale[],\n\tmetricKeys: string[],\n\tmetricAxis: AxisType = 'y',\n\tscaleName?: string\n) => {\n\tconst index = getScaleIndexByType(scales, 'linear', metricAxis, scaleName);\n\tscales[index] = addDomainFields(scales[index], metricKeys);\n};\n\n/**\n * Generates a metric scale and returns it\n * NOTE: Does not check if the metric scale already exists\n * @param metricKeys\n * @param metricAxis\n * @returns\n */\nexport const getMetricScale = (metricKeys: string[], metricAxis: AxisType, chartOrientation: Orientation): Scale => {\n\tlet scale = getDefaultScale('linear', metricAxis, chartOrientation);\n\tscale = addDomainFields(scale, metricKeys);\n\treturn scale;\n};\n\n/**\n * adds the field to the facet scale domain if it isn't a static value\n * @param scales\n * @param facetType\n * @param facetValue\n */\nexport const addFieldToFacetScaleDomain = (\n\tscales: Scale[],\n\tfacetType: FacetType,\n\tfacetValue: FacetRef<string | number | number[]> | DualFacet | undefined\n) => {\n\t// if facetValue is a string or an array of strings, it is a field reference and should be added the facet scale domain\n\tif (typeof facetValue === 'string' || (Array.isArray(facetValue) && facetValue.length)) {\n\t\tconst index = getScaleIndexByName(scales, facetType);\n\t\tconst facetField = Array.isArray(facetValue) ? facetValue[0] : facetValue;\n\t\tscales[index] = addDomainFields(scales[index], [facetField]);\n\t}\n};\n\nexport const generateScale = (type: SupportedScaleType, axis: AxisType, options?: Partial<Scale>): Scale => {\n\treturn {\n\t\t...getDefaultScale(type, axis),\n\t\t...options,\n\t} as unknown as Scale;\n};\n\nexport const getDefaultScale = (\n\tscaleType: SupportedScaleType,\n\taxis: AxisType,\n\tchartOrientation: Orientation = 'vertical'\n): Scale => {\n\tconst orientationToAxis: { [key in Orientation]: AxisType } = {\n\t\tvertical: 'x',\n\t\thorizontal: 'y',\n\t};\n\tconst isDimensionAxis = axis === orientationToAxis[chartOrientation];\n\n\tconst scale: Scale = {\n\t\tname: toCamelCase(`${axis} ${scaleType}`),\n\t\ttype: scaleType,\n\t\trange: axis === 'x' ? 'width' : 'height',\n\t\tdomain: { data: FILTERED_TABLE, fields: [] },\n\t\t// if this is the dimension axis, add padding\n\t\t...(isDimensionAxis ? getPadding(scaleType) : {}),\n\t};\n\tif (scale.type === 'ordinal') {\n\t\tconst { name, type, domain } = scale;\n\t\treturn { name, type, domain };\n\t}\n\t// metric axis properties\n\tif (scale.type === 'linear' && !isDimensionAxis) {\n\t\treturn { ...scale, nice: true, zero: true };\n\t}\n\treturn scale;\n};\n\n/**\n * Sets the appropriate axis padding based on type.\n *\n * Discrete scales use a relative value where padding is step size * padding [0-1].\n * Continuous scales use a pixel value for padding.\n */\nexport const getPadding = (type: SupportedScaleType | 'band') => {\n\tswitch (type) {\n\t\tcase 'band': {\n\t\t\tconst { paddingInner, paddingOuter } = getBandPadding(PADDING_RATIO);\n\t\t\treturn { paddingInner, paddingOuter };\n\t\t}\n\t\tcase 'linear':\n\t\tcase 'time':\n\t\t\treturn { padding: LINEAR_PADDING };\n\t\tcase 'point':\n\t\t\treturn { paddingOuter: DISCRETE_PADDING };\n\t\tdefault:\n\t\t\treturn {};\n\t}\n};\n\nexport const getBandPadding = (paddingRatio: number, paddingOuter?: number) => {\n\tconst paddingInner = paddingRatio;\n\treturn {\n\t\tpaddingInner,\n\t\tpaddingOuter: paddingOuter === undefined ? DISCRETE_PADDING - (1 - paddingInner) / 2 : paddingOuter,\n\t};\n};\n\n/**\n * Gets the name of the scale based on the axis and type\n * @param axis\n * @param type\n * @returns scale name\n */\nexport const getScaleName = (axis: AxisType, type: SupportedScaleType) => toCamelCase(`${axis} ${type}`);\n\nexport const getOrdinalScale = (name: string, range: OrdinalScale['range']): OrdinalScale => ({\n\tname,\n\ttype: 'ordinal',\n\trange,\n\tdomain: { data: TABLE, fields: [] },\n});\n\nconst isScaleMultiFieldsRef = (\n\tdomain: (null | string | number | boolean | SignalRef)[] | ScaleData | SignalRef | undefined\n): domain is ScaleMultiFieldsRef => {\n\treturn Boolean(domain && !Array.isArray(domain) && 'data' in domain && 'fields' in domain);\n};\n","/*\n * Copyright 2024 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport { produce } from 'immer';\nimport { GroupMark, Mark, NumericValueRef, SymbolMark } from 'vega';\n\nimport {\n\tDEFAULT_OPACITY_RULE,\n\tFILTERED_TABLE,\n\tHIGHLIGHT_CONTRAST_RATIO,\n\tSELECTED_ITEM,\n} from '@spectrum-charts/constants';\nimport { spectrumColors } from '@spectrum-charts/themes';\n\nimport { addHighlightMarkOpacityRules } from '../chartTooltip/chartTooltipUtils';\nimport {\n\tgetColorProductionRule,\n\tgetLineWidthProductionRule,\n\tgetOpacityProductionRule,\n\tgetPointsForVoronoi,\n\tgetStrokeDashProductionRule,\n\tgetSymbolSizeProductionRule,\n\tgetVoronoiPath,\n\tgetXProductionRule,\n\thasPopover,\n\tisInteractive,\n} from '../marks/markUtils';\nimport { getScatterPathMarks } from '../scatterPath/scatterPathUtils';\nimport { getTrendlineMarks } from '../trendline';\nimport { ScatterSpecOptions, SymbolSizeFacet } from '../types';\n\nexport const addScatterMarks = produce<Mark[], [ScatterSpecOptions]>((marks, options) => {\n\tconst { name } = options;\n\n\tconst scatterGroup: GroupMark = {\n\t\tname: `${name}_group`,\n\t\ttype: 'group',\n\t\tmarks: [getScatterMark(options), ...getScatterHoverMarks(options), ...getScatterSelectMarks(options)],\n\t};\n\n\tmarks.push(...getScatterPathMarks(options));\n\tmarks.push(scatterGroup);\n\tmarks.push(...getTrendlineMarks(options));\n});\n\n/**\n * Gets the primary scatter mark\n * @param scatterOptions scatterSpecOptions\n * @returns SymbolMark\n */\nexport const getScatterMark = (options: ScatterSpecOptions): SymbolMark => {\n\tconst {\n\t\tcolor,\n\t\tcolorScaleType,\n\t\tcolorScheme,\n\t\tdimension,\n\t\tdimensionScaleType,\n\t\tlineType,\n\t\tlineWidth,\n\t\tmetric,\n\t\tname,\n\t\topacity,\n\t\tsize,\n\t} = options;\n\treturn {\n\t\tname,\n\t\tdescription: name,\n\t\ttype: 'symbol',\n\t\tfrom: {\n\t\t\tdata: FILTERED_TABLE,\n\t\t},\n\t\tencode: {\n\t\t\tenter: {\n\t\t\t\t/**\n\t\t\t\t * the blend mode makes it possible to tell when there are overlapping points\n\t\t\t\t * in light mode, the points are darker when they overlap (multiply)\n\t\t\t\t * in dark mode, the points are lighter when they overlap (screen)\n\t\t\t\t */\n\t\t\t\tblend: { value: colorScheme === 'light' ? 'multiply' : 'screen' },\n\t\t\t\tfill: getColorProductionRule(color, colorScheme, colorScaleType),\n\t\t\t\tfillOpacity: getOpacityProductionRule(opacity),\n\t\t\t\tshape: { value: 'circle' },\n\t\t\t\tsize: getSymbolSizeProductionRule(size),\n\t\t\t\tstrokeDash: getStrokeDashProductionRule(lineType),\n\t\t\t\tstrokeWidth: getLineWidthProductionRule(lineWidth),\n\t\t\t\tstroke: getColorProductionRule(color, colorScheme, colorScaleType),\n\t\t\t},\n\t\t\tupdate: {\n\t\t\t\topacity: getOpacity(options),\n\t\t\t\tx: getXProductionRule(dimensionScaleType, dimension),\n\t\t\t\ty: { scale: 'yLinear', field: metric },\n\t\t\t},\n\t\t},\n\t};\n};\n\n/**\n * Gets the opacity production rule for the scatter mark.\n * This is used for highlighting points on hover and selection.\n * @param scatterOptions ScatterSpecOptions\n * @returns opacity production rule\n */\nexport const getOpacity = (scatterOptions: ScatterSpecOptions): ({ test?: string } & NumericValueRef)[] => {\n\tconst { highlightedItem, idKey } = scatterOptions;\n\tif (!isInteractive(scatterOptions) && highlightedItem === undefined) {\n\t\treturn [DEFAULT_OPACITY_RULE];\n\t}\n\t// if a point is hovered or selected, all other points should be reduced opacity\n\tconst fadedValue = 1 / HIGHLIGHT_CONTRAST_RATIO;\n\n\tconst rules: ({ test?: string } & NumericValueRef)[] = [];\n\taddHighlightMarkOpacityRules(rules, scatterOptions);\n\tif (hasPopover(scatterOptions)) {\n\t\trules.push({\n\t\t\ttest: `isValid(${SELECTED_ITEM}) && ${SELECTED_ITEM} !== datum.${idKey}`,\n\t\t\tvalue: fadedValue,\n\t\t});\n\t}\n\n\treturn [...rules, DEFAULT_OPACITY_RULE];\n};\n\n/**\n * Gets the vornoi path mark if there are any interactive children\n * @param scatterOptions ScatterSpecOptions\n * @returns Mark[]\n */\nexport const getScatterHoverMarks = (scatterOptions: ScatterSpecOptions): Mark[] => {\n\tconst { dimension, dimensionScaleType, highlightedItem, metric, name } = scatterOptions;\n\tif (!isInteractive(scatterOptions) && highlightedItem === undefined) {\n\t\treturn [];\n\t}\n\n\treturn [\n\t\tgetPointsForVoronoi(`${FILTERED_TABLE}ForTooltip`, dimension, metric, name, dimensionScaleType),\n\t\tgetVoronoiPath(scatterOptions, `${name}_pointsForVoronoi`),\n\t];\n};\n\nconst getScatterSelectMarks = (scatterOptions: ScatterSpecOptions): SymbolMark[] => {\n\tconst { dimension, dimensionScaleType, metric, name, size } = scatterOptions;\n\tif (!hasPopover(scatterOptions)) {\n\t\treturn [];\n\t}\n\treturn [\n\t\t{\n\t\t\tname: `${name}_selectRing`,\n\t\t\ttype: 'symbol',\n\t\t\tfrom: {\n\t\t\t\tdata: `${name}_selectedData`,\n\t\t\t},\n\t\t\tencode: {\n\t\t\t\tenter: {\n\t\t\t\t\tfill: { value: 'transparent' },\n\t\t\t\t\tshape: { value: 'circle' },\n\t\t\t\t\tsize: getSelectRingSize(size),\n\t\t\t\t\tstrokeWidth: { value: 2 },\n\t\t\t\t\tstroke: { value: spectrumColors.light['static-blue'] },\n\t\t\t\t},\n\t\t\t\tupdate: {\n\t\t\t\t\tx: getXProductionRule(dimensionScaleType, dimension),\n\t\t\t\t\ty: { scale: 'yLinear', field: metric },\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t];\n};\n\n/**\n * Gets the size of the select ring based on the size of the scatter points\n * @param size SymbolSizeFacet\n * @returns NumericValueRef\n */\nexport const getSelectRingSize = (size: SymbolSizeFacet): NumericValueRef => {\n\tconst baseSize = getSymbolSizeProductionRule(size);\n\tif ('value' in baseSize && typeof baseSize.value === 'number') {\n\t\t// the select ring is 4px widr and taller\n\t\t// to calculate: (sqrt(baseSize) + 4)^2\n\t\treturn { value: Math.pow(Math.sqrt(baseSize.value) + 4, 2) };\n\t}\n\tif ('scale' in baseSize && 'field' in baseSize) {\n\t\treturn { signal: `pow(sqrt(scale('${baseSize.scale}', datum.${baseSize.field})) + 4, 2)` };\n\t}\n\treturn baseSize;\n};\n","/*\n * Copyright 2024 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport { produce } from 'immer';\nimport { Data, Scale, Signal, Spec } from 'vega';\n\nimport {\n\tCOLOR_SCALE,\n\tDEFAULT_COLOR_SCHEME,\n\tDEFAULT_DIMENSION_SCALE_TYPE,\n\tDEFAULT_LINEAR_DIMENSION,\n\tDEFAULT_METRIC,\n\tFILTERED_TABLE,\n\tLINEAR_COLOR_SCALE,\n\tLINE_TYPE_SCALE,\n\tLINE_WIDTH_SCALE,\n\tOPACITY_SCALE,\n\tSELECTED_ITEM,\n\tSYMBOL_SIZE_SCALE,\n} from '@spectrum-charts/constants';\nimport { toCamelCase } from '@spectrum-charts/utils';\n\nimport { addTooltipData, addTooltipSignals } from '../chartTooltip/chartTooltipUtils';\nimport { addTimeTransform, getFilteredTooltipData, getTableData } from '../data/dataUtils';\nimport { getInteractiveMarkName, hasPopover, isInteractive } from '../marks/markUtils';\nimport { addContinuousDimensionScale, addFieldToFacetScaleDomain, addMetricScale } from '../scale/scaleSpecBuilder';\nimport { setScatterPathScales } from '../scatterPath';\nimport { addHighlightedItemSignalEvents } from '../signal/signalSpecBuilder';\nimport { addTrendlineData, getTrendlineScales, setTrendlineSignals } from '../trendline';\nimport { ColorScheme, HighlightedItem, ScatterOptions, ScatterSpecOptions } from '../types';\nimport { addScatterMarks } from './scatterMarkUtils';\n\n/**\n * Adds all the necessary parts of a scatter to the spec\n * @param spec Spec\n * @param scatterOptions ScatterOptions\n */\nexport const addScatter = produce<\n\tSpec,\n\t[ScatterOptions & { colorScheme?: ColorScheme; highlightedItem?: HighlightedItem; index?: number; idKey: string }]\n>(\n\t(\n\t\tspec,\n\t\t{\n\t\t\tchartPopovers = [],\n\t\t\tchartTooltips = [],\n\t\t\tcolor = { value: 'categorical-100' },\n\t\t\tcolorScaleType = 'ordinal',\n\t\t\tcolorScheme = DEFAULT_COLOR_SCHEME,\n\t\t\tdimension = DEFAULT_LINEAR_DIMENSION,\n\t\t\tdimensionScaleType = DEFAULT_DIMENSION_SCALE_TYPE,\n\t\t\tindex = 0,\n\t\t\tlineType = { value: 'solid' },\n\t\t\tlineWidth = { value: 0 },\n\t\t\tmetric = DEFAULT_METRIC,\n\t\t\tname,\n\t\t\topacity = { value: 1 },\n\t\t\tscatterPaths = [],\n\t\t\tsize = { value: 'M' },\n\t\t\ttrendlines = [],\n\t\t\t...options\n\t\t}\n\t) => {\n\t\tconst scatterName = toCamelCase(name || `scatter${index}`);\n\t\t// put options back together now that all the defaults have been set\n\n\t\tconst scatterOptions: ScatterSpecOptions = {\n\t\t\tchartPopovers,\n\t\t\tchartTooltips,\n\t\t\tcolor,\n\t\t\tcolorScaleType,\n\t\t\tcolorScheme,\n\t\t\tdimension,\n\t\t\tdimensionScaleType,\n\t\t\tindex,\n\t\t\tinteractiveMarkName: getInteractiveMarkName(\n\t\t\t\t{ chartPopovers, chartTooltips, highlightedItem: options.highlightedItem, trendlines },\n\t\t\t\tscatterName\n\t\t\t),\n\t\t\tlineType,\n\t\t\tlineWidth,\n\t\t\tmetric,\n\t\t\tname: scatterName,\n\t\t\topacity,\n\t\t\tscatterPaths,\n\t\t\tsize,\n\t\t\ttrendlines,\n\t\t\t...options,\n\t\t};\n\n\t\tspec.data = addData(spec.data ?? [], scatterOptions);\n\t\tspec.signals = addSignals(spec.signals ?? [], scatterOptions);\n\t\tspec.scales = setScales(spec.scales ?? [], scatterOptions);\n\t\tspec.marks = addScatterMarks(spec.marks ?? [], scatterOptions);\n\t}\n);\n\nexport const addData = produce<Data[], [ScatterSpecOptions]>((data, scatterOptions) => {\n\tconst { chartTooltips, dimension, dimensionScaleType, highlightedItem, idKey, name } = scatterOptions;\n\tif (dimensionScaleType === 'time') {\n\t\tconst tableData = getTableData(data);\n\t\ttableData.transform = addTimeTransform(tableData.transform ?? [], dimension);\n\t}\n\n\tif (isInteractive(scatterOptions) || highlightedItem !== undefined) {\n\t\tdata.push(getFilteredTooltipData(chartTooltips));\n\t}\n\n\tif (hasPopover(scatterOptions)) {\n\t\tdata.push({\n\t\t\tname: `${name}_selectedData`,\n\t\t\tsource: FILTERED_TABLE,\n\t\t\ttransform: [\n\t\t\t\t{\n\t\t\t\t\ttype: 'filter',\n\t\t\t\t\texpr: `${SELECTED_ITEM} === datum.${idKey}`,\n\t\t\t\t},\n\t\t\t],\n\t\t});\n\t}\n\taddTooltipData(data, scatterOptions);\n\taddTrendlineData(data, scatterOptions);\n});\n\n/**\n * Adds the signals for scatter to the signals array\n * @param signals Signal[]\n * @param scatterOptions ScatterSpecOptions\n */\nexport const addSignals = produce<Signal[], [ScatterSpecOptions]>((signals, scatterOptions) => {\n\tconst { idKey, name } = scatterOptions;\n\t// trendline signals\n\tsetTrendlineSignals(signals, scatterOptions);\n\n\tif (!isInteractive(scatterOptions)) return;\n\t// interactive signals\n\taddHighlightedItemSignalEvents(signals, `${name}_voronoi`, idKey, 2);\n\taddTooltipSignals(signals, scatterOptions);\n});\n\n/**\n * Sets up all the scales for scatter on the scales array\n * @param scales Scale[]\n * @param scatterOptions ScatterSpecOptions\n */\nexport const setScales = produce<Scale[], [ScatterSpecOptions]>((scales, scatterOptions) => {\n\tconst { color, colorScaleType, dimension, dimensionScaleType, lineType, lineWidth, metric, opacity, size } =\n\t\tscatterOptions;\n\t// add dimension scale\n\taddContinuousDimensionScale(scales, { scaleType: dimensionScaleType, dimension });\n\t// add metric scale\n\taddMetricScale(scales, [metric]);\n\tif (colorScaleType === 'linear') {\n\t\t// add color to the color domain\n\t\taddFieldToFacetScaleDomain(scales, LINEAR_COLOR_SCALE, color);\n\t} else {\n\t\t// add color to the color domain\n\t\taddFieldToFacetScaleDomain(scales, COLOR_SCALE, color);\n\t}\n\t// add lineType to the lineType domain\n\taddFieldToFacetScaleDomain(scales, LINE_TYPE_SCALE, lineType);\n\t// add lineWidth to the lineWidth domain\n\taddFieldToFacetScaleDomain(scales, LINE_WIDTH_SCALE, lineWidth);\n\t// add opacity to the opacity domain\n\taddFieldToFacetScaleDomain(scales, OPACITY_SCALE, opacity);\n\t// add size to the size domain\n\taddFieldToFacetScaleDomain(scales, SYMBOL_SIZE_SCALE, size);\n\n\tsetScatterPathScales(scales, scatterOptions);\n\tscales.push(...getTrendlineScales(scatterOptions));\n});\n","/*\n * Copyright 2024 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport * from './scatterPathUtils';\n","/*\n * Copyright 2024 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport { GroupMark, NumericValueRef, Scale, TrailMark } from 'vega';\n\nimport {\n\tDEFAULT_OPACITY_RULE,\n\tFILTERED_TABLE,\n\tHIGHLIGHTED_ITEM,\n\tHIGHLIGHTED_SERIES,\n\tHIGHLIGHT_CONTRAST_RATIO,\n\tSELECTED_ITEM,\n\tSELECTED_SERIES,\n\tSYMBOL_PATH_WIDTH_SCALE,\n} from '@spectrum-charts/constants';\nimport { getColorValue } from '@spectrum-charts/themes';\n\nimport { getXProductionRule } from '../marks/markUtils';\nimport { addFieldToFacetScaleDomain } from '../scale/scaleSpecBuilder';\nimport { getFacetsFromOptions, getLineWidthPixelsFromLineWidth } from '../specUtils';\nimport { LineWidthFacet, ScatterPathOptions, ScatterPathSpecOptions, ScatterSpecOptions } from '../types';\n\n/**\n * Gets the path spec options, applying defaults.\n * @param scatterPathOptions\n * @param index\n * @param markName\n * @param colorScheme\n * @returns ScatterPathSpecOptions\n */\nexport const getScatterPathSpecOptions = (\n\t{\n\t\tcolor = 'gray-500',\n\t\tgroupBy,\n\t\tpathWidth = { value: 'M' },\n\t\topacity = 0.5,\n\t\t...scatterPathOptions\n\t}: ScatterPathOptions,\n\tindex: number,\n\t{\n\t\tcolor: scatterColor,\n\t\tcolorScheme,\n\t\tdimension,\n\t\tdimensionScaleType,\n\t\tlineType,\n\t\tmetric,\n\t\tname: scatterName,\n\t\topacity: scatterOpacity,\n\t\tsize,\n\t}: ScatterSpecOptions\n): ScatterPathSpecOptions => {\n\tconst { facets } = getFacetsFromOptions({ color: scatterColor, lineType, size, opacity: scatterOpacity });\n\treturn {\n\t\tcolor,\n\t\tcolorScheme,\n\t\tdimension,\n\t\tdimensionScaleType,\n\t\tgroupBy: groupBy ?? facets,\n\t\tmetric,\n\t\tindex,\n\t\tpathWidth,\n\t\tname: `${scatterName}Path${index}`,\n\t\topacity,\n\t\t...scatterPathOptions,\n\t};\n};\n\n/**\n * Gets all the paths on a scatter\n * @param scatterOptions\n * @returns ScatterPathSpecOptions[]\n */\nexport const getScatterPaths = (scatterOptions: ScatterSpecOptions): ScatterPathSpecOptions[] => {\n\treturn scatterOptions.scatterPaths.map((path, index) => getScatterPathSpecOptions(path, index, scatterOptions));\n};\n\n/**\n * Sets the scales up for the scatter path marks\n * Note: This mutates the scales array so it should only be called from an immer produce function\n * @param scales\n * @param scatterOptions\n */\nexport const setScatterPathScales = (scales: Scale[], scatterOptions: ScatterSpecOptions) => {\n\tconst paths = getScatterPaths(scatterOptions);\n\n\tpaths.forEach((path) => {\n\t\taddFieldToFacetScaleDomain(scales, SYMBOL_PATH_WIDTH_SCALE, path.pathWidth);\n\t});\n};\n\nexport const getScatterPathMarks = (scatterOptions: ScatterSpecOptions): GroupMark[] => {\n\tconst marks: GroupMark[] = [];\n\tconst paths = getScatterPaths(scatterOptions);\n\n\tpaths.forEach((path) => {\n\t\tconst { groupBy, name } = path;\n\t\tmarks.push({\n\t\t\tname: `${name}_group`,\n\t\t\ttype: 'group',\n\t\t\tfrom: {\n\t\t\t\tfacet: {\n\t\t\t\t\tname: `${name}_facet`,\n\t\t\t\t\tdata: FILTERED_TABLE,\n\t\t\t\t\tgroupby: groupBy,\n\t\t\t\t},\n\t\t\t},\n\t\t\tmarks: [getScatterPathTrailMark(path)],\n\t\t});\n\t});\n\n\treturn marks;\n};\n\nexport const getScatterPathTrailMark = ({\n\tcolor,\n\tcolorScheme,\n\tdimension,\n\tdimensionScaleType,\n\tpathWidth,\n\tmetric,\n\tname,\n\topacity,\n}: ScatterPathSpecOptions): TrailMark => {\n\treturn {\n\t\tname,\n\t\ttype: 'trail',\n\t\tfrom: { data: `${name}_facet` },\n\t\tencode: {\n\t\t\tenter: {\n\t\t\t\tfill: {\n\t\t\t\t\tvalue: getColorValue(color, colorScheme),\n\t\t\t\t},\n\t\t\t\tfillOpacity: { value: opacity },\n\t\t\t\tsize: getPathWidth(pathWidth),\n\t\t\t},\n\t\t\tupdate: {\n\t\t\t\topacity: getOpacity(),\n\t\t\t\tx: getXProductionRule(dimensionScaleType, dimension),\n\t\t\t\ty: { scale: 'yLinear', field: metric },\n\t\t\t},\n\t\t},\n\t};\n};\n\n/**\n * Gets the opacity production rule for the scatterPath trail marks.\n * This is used for highlighting trails on hover and selection.\n * @param scatterOptions ScatterSpecOptions\n * @returns opacity production rule\n */\nexport const getOpacity = (): ({ test?: string } & NumericValueRef)[] => {\n\t// if a point is hovered or selected, all other points should be reduced opacity\n\tconst fadedValue = 1 / HIGHLIGHT_CONTRAST_RATIO;\n\n\treturn [\n\t\t{\n\t\t\ttest: `isValid(${HIGHLIGHTED_SERIES}) || isValid(${HIGHLIGHTED_ITEM}) || isValid(${SELECTED_SERIES}) || isValid(${SELECTED_ITEM})`,\n\t\t\tvalue: fadedValue,\n\t\t},\n\t\tDEFAULT_OPACITY_RULE,\n\t];\n};\n\nexport const getPathWidth = (pathWidth: LineWidthFacet): NumericValueRef => {\n\tif (typeof pathWidth === 'string') {\n\t\treturn { scale: SYMBOL_PATH_WIDTH_SCALE, field: pathWidth };\n\t}\n\treturn { value: getLineWidthPixelsFromLineWidth(pathWidth.value) };\n};\n","/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport { Signal } from 'vega';\n\nimport {\n\tFILTERED_TABLE,\n\tHIGHLIGHTED_GROUP,\n\tHIGHLIGHTED_ITEM,\n\tHIGHLIGHTED_SERIES,\n\tSERIES_ID,\n} from '@spectrum-charts/constants';\n\n/**\n * Does signal with given name exist?\n */\nexport const hasSignalByName = (signals: Signal[], name: string) => {\n\treturn signals.some((signal) => signal.name === name);\n};\n\n/**\n *  Returns a controlled hover signal.\n *  Controlled hover signals get manually updated via the view in Chart.tsx\n */\nexport const getControlledHoveredIdSignal = (name: string): Signal => {\n\treturn {\n\t\tname: `${name}_controlledHoveredId`,\n\t\tvalue: null,\n\t\ton: [{ events: `@${name}:mouseout`, update: 'null' }],\n\t};\n};\n\n/**\n *  Returns a controlled hover signal.\n *  Controlled hover signals get manually updated via the view in Chart.tsx\n */\nexport const getControlledHoveredGroupSignal = (name: string): Signal => {\n\treturn {\n\t\tname: `${name}_controlledHoveredGroup`,\n\t\tvalue: null,\n\t\ton: [{ events: `@${name}:mouseout`, update: 'null' }],\n\t};\n};\n\n/**\n * Returns the highlighted series signal\n */\nexport const addHighlighSignalLegendHoverEvents = (\n\tsignals: Signal[],\n\tlegendName: string,\n\tincludeHiddenSeries: boolean,\n\tkeys?: string[]\n) => {\n\tconst signalName = keys?.length ? HIGHLIGHTED_GROUP : HIGHLIGHTED_SERIES;\n\tconst highlightedItemSignal = signals.find((signal) => signal.name === signalName);\n\tif (highlightedItemSignal) {\n\t\tif (highlightedItemSignal.on === undefined) {\n\t\t\thighlightedItemSignal.on = [];\n\t\t}\n\t\thighlightedItemSignal.on.push(\n\t\t\t...[\n\t\t\t\t{\n\t\t\t\t\tevents: `@${legendName}_legendEntry:mouseover`,\n\t\t\t\t\tupdate: getHighlightSignalUpdateExpression(legendName, includeHiddenSeries, keys),\n\t\t\t\t},\n\t\t\t\t{ events: `@${legendName}_legendEntry:mouseout`, update: 'null' },\n\t\t\t]\n\t\t);\n\t}\n};\n\nexport const getHighlightSignalUpdateExpression = (\n\tlegendName: string,\n\tincludeHiddenSeries: boolean,\n\tkeys?: string[]\n) => {\n\tconst hoveredSeriesExpression = `domain(\"${legendName}Entries\")[datum.index]`;\n\tif (!includeHiddenSeries) return hoveredSeriesExpression;\n\tif (keys?.length) {\n\t\treturn `indexof(pluck(data(\"${FILTERED_TABLE}\"),\"${legendName}_highlightGroupId\"), ${hoveredSeriesExpression}) !== -1 ? ${hoveredSeriesExpression} : null`;\n\t}\n\treturn `indexof(hiddenSeries, ${hoveredSeriesExpression}) === -1 ? ${hoveredSeriesExpression} : null`;\n};\n\n/**\n * Returns the legendLabels series signal\n */\nexport const getLegendLabelsSeriesSignal = (value: unknown = null): Signal => {\n\treturn {\n\t\tname: 'legendLabels',\n\t\tvalue,\n\t};\n};\n\n/**\n * Returns a basic value based signal\n */\nexport const getGenericValueSignal = (name: string, value: unknown = null): Signal => {\n\treturn { name, value };\n};\n\n/**\n * Returns a basic value based signal\n */\nexport const getGenericUpdateSignal = (name: string, update: string): Signal => {\n\treturn { name, update };\n};\n\n/**\n * adds on events to the highlighted item signal\n * @param signals\n * @param markName\n * @param datumOrder how deep the datum is nested (i.e. 1 becomes datum.rscMarkId, 2 becomes datum.datum.rscMarkId, etc.)\n * @param excludeDataKey data items with a truthy value for this key will be excluded from the signal\n */\nexport const addHighlightedItemSignalEvents = (\n\tsignals: Signal[],\n\tmarkName: string,\n\tidKey: string,\n\tdatumOrder = 1,\n\texcludeDataKeys?: string[]\n) => {\n\tconst highlightedItemSignal = signals.find((signal) => signal.name === HIGHLIGHTED_ITEM);\n\tif (highlightedItemSignal) {\n\t\tif (highlightedItemSignal.on === undefined) {\n\t\t\thighlightedItemSignal.on = [];\n\t\t}\n\t\tconst datum = new Array(datumOrder).fill('datum.').join('');\n\n\t\tconst excludeDataKeysCondition = excludeDataKeys\n\t\t\t?.map((excludeDataKey) => `${datum}${excludeDataKey}`)\n\t\t\t.join(' || ');\n\t\thighlightedItemSignal.on.push(\n\t\t\t...[\n\t\t\t\t{\n\t\t\t\t\tevents: `@${markName}:mouseover`,\n\t\t\t\t\tupdate: excludeDataKeys?.length\n\t\t\t\t\t\t? `(${excludeDataKeysCondition}) ? null : ${datum}${idKey}`\n\t\t\t\t\t\t: `${datum}${idKey}`,\n\t\t\t\t},\n\t\t\t\t{ events: `@${markName}:mouseout`, update: 'null' },\n\t\t\t]\n\t\t);\n\t}\n};\n\n/**\n * adds on events to the highlighted series signal\n * @param signals\n * @param markName\n * @param datumOrder how deep the datum is nested (i.e. 1 becomes datum.rscMarkId, 2 becomes datum.datum.rscMarkId, etc.)\n * @param excludeDataKey data items with a truthy value for this key will be excluded from the signal\n */\nexport const addHighlightedSeriesSignalEvents = (\n\tsignals: Signal[],\n\tmarkName: string,\n\tdatumOrder = 1,\n\texcludeDataKeys?: string[]\n) => {\n\tconst highlightedSeriesSignal = signals.find((signal) => signal.name === HIGHLIGHTED_SERIES);\n\tif (highlightedSeriesSignal) {\n\t\tif (highlightedSeriesSignal.on === undefined) {\n\t\t\thighlightedSeriesSignal.on = [];\n\t\t}\n\t\tconst datum = new Array(datumOrder).fill('datum.').join('');\n\n\t\tconst excludeDataKeysCondition = excludeDataKeys\n\t\t\t?.map((excludeDataKey) => `${datum}${excludeDataKey}`)\n\t\t\t.join(' || ');\n\t\thighlightedSeriesSignal.on.push(\n\t\t\t...[\n\t\t\t\t{\n\t\t\t\t\tevents: `@${markName}:mouseover`,\n\t\t\t\t\tupdate: excludeDataKeys?.length\n\t\t\t\t\t\t? `(${excludeDataKeysCondition}) ? null : ${datum}${SERIES_ID}`\n\t\t\t\t\t\t: `${datum}${SERIES_ID}`,\n\t\t\t\t},\n\t\t\t\t{ events: `@${markName}:mouseout`, update: 'null' },\n\t\t\t]\n\t\t);\n\t}\n};\n","/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport { Data, Scale, ScaleType, Spec } from 'vega';\n\nimport {\n\tCOLOR_SCALE,\n\tDATE_PATH,\n\tDEFAULT_TRANSFORMED_TIME_DIMENSION,\n\tFILTERED_TABLE,\n\tLINE_TYPE_SCALE,\n\tMARK_ID,\n\tOPACITY_SCALE,\n\tROUNDED_SQUARE_PATH,\n\tSENTIMENT_NEGATIVE_PATH,\n\tSENTIMENT_NEUTRAL_PATH,\n\tSENTIMENT_POSITIVE_PATH,\n\tTABLE,\n} from '@spectrum-charts/constants';\nimport { getColorValue } from '@spectrum-charts/themes';\n\nimport {\n\tChartSpecOptions,\n\tChartSymbolShape,\n\tColorFacet,\n\tDualFacet,\n\tIcon,\n\tLineType,\n\tLineTypeFacet,\n\tLineWidth,\n\tNumberFormat,\n\tOpacityFacet,\n\tSymbolSize,\n\tSymbolSizeFacet,\n} from './types';\n\n/**\n * gets all the keys that are used to facet by\n * @param facetOptions\n * @returns facets\n */\nexport const getFacetsFromOptions = ({\n\tcolor,\n\tlineType,\n\topacity,\n\tsize,\n}: {\n\tcolor?: ColorFacet | DualFacet;\n\tlineType?: LineTypeFacet | DualFacet;\n\topacity?: OpacityFacet | DualFacet;\n\tsize?: SymbolSizeFacet;\n}): { facets: string[]; secondaryFacets: string[] } => {\n\t// get all the keys that we need to facet by\n\t// filter out the ones that use static values instead of fields\n\tlet facets = [color, lineType, opacity, size]\n\t\t.map((facet) => (Array.isArray(facet) ? facet[0] : facet))\n\t\t.filter((facet): facet is string => typeof facet === 'string');\n\t// remove duplicates\n\tfacets = [...new Set(facets)];\n\n\tlet secondaryFacets = [color, lineType, opacity]\n\t\t.map((facet) => (Array.isArray(facet) ? facet[1] : undefined))\n\t\t.filter((facet): facet is string => typeof facet === 'string');\n\t// remove duplicates\n\tsecondaryFacets = [...new Set(secondaryFacets)];\n\n\treturn { facets, secondaryFacets };\n};\n\n/**\n * gets all the keys that have been used to facet the data into series from the scales\n * @param scales\n * @returns\n */\nexport const getFacetsFromScales = (scales: Scale[] = []): string[] => {\n\tconst facets = [\n\t\tCOLOR_SCALE,\n\t\tLINE_TYPE_SCALE,\n\t\tOPACITY_SCALE,\n\t\t'secondaryColor',\n\t\t'secondaryLineType',\n\t\t'secondaryOpacity',\n\t].reduce((acc, cur) => {\n\t\tconst scale = scales.find((scale) => scale.name === cur);\n\t\tif (scale?.domain && 'fields' in scale.domain && scale.domain.fields.length) {\n\t\t\treturn [...acc, scale.domain.fields[0].toString()];\n\t\t}\n\t\treturn acc;\n\t}, [] as string[]);\n\n\t// only want the unique facets\n\treturn [...new Set(facets)];\n};\n\n/**\n * gets the strokeDash array from the lineType\n * @param lineType\n * @returns strokeDash array\n */\nexport const getStrokeDashFromLineType = (lineType: LineType): number[] => {\n\tif (Array.isArray(lineType)) {\n\t\treturn lineType;\n\t}\n\tswitch (lineType) {\n\t\tcase 'dashed':\n\t\t\treturn [7, 4];\n\t\tcase 'dotted':\n\t\t\treturn [2, 3];\n\t\tcase 'dotDash':\n\t\t\treturn [2, 3, 7, 4];\n\t\tcase 'shortDash':\n\t\t\treturn [3, 4];\n\t\tcase 'longDash':\n\t\t\treturn [11, 4];\n\t\tcase 'twoDash':\n\t\t\treturn [5, 2, 11, 2];\n\t\tcase 'solid':\n\t\tdefault:\n\t\t\treturn [];\n\t}\n};\n\n/**\n * gets the line width pixel value from the lineWidth\n * @param lineWidth\n * @returns line width pixel value\n */\nexport const getLineWidthPixelsFromLineWidth = (lineWidth: LineWidth): number => {\n\tif (typeof lineWidth === 'number') {\n\t\treturn lineWidth;\n\t}\n\n\tswitch (lineWidth) {\n\t\tcase 'XS':\n\t\t\treturn 1;\n\t\tcase 'S':\n\t\t\treturn 1.5;\n\t\tcase 'L':\n\t\t\treturn 3;\n\t\tcase 'XL':\n\t\t\treturn 4;\n\t\tcase 'M':\n\t\tdefault:\n\t\t\treturn 2;\n\t}\n};\n\n/**\n * get the SVG path for the symbol shape\n * @param symbolShape supported shape name or custom SVG path\n * @returns SVG path\n */\nexport const getPathFromSymbolShape = (symbolShape: ChartSymbolShape): string => {\n\tif (symbolShape === 'rounded-square') return ROUNDED_SQUARE_PATH;\n\treturn symbolShape;\n};\n\n/**\n * gets the strokeDash array from the lineType\n * @param icon\n * @returns strokeDash array\n */\nexport const getPathFromIcon = (icon: Icon | string): string => {\n\tconst supportedIcons: { [key in Icon]: string } = {\n\t\tdate: DATE_PATH,\n\t\tsentimentNegative: SENTIMENT_NEGATIVE_PATH,\n\t\tsentimentNeutral: SENTIMENT_NEUTRAL_PATH,\n\t\tsentimentPositive: SENTIMENT_POSITIVE_PATH,\n\t};\n\treturn supportedIcons[icon] || icon;\n};\n\n/**\n * Converts a symbolSize to the vega size\n * RSC uses the width of the symbol to determine the size\n * Vega uses the area of the symbol to determine the size\n * @param symbolSize\n * @returns size in square pixels\n */\nexport const getVegaSymbolSizeFromRscSymbolSize = (symbolSize: SymbolSize): number => {\n\treturn Math.pow(getSymbolWidthFromRscSymbolSize(symbolSize), 2);\n};\n\n/**\n * Gets the width of the symbol or trail from the symbolSize\n * @param symbolSize\n * @returns width in pixels\n */\nexport const getSymbolWidthFromRscSymbolSize = (symbolSize: SymbolSize): number => {\n\tif (typeof symbolSize === 'number') {\n\t\treturn symbolSize;\n\t}\n\n\tswitch (symbolSize) {\n\t\tcase 'XS':\n\t\t\treturn 6;\n\t\tcase 'S':\n\t\t\treturn 8;\n\t\tcase 'L':\n\t\t\treturn 12;\n\t\tcase 'XL':\n\t\t\treturn 16;\n\t\tcase 'M':\n\t\tdefault:\n\t\t\treturn 10;\n\t}\n};\n\n/**\n * base data that gets initialized with every uncontrolled spec\n */\nexport const baseData: Data[] = [\n\t{ name: TABLE, values: [], transform: [{ type: 'identifier', as: MARK_ID }] },\n\t{ name: FILTERED_TABLE, source: TABLE },\n];\n\n/**\n * Merges an optionally supplied spec with Chart options and default values.\n *\n * @param spec - The spec to merge with the base spec. If none is supplied, the base spec is returned.\n * @param chartOptions - A partial set of chart options to spread on to the spec.\n * @returns Spec with default values\n */\nexport const initializeSpec = (spec: Spec | null = {}, chartOptions: Partial<ChartSpecOptions> = {}): Spec => {\n\tconst { backgroundColor, colorScheme = 'light', description, title } = chartOptions;\n\n\tconst baseSpec: Spec = {\n\t\ttitle: title || undefined,\n\t\tdescription,\n\t\tautosize: { type: 'fit', contains: 'padding', resize: true },\n\t\tdata: baseData,\n\t\tbackground: backgroundColor ? getColorValue(backgroundColor, colorScheme) : undefined,\n\t};\n\n\treturn { ...baseSpec, ...(spec || {}) };\n};\n\n/**\n * The inverse of `extractValues`. Given an array of Vega datasets and an object of key/value pairs\n * merge the values into the datasets.\n * @param data An array of Vega datasets\n * @param values An object of key/value pairs where the key is the dataset name and the value is\n * the array of values\n * @returns An array of Vega datasets with the values from the values object merged in\n */\nexport const mergeValuesIntoData = (data, values) => {\n\treturn data.map((dataset) => {\n\t\tconst datasetValues = values[dataset.name];\n\t\tif (datasetValues) {\n\t\t\tdataset.values = datasetValues;\n\t\t}\n\t\treturn dataset;\n\t});\n};\n\n/**\n * returns the correct data field to use as the dimension\n * @param dimension\n * @param scaleType\n * @returns string\n */\nexport const getDimensionField = (dimension: string, scaleType?: ScaleType) => {\n\treturn scaleType === 'time' ? DEFAULT_TRANSFORMED_TIME_DIMENSION : dimension;\n};\n\n/**\n * Gets the d3 format specifier for named number formats.\n * shortNumber and shortCurrency are not included since these require additional logic\n * @param numberFormat\n * @returns\n */\nexport const getD3FormatSpecifierFromNumberFormat = (numberFormat: NumberFormat | string): string => {\n\tswitch (numberFormat) {\n\t\tcase 'currency':\n\t\t\treturn '$,.2f'; // currency format\n\t\tcase 'standardNumber':\n\t\t\treturn ','; // standard number format\n\t\tdefault:\n\t\t\treturn numberFormat;\n\t}\n};\n","/*\n * Copyright 2024 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport { TextValueRef } from 'vega';\n\nimport { getD3FormatSpecifierFromNumberFormat } from './specUtils';\nimport { NumberFormat } from './types';\n\n/**\n * gets the number format tests and signals based on the numberFormat\n * @param numberFormat\n * @returns\n */\nexport const getTextNumberFormat = (\n\tnumberFormat: NumberFormat | string,\n\tdatumProperty: string = 'value',\n\tcurrencyLocale?: string,\n\tcurrencyCode?: string\n): ({\n\ttest?: string;\n} & TextValueRef)[] => {\n\tconst test = `isNumber(datum['${datumProperty}'])`;\n\tif (numberFormat === 'shortNumber') {\n\t\treturn [\n\t\t\t{\n\t\t\t\ttest: `${test} && abs(datum['${datumProperty}']) >= 1000`,\n\t\t\t\tsignal: `upper(replace(format(datum['${datumProperty}'], '.3~s'), /(\\\\d+)G/, '$1B'))`,\n\t\t\t},\n\t\t];\n\t}\n\tif (numberFormat === 'shortCurrency') {\n\t\treturn [\n\t\t\t{\n\t\t\t\ttest: `${test} && abs(datum['${datumProperty}']) >= 1000`,\n\t\t\t\tsignal: `upper(replace(format(datum['${datumProperty}'], '$.3~s'), /(\\\\d+)G/, '$1B'))`,\n\t\t\t},\n\t\t\t{\n\t\t\t\ttest,\n\t\t\t\tsignal: `format(datum['${datumProperty}'], '$')`,\n\t\t\t},\n\t\t];\n\t}\n\tif (currencyCode && currencyLocale) {\n\t\treturn [\n\t\t\t{ test, signal: `formatLocaleCurrency(datum, \"${currencyLocale}\", \"${currencyCode}\", \"${numberFormat}\")` },\n\t\t];\n\t}\n\tconst d3FormatSpecifier = getD3FormatSpecifierFromNumberFormat(numberFormat);\n\treturn [{ test, signal: `format(datum['${datumProperty}'], '${d3FormatSpecifier}')` }];\n};\n","/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport { produce } from 'immer';\nimport { Spec } from 'vega';\n\nimport { DEFAULT_TITLE_FONT_WEIGHT } from '@spectrum-charts/constants';\n\nimport { TitleOptions } from '../types';\n\nexport const addTitle = produce<Spec, [TitleOptions]>(\n\t(spec, { text, fontWeight = DEFAULT_TITLE_FONT_WEIGHT, position = 'middle', orient = 'top' }) => {\n\t\tspec.title = {\n\t\t\ttext,\n\t\t\tfontWeight,\n\t\t\tanchor: position,\n\t\t\tframe: 'group',\n\t\t\torient,\n\t\t};\n\n\t\treturn spec;\n\t}\n);\n","/*\n * Copyright 2024 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport * from './trendlineDataUtils';\nexport * from './trendlineMarkUtils';\nexport * from './trendlineScaleUtils';\nexport * from './trendlineSignalUtils';\n","/*\n * Copyright 2024 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport {\n\tAggregateOp,\n\tAggregateTransform,\n\tCollectTransform,\n\tExtentTransform,\n\tFilterTransform,\n\tFormulaTransform,\n\tJoinAggregateTransform,\n\tLookupTransform,\n\tRegressionMethod,\n\tRegressionTransform,\n\tTransforms,\n\tWindowTransform,\n} from 'vega';\n\nimport { MS_PER_DAY, TRENDLINE_VALUE } from '@spectrum-charts/constants';\n\nimport { getFacetsFromOptions } from '../specUtils';\nimport { AggregateMethod, TrendlineMethod, TrendlineSpecOptions } from '../types';\nimport { TrendlineParentOptions, getPolynomialOrder, getRegressionExtent, isPolynomialMethod } from './trendlineUtils';\n\n/**\n * Gets the aggreagate transform used for calculating the average trendline\n * @param markOptions\n * @param trendlineSpecOptions\n * @param isHighResolutionData\n * @returns transform\n */\nexport const getAggregateTransform = (\n\tmarkOptions: TrendlineParentOptions,\n\t{ method, trendlineDimension, trendlineMetric }: TrendlineSpecOptions,\n\tisHighResolutionData: boolean\n): AggregateTransform | JoinAggregateTransform => {\n\tconst { color, lineType } = markOptions;\n\tconst { facets } = getFacetsFromOptions({ color, lineType });\n\tconst operations: Record<AggregateMethod, AggregateOp> = {\n\t\taverage: 'mean',\n\t\tmedian: 'median',\n\t};\n\tif (isHighResolutionData) {\n\t\treturn {\n\t\t\ttype: 'aggregate',\n\t\t\tgroupby: facets,\n\t\t\tops: [operations[method], 'min', 'max'],\n\t\t\tfields: [trendlineMetric, trendlineDimension, trendlineDimension],\n\t\t\tas: [TRENDLINE_VALUE, `${trendlineDimension}Min`, `${trendlineDimension}Max`],\n\t\t};\n\t}\n\treturn {\n\t\ttype: 'joinaggregate',\n\t\tgroupby: facets,\n\t\tops: [operations[method]],\n\t\tfields: [trendlineMetric],\n\t\tas: [TRENDLINE_VALUE],\n\t};\n};\n\n/**\n * Gets the regression transform used for calculating the regression trendline.\n * Regression trendlines are ones that use the x value as a parameter\n * @see https://vega.github.io/vega/docs/transforms/regression/\n * @param markOptions\n * @param method\n * @param isHighResolutionData\n * @returns\n */\nexport const getRegressionTransform = (\n\tmarkOptions: TrendlineParentOptions,\n\ttrendlineOptions: TrendlineSpecOptions,\n\tisHighResolutionData: boolean\n): RegressionTransform => {\n\tconst { color, lineType } = markOptions;\n\tconst { dimensionExtent, isDimensionNormalized, method, name, trendlineDimension, trendlineMetric } =\n\t\ttrendlineOptions;\n\tconst { facets } = getFacetsFromOptions({ color, lineType });\n\n\tlet regressionMethod: RegressionMethod | undefined;\n\tlet order: number | undefined;\n\n\tswitch (method) {\n\t\tcase 'exponential':\n\t\t\tregressionMethod = 'exp';\n\t\t\tbreak;\n\t\tcase 'logarithmic':\n\t\t\tregressionMethod = 'log';\n\t\t\tbreak;\n\t\tcase 'power':\n\t\t\tregressionMethod = 'pow';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\torder = getPolynomialOrder(method);\n\t\t\tregressionMethod = 'poly';\n\t\t\tbreak;\n\t}\n\n\treturn {\n\t\ttype: 'regression',\n\t\tmethod: regressionMethod,\n\t\torder,\n\t\tgroupby: facets,\n\t\tx: trendlineDimension,\n\t\ty: trendlineMetric,\n\t\tas: isHighResolutionData ? [trendlineDimension, TRENDLINE_VALUE] : undefined,\n\t\tparams: !isHighResolutionData,\n\t\textent: isHighResolutionData ? getRegressionExtent(dimensionExtent, name, isDimensionNormalized) : undefined,\n\t};\n};\n\n/**\n * Gets the window transform used for calculating the moving average trendline.\n * @param markOptions\n * @param method\n * @returns\n */\nexport const getWindowTransform = (\n\tmarkOptions: TrendlineParentOptions,\n\t{ method, trendlineMetric }: TrendlineSpecOptions\n): WindowTransform => {\n\tconst frameWidth = parseInt(method.split('-')[1]);\n\n\tconst { color, lineType } = markOptions;\n\tconst { facets } = getFacetsFromOptions({ color, lineType });\n\n\tif (isNaN(frameWidth) || frameWidth < 1) {\n\t\tthrow new Error(\n\t\t\t`Invalid moving average frame width: ${frameWidth}, frame width must be an integer greater than 0`\n\t\t);\n\t}\n\n\treturn {\n\t\ttype: 'window',\n\t\tops: ['mean'],\n\t\tgroupby: facets,\n\t\tfields: [trendlineMetric],\n\t\tas: [TRENDLINE_VALUE],\n\t\tframe: [frameWidth - 1, 0],\n\t};\n};\n\n/**\n * Gets the transforms that will normalize the dimension.\n * The dimension gets normalized for time scales on regression methods. This makes the regression calculations far more accurate than using the raw time values\n * @param dimension\n * @returns\n */\nexport const getNormalizedDimensionTransform = (dimension: string): Transforms[] => [\n\t{\n\t\ttype: 'joinaggregate',\n\t\tfields: [dimension],\n\t\tas: [`${dimension}Min`],\n\t\tops: ['min'],\n\t},\n\t{\n\t\ttype: 'formula',\n\t\texpr: `(datum.${dimension} - datum.${dimension}Min + ${MS_PER_DAY}) / ${MS_PER_DAY}`,\n\t\tas: `${dimension}Normalized`,\n\t},\n];\n\n/**\n * Gets an extent transform.\n * This is used to calculate the min and max of the dimension so that it can be used to set the extent of the regression trendline\n * @param dimension\n * @param name\n * @returns\n */\nexport const getRegressionExtentTransform = (dimension: string, name: string): ExtentTransform => ({\n\ttype: 'extent',\n\tfield: dimension,\n\tsignal: `${name}_extent`,\n});\n\n/**\n * Gets the sort transform for the provided dimension.\n * This is used to sort window methods so they are calculated and drawn in the correct order\n * @param dimension\n * @returns CollectTransform\n */\nexport const getSortTransform = (dimension: string): CollectTransform => ({\n\ttype: 'collect',\n\tsort: {\n\t\tfield: dimension,\n\t},\n});\n\n/**\n * gets the filter transforms that will restrict the data to the dimension range\n * @param dimension\n * @param dimensionRange\n * @returns filterTansforms\n */\nexport const getTrendlineDimensionRangeTransforms = (\n\tdimension: string,\n\tdimensionRange: [number | null, number | null]\n): FilterTransform[] => {\n\tconst filterExpressions: string[] = [];\n\tif (dimensionRange[0] !== null) {\n\t\tfilterExpressions.push(`datum.${dimension} >= ${dimensionRange[0]}`);\n\t}\n\tif (dimensionRange[1] !== null) {\n\t\tfilterExpressions.push(`datum.${dimension} <= ${dimensionRange[1]}`);\n\t}\n\tif (filterExpressions.length) {\n\t\treturn [\n\t\t\t{\n\t\t\t\ttype: 'filter',\n\t\t\t\texpr: filterExpressions.join(' && '),\n\t\t\t},\n\t\t];\n\t}\n\treturn [];\n};\n\n/**\n * This transform is used to calculate the value of the trendline using the coef and the dimension\n * @param trendlineDimension mark dimension\n * @param method trenline method\n * @returns formula transorfm\n */\nexport const getTrendlineParamFormulaTransforms = (\n\ttrendlineDimension: string,\n\tmethod: TrendlineMethod\n): FormulaTransform[] => {\n\tlet expr = '';\n\tif (isPolynomialMethod(method)) {\n\t\tconst order = getPolynomialOrder(method);\n\t\texpr = [\n\t\t\t'datum.coef[0]',\n\t\t\t...Array(order)\n\t\t\t\t.fill(0)\n\t\t\t\t.map((_e, i) => `datum.coef[${i + 1}] * pow(datum.${trendlineDimension}, ${i + 1})`),\n\t\t].join(' + ');\n\t} else if (method === 'exponential') {\n\t\texpr = `datum.coef[0] + exp(datum.coef[1] * datum.${trendlineDimension})`;\n\t} else if (method === 'logarithmic') {\n\t\texpr = `datum.coef[0] + datum.coef[1] * log(datum.${trendlineDimension})`;\n\t} else if (method === 'power') {\n\t\texpr = `datum.coef[0] * pow(datum.${trendlineDimension}, datum.coef[1])`;\n\t}\n\n\tif (!expr) return [];\n\treturn [\n\t\t{\n\t\t\ttype: 'formula',\n\t\t\texpr,\n\t\t\tas: TRENDLINE_VALUE,\n\t\t},\n\t];\n};\n\n/**\n * Gets the lookup transform that will be used to lookup the coef for regression trendlines\n * @param markOptions\n * @param trendlineOptions\n * @returns LookupTransform\n */\nexport const getTrendlineParamLookupTransform = (\n\t{ color, lineType }: TrendlineParentOptions,\n\t{ name }: TrendlineSpecOptions\n): LookupTransform => {\n\tconst { facets } = getFacetsFromOptions({ color, lineType });\n\treturn {\n\t\ttype: 'lookup',\n\t\tfrom: `${name}_params`,\n\t\tkey: 'keys',\n\t\tfields: facets,\n\t\tvalues: ['coef'],\n\t};\n};\n","/*\n * Copyright 2024 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport { produce } from 'immer';\nimport { Data, SourceData, Transforms } from 'vega';\n\nimport {\n\tFILTERED_TABLE,\n\tHIGHLIGHTED_ITEM,\n\tHIGHLIGHTED_SERIES,\n\tSELECTED_ITEM,\n\tSELECTED_SERIES,\n\tSERIES_ID,\n} from '@spectrum-charts/constants';\n\nimport { getSeriesIdTransform, getTableData } from '../data/dataUtils';\nimport { isInteractive } from '../marks/markUtils';\nimport { getFacetsFromOptions } from '../specUtils';\nimport { TrendlineMethod, TrendlineSpecOptions } from '../types';\nimport {\n\tgetAggregateTransform,\n\tgetNormalizedDimensionTransform,\n\tgetRegressionExtentTransform,\n\tgetRegressionTransform,\n\tgetSortTransform,\n\tgetTrendlineDimensionRangeTransforms,\n\tgetTrendlineParamFormulaTransforms,\n\tgetTrendlineParamLookupTransform,\n\tgetWindowTransform,\n} from './trendlineDataTransformUtils';\nimport {\n\tTrendlineParentOptions,\n\tgetTrendlineDimensionMetric,\n\tgetTrendlines,\n\tisAggregateMethod,\n\tisRegressionMethod,\n\tisWindowMethod,\n} from './trendlineUtils';\n\n/**\n * Adds the necessary data sources and transforms for the trendlines\n * NOTE: this function mutates the data array because it gets called from within a data produce function\n * @param data\n * @param markOptions\n */\nexport const addTrendlineData = (data: Data[], markOptions: TrendlineParentOptions) => {\n\tdata.push(...getTrendlineData(markOptions));\n\n\tconst tableData = getTableData(data);\n\ttableData.transform = addTableDataTransforms(tableData.transform ?? [], markOptions);\n};\n\n/**\n * Gets all the data sources and transforms for all trendlines\n * @param data\n * @param markOptions\n * @returns Data[]\n */\nexport const getTrendlineData = (markOptions: TrendlineParentOptions): SourceData[] => {\n\tconst data: SourceData[] = [];\n\tconst { color, idKey, lineType, name: markName } = markOptions;\n\tconst trendlines = getTrendlines(markOptions);\n\n\tconst concatenatedTrendlineData: { name: string; source: string[] } = {\n\t\tname: `${markName}_allTrendlineData`,\n\t\tsource: [],\n\t};\n\n\tfor (const trendlineOptions of trendlines) {\n\t\tconst { displayOnHover, method, name } = trendlineOptions;\n\t\tconst { facets } = getFacetsFromOptions({ color, lineType });\n\n\t\tif (isRegressionMethod(method)) {\n\t\t\tdata.push(...getRegressionTrendlineData(markOptions, trendlineOptions, facets));\n\t\t} else if (isAggregateMethod(method)) {\n\t\t\tdata.push(...getAggregateTrendlineData(markOptions, trendlineOptions, facets));\n\t\t} else if (isWindowMethod(method)) {\n\t\t\tdata.push(getWindowTrendlineData(markOptions, trendlineOptions));\n\t\t}\n\t\tif (displayOnHover) {\n\t\t\tdata.push(getTrendlineDisplayOnHoverData(name, method));\n\t\t}\n\t\tif (isInteractive(trendlineOptions)) {\n\t\t\tconcatenatedTrendlineData.source.push(`${name}_data`);\n\t\t}\n\t}\n\n\tif (trendlines.some((trendline) => isInteractive(trendline))) {\n\t\tdata.push(concatenatedTrendlineData);\n\t\tdata.push(getHighlightTrendlineData(markName, idKey));\n\t}\n\n\treturn data;\n};\n\n/**\n * Gets the data sources and transforms for aggregate trendlines (average, median)\n * @param markOptions\n * @param trendlineOptions\n * @param facets\n * @returns Data[]\n */\nexport const getAggregateTrendlineData = (\n\tmarkOptions: TrendlineParentOptions,\n\ttrendlineOptions: TrendlineSpecOptions,\n\tfacets: string[]\n) => {\n\tconst data: SourceData[] = [];\n\tconst { dimensionRange, name, trendlineDimension } = trendlineOptions;\n\tconst dimensionRangeTransforms = getTrendlineDimensionRangeTransforms(trendlineDimension, dimensionRange);\n\t// high resolution data used for drawing the rule marks\n\tdata.push({\n\t\tname: `${name}_highResolutionData`,\n\t\tsource: FILTERED_TABLE,\n\t\ttransform: [\n\t\t\t...getExcludeDataKeyTransforms(trendlineOptions.excludeDataKeys),\n\t\t\t...dimensionRangeTransforms,\n\t\t\t...getTrendlineStatisticalTransforms(markOptions, trendlineOptions, true),\n\t\t\t...getSeriesIdTransform(facets),\n\t\t],\n\t});\n\tif (isInteractive(trendlineOptions)) {\n\t\t// data used for each of the trendline points\n\t\tdata.push({\n\t\t\tname: `${name}_data`,\n\t\t\tsource: FILTERED_TABLE,\n\t\t\ttransform: [\n\t\t\t\t...dimensionRangeTransforms,\n\t\t\t\t...getTrendlineStatisticalTransforms(markOptions, trendlineOptions, false),\n\t\t\t],\n\t\t});\n\t}\n\treturn data;\n};\n\n/**\n * Gets the data sources and transforms for regression trendlines (linear, power, polynomial-x, etc.)\n * @param markOptions\n * @param trendlineOptions\n * @param facets\n * @returns Data[]\n */\nexport const getRegressionTrendlineData = (\n\tmarkOptions: TrendlineParentOptions,\n\ttrendlineOptions: TrendlineSpecOptions,\n\tfacets: string[]\n) => {\n\tconst data: SourceData[] = [];\n\tconst { dimension, metric } = markOptions;\n\tconst { dimensionRange, method, name, orientation, trendlineDimension } = trendlineOptions;\n\tconst { trendlineDimension: standardTrendlineDimension } = getTrendlineDimensionMetric(\n\t\tdimension,\n\t\tmetric,\n\t\torientation,\n\t\tfalse\n\t);\n\tconst dimensionRangeTransforms = getTrendlineDimensionRangeTransforms(standardTrendlineDimension, dimensionRange);\n\t// high resolution data used for drawing the smooth trendline\n\tdata.push({\n\t\tname: `${name}_highResolutionData`,\n\t\tsource: FILTERED_TABLE,\n\t\ttransform: [\n\t\t\t...getExcludeDataKeyTransforms(trendlineOptions.excludeDataKeys),\n\t\t\t...dimensionRangeTransforms,\n\t\t\t...getTrendlineStatisticalTransforms(markOptions, trendlineOptions, true),\n\t\t\t...getSeriesIdTransform(facets),\n\t\t],\n\t});\n\tif (isInteractive(trendlineOptions)) {\n\t\t// params and data used for each of the trendline data points\n\t\t// the high resolution data has too much detail and we don't want a tooltip at each high resolution point\n\t\tdata.push(\n\t\t\t{\n\t\t\t\tname: `${name}_params`,\n\t\t\t\tsource: FILTERED_TABLE,\n\t\t\t\ttransform: [\n\t\t\t\t\t...dimensionRangeTransforms,\n\t\t\t\t\t...getTrendlineStatisticalTransforms(markOptions, trendlineOptions, false),\n\t\t\t\t],\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: `${name}_data`,\n\t\t\t\tsource: FILTERED_TABLE,\n\t\t\t\ttransform: [\n\t\t\t\t\t...dimensionRangeTransforms,\n\t\t\t\t\tgetTrendlineParamLookupTransform(markOptions, trendlineOptions),\n\t\t\t\t\t...getTrendlineParamFormulaTransforms(trendlineDimension, method),\n\t\t\t\t],\n\t\t\t}\n\t\t);\n\t}\n\treturn data;\n};\n\n/**\n * Gets the data source and transforms for window trendlines (movingAverage-x)\n * @param markOptions\n * @param trendlineOptions\n * @returns Data\n */\nconst getWindowTrendlineData = (\n\tmarkOptions: TrendlineParentOptions,\n\ttrendlineOptions: TrendlineSpecOptions\n): SourceData => ({\n\tname: `${trendlineOptions.name}_data`,\n\tsource: FILTERED_TABLE,\n\ttransform: [\n\t\t...getExcludeDataKeyTransforms(trendlineOptions.excludeDataKeys),\n\t\t...getTrendlineStatisticalTransforms(markOptions, trendlineOptions, false),\n\t\t...getTrendlineDimensionRangeTransforms(markOptions.dimension, trendlineOptions.dimensionRange),\n\t],\n});\n\n/**\n * gets the data source and transforms for highlighting trendlines\n * @param markName\n * @param trendlines\n * @returns Data\n */\nconst getHighlightTrendlineData = (markName: string, idKey: string): SourceData => {\n\tconst expr = `${SELECTED_ITEM} === datum.${idKey} || !isValid(${SELECTED_ITEM}) && (isArray(${HIGHLIGHTED_ITEM}) && indexof(${HIGHLIGHTED_ITEM}, datum.${idKey}) || ${HIGHLIGHTED_ITEM} === datum.${idKey})`;\n\treturn {\n\t\tname: `${markName}Trendline_highlightedData`,\n\t\tsource: `${markName}_allTrendlineData`,\n\t\ttransform: [\n\t\t\t{\n\t\t\t\ttype: 'filter',\n\t\t\t\texpr,\n\t\t\t},\n\t\t],\n\t};\n};\n\n/**\n * Gets the statistical transforms that will calculate the trendline values\n * @param markOptions\n * @param trendlineOptions\n * @returns dataTransforms\n */\nexport const getTrendlineStatisticalTransforms = (\n\tmarkOptions: TrendlineParentOptions,\n\ttrendlineOptions: TrendlineSpecOptions,\n\tisHighResolutionData: boolean\n): Transforms[] => {\n\tconst { method, trendlineDimension } = trendlineOptions;\n\n\tif (isAggregateMethod(method)) {\n\t\treturn [getAggregateTransform(markOptions, trendlineOptions, isHighResolutionData)];\n\t}\n\tif (isRegressionMethod(method)) {\n\t\treturn [getRegressionTransform(markOptions, trendlineOptions, isHighResolutionData)];\n\t}\n\tif (isWindowMethod(method)) {\n\t\treturn [getSortTransform(trendlineDimension), getWindowTransform(markOptions, trendlineOptions)];\n\t}\n\n\treturn [];\n};\n\n/**\n * Adds the table data transforms needed for trendlines\n * @param transforms\n * @param markOptions\n */\nexport const addTableDataTransforms = produce<Transforms[], [TrendlineParentOptions]>((transforms, markOptions) => {\n\tconst { dimension, metric } = markOptions;\n\n\tconst trendlines = getTrendlines(markOptions);\n\tfor (const { isDimensionNormalized, method, name, orientation, trendlineDimension } of trendlines) {\n\t\tif (isRegressionMethod(method)) {\n\t\t\t// time scales need to be normalized for regression trendlines\n\t\t\tconst { trendlineDimension: standardTrendlinDimension } = getTrendlineDimensionMetric(\n\t\t\t\tdimension,\n\t\t\t\tmetric,\n\t\t\t\torientation,\n\t\t\t\tfalse\n\t\t\t);\n\n\t\t\tif (isDimensionNormalized) {\n\t\t\t\tif (\n\t\t\t\t\t!transforms.some(\n\t\t\t\t\t\t(transform) => 'as' in transform && transform.as === `${standardTrendlinDimension}Normalized`\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\ttransforms.push(...getNormalizedDimensionTransform(standardTrendlinDimension));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// add the extent transform\n\t\t\ttransforms.push(getRegressionExtentTransform(trendlineDimension, name));\n\t\t}\n\t}\n});\n\n/**\n * Gets the data source and transforms for displaying the trendline on hover\n * @param trendlineName\n * @param method\n * @returns SourceData\n */\nexport const getTrendlineDisplayOnHoverData = (trendlineName: string, method: TrendlineMethod): SourceData => {\n\tconst source = isWindowMethod(method) ? `${trendlineName}_data` : `${trendlineName}_highResolutionData`;\n\treturn {\n\t\tname: `${trendlineName}_highlightedData`,\n\t\tsource,\n\t\ttransform: [\n\t\t\t{\n\t\t\t\ttype: 'filter',\n\t\t\t\texpr: `datum.${SERIES_ID} === ${HIGHLIGHTED_SERIES} || datum.${SERIES_ID} === ${SELECTED_SERIES}`,\n\t\t\t},\n\t\t],\n\t};\n};\n\nconst getExcludeDataKeyTransforms = (excludeDataKeys?: string[]): Transforms[] =>\n\texcludeDataKeys?.map((excludeDataKey) => ({\n\t\ttype: 'filter',\n\t\texpr: `!datum.${excludeDataKey}`,\n\t})) ?? [];\n","/*\n * Copyright 2024 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport { EncodeEntry, GroupMark, LineMark, NumericValueRef, RuleMark } from 'vega';\n\nimport { TRENDLINE_VALUE } from '@spectrum-charts/constants';\n\nimport { getLineHoverMarks, getLineOpacity } from '../line/lineMarkUtils';\nimport { LineMarkOptions } from '../line/lineUtils';\nimport {\n\tgetColorProductionRule,\n\tgetLineWidthProductionRule,\n\tgetOpacityProductionRule,\n\tgetStrokeDashProductionRule,\n\thasTooltip,\n} from '../marks/markUtils';\nimport { getScaleName } from '../scale/scaleSpecBuilder';\nimport { getFacetsFromOptions } from '../specUtils';\nimport { getTrendlineAnnotationMarks } from '../trendlineAnnotation';\nimport { Orientation, ScaleType, TrendlineMethod, TrendlineSpecOptions } from '../types';\nimport {\n\tTrendlineParentOptions,\n\tgetTrendlineColorFromMarkOptions,\n\tgetTrendlineLineTypeFromMarkOptions,\n\tgetTrendlines,\n\tisAggregateMethod,\n\tisRegressionMethod,\n} from './trendlineUtils';\n\nexport const getTrendlineMarks = (markOptions: TrendlineParentOptions): (GroupMark | RuleMark)[] => {\n\tconst { color, lineType } = markOptions;\n\tconst { facets } = getFacetsFromOptions({ color, lineType });\n\n\tconst marks: (GroupMark | RuleMark)[] = [];\n\tconst trendlines = getTrendlines(markOptions);\n\tfor (const trendlineOptions of trendlines) {\n\t\tconst { displayOnHover, method, name } = trendlineOptions;\n\t\tif (isAggregateMethod(method)) {\n\t\t\tmarks.push(getTrendlineRuleMark(markOptions, trendlineOptions));\n\t\t} else {\n\t\t\tconst data = getDataSourceName(name, method, displayOnHover);\n\t\t\tmarks.push({\n\t\t\t\tname: `${name}_group`,\n\t\t\t\ttype: 'group',\n\t\t\t\tclip: true,\n\t\t\t\tfrom: {\n\t\t\t\t\tfacet: {\n\t\t\t\t\t\tname: `${name}_facet`,\n\t\t\t\t\t\tdata,\n\t\t\t\t\t\tgroupby: facets,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tmarks: [getTrendlineLineMark(markOptions, trendlineOptions)],\n\t\t\t});\n\t\t}\n\t\tmarks.push(...getTrendlineAnnotationMarks(trendlineOptions, markOptions.name));\n\t}\n\n\tif (trendlines.some((trendline) => hasTooltip(trendline))) {\n\t\tmarks.push(\n\t\t\tgetTrendlineHoverMarks(\n\t\t\t\tmarkOptions,\n\t\t\t\ttrendlines.some((trendlineOptions) => trendlineOptions.highlightRawPoint)\n\t\t\t)\n\t\t);\n\t}\n\n\treturn marks;\n};\n\nconst getDataSourceName = (trendlineName: string, method: TrendlineMethod, displayOnHover: boolean): string => {\n\tif (displayOnHover) return `${trendlineName}_highlightedData`;\n\tif (isRegressionMethod(method)) return `${trendlineName}_highResolutionData`;\n\treturn `${trendlineName}_data`;\n};\n\n/**\n * gets the trendline rule mark used for aggregate methods (mean, median)\n * @param markOptions\n * @param trendlineOptions\n * @returns rule mark\n */\nexport const getTrendlineRuleMark = (\n\tmarkOptions: TrendlineParentOptions,\n\ttrendlineOptions: TrendlineSpecOptions\n): RuleMark => {\n\tconst { colorScheme } = markOptions;\n\tconst {\n\t\tdimensionExtent,\n\t\tdimensionScaleType,\n\t\tdisplayOnHover,\n\t\tlineType,\n\t\tlineWidth,\n\t\tname,\n\t\torientation,\n\t\ttrendlineColor,\n\t\ttrendlineDimension,\n\t} = trendlineOptions;\n\n\tconst data = displayOnHover ? `${name}_highlightedData` : `${name}_highResolutionData`;\n\n\treturn {\n\t\tname,\n\t\ttype: 'rule',\n\t\tclip: true,\n\t\tfrom: {\n\t\t\tdata,\n\t\t},\n\t\tinteractive: false,\n\t\tencode: {\n\t\t\tenter: {\n\t\t\t\t...getRuleYEncodings(dimensionExtent, trendlineDimension, orientation),\n\t\t\t\tstroke: getColorProductionRule(trendlineColor, colorScheme),\n\t\t\t\tstrokeDash: getStrokeDashProductionRule({ value: lineType }),\n\t\t\t\tstrokeOpacity: getOpacityProductionRule({ value: trendlineOptions.opacity }),\n\t\t\t\tstrokeWidth: getLineWidthProductionRule({ value: lineWidth }),\n\t\t\t},\n\t\t\tupdate: {\n\t\t\t\t...getRuleXEncodings(dimensionExtent, trendlineDimension, dimensionScaleType, orientation),\n\t\t\t\topacity: getLineOpacity(getLineMarkOptions(markOptions, trendlineOptions)),\n\t\t\t},\n\t\t},\n\t};\n};\n\n/**\n * gets the production rules for the y and y2 encoding of a rule mark\n * @param dimensionExtent\n * @param dimension\n * @param orientation\n * @returns x production rules\n */\nexport const getRuleYEncodings = (\n\tdimensionExtent: TrendlineSpecOptions['dimensionExtent'],\n\tdimension: string,\n\torientation: Orientation\n): EncodeEntry => {\n\tif (orientation === 'horizontal') {\n\t\treturn { y: { scale: 'yLinear', field: TRENDLINE_VALUE } };\n\t}\n\treturn {\n\t\ty: getStartDimensionExtentProductionRule(dimensionExtent[0], dimension, 'yLinear', 'y'),\n\t\ty2: getEndDimensionExtentProductionRule(dimensionExtent[1], dimension, 'yLinear', 'y'),\n\t};\n};\n\n/**\n * gets the production rules for the x and x2 encoding of a rule mark\n * @param dimensionExtent\n * @param dimension\n * @param scaleType\n * @param orientation\n * @returns x production rules\n */\nexport const getRuleXEncodings = (\n\tdimensionExtent: TrendlineSpecOptions['dimensionExtent'],\n\tdimension: string,\n\tscaleType: ScaleType,\n\torientation: Orientation\n): EncodeEntry => {\n\tconst scale = getScaleName('x', scaleType);\n\tif (orientation === 'vertical') {\n\t\treturn { x: { scale, field: TRENDLINE_VALUE } };\n\t}\n\treturn {\n\t\tx: getStartDimensionExtentProductionRule(dimensionExtent[0], dimension, scale, 'x'),\n\t\tx2: getEndDimensionExtentProductionRule(dimensionExtent[1], dimension, scale, 'x'),\n\t};\n};\n\n/**\n * Gets the production rule for the start dimension extent of a trendline\n * @param startDimensionExtent\n * @param dimension\n * @param scale\n * @param axis\n * @returns\n */\nexport const getStartDimensionExtentProductionRule = (\n\tstartDimensionExtent: number | 'domain' | null,\n\tdimension: string,\n\tscale: string,\n\taxis: 'x' | 'y'\n): NumericValueRef => {\n\tswitch (startDimensionExtent) {\n\t\tcase null:\n\t\t\treturn { scale, field: `${dimension}Min` };\n\t\tcase 'domain':\n\t\t\tif (axis === 'x') return { value: 0 };\n\t\t\treturn { signal: 'height' };\n\t\tdefault:\n\t\t\treturn { scale, value: startDimensionExtent };\n\t}\n};\n\n/**\n * gets the production rule for the end dimension extent of a trendline\n * @param endDimensionExtent\n * @param dimension\n * @param scale\n * @param axis\n * @returns\n */\nexport const getEndDimensionExtentProductionRule = (\n\tendDimensionExtent: number | 'domain' | null,\n\tdimension: string,\n\tscale: string,\n\taxis: 'x' | 'y'\n): NumericValueRef => {\n\tswitch (endDimensionExtent) {\n\t\tcase null:\n\t\t\treturn { scale, field: `${dimension}Max` };\n\t\tcase 'domain':\n\t\t\tif (axis === 'x') return { signal: 'width' };\n\t\t\treturn { value: 0 };\n\t\tdefault:\n\t\t\treturn { scale, value: endDimensionExtent };\n\t}\n};\n\n/**\n * gets the trendline line mark used for regression and window methods\n * @param markOptions\n * @param trendlineOptions\n * @returns\n */\nexport const getTrendlineLineMark = (\n\tmarkOptions: TrendlineParentOptions,\n\ttrendlineOptions: TrendlineSpecOptions\n): LineMark => {\n\tconst { colorScheme } = markOptions;\n\tconst {\n\t\tdimensionScaleType,\n\t\tisDimensionNormalized,\n\t\tlineType,\n\t\tlineWidth,\n\t\tname,\n\t\torientation,\n\t\ttrendlineColor,\n\t\ttrendlineDimension,\n\t} = trendlineOptions;\n\n\treturn {\n\t\tname,\n\t\ttype: 'line',\n\t\tfrom: { data: `${name}_facet` },\n\t\tinteractive: false,\n\t\tencode: {\n\t\t\tenter: {\n\t\t\t\ty: getLineYProductionRule(trendlineDimension, orientation),\n\t\t\t\tstroke: getColorProductionRule(trendlineColor, colorScheme),\n\t\t\t\tstrokeDash: getStrokeDashProductionRule({ value: lineType }),\n\t\t\t\tstrokeOpacity: getOpacityProductionRule({ value: trendlineOptions.opacity }),\n\t\t\t\tstrokeWidth: getLineWidthProductionRule({ value: lineWidth }),\n\t\t\t},\n\t\t\tupdate: {\n\t\t\t\tx: getLineXProductionRule(trendlineDimension, dimensionScaleType, orientation, isDimensionNormalized),\n\t\t\t\topacity: getLineOpacity(getLineMarkOptions(markOptions, trendlineOptions)),\n\t\t\t},\n\t\t},\n\t};\n};\n\n/**\n * gets the production rule for the y encoding of a line mark\n * @param trendlineDimension\n * @param orientation\n * @returns\n */\nexport const getLineYProductionRule = (trendlineDimension: string, orientation: Orientation): NumericValueRef => {\n\tconst scale = 'yLinear';\n\tif (orientation === 'horizontal') {\n\t\treturn { scale, field: TRENDLINE_VALUE };\n\t}\n\treturn { scale, field: trendlineDimension };\n};\n\n/**\n * gets the production rule for the x encoding of a line mark\n * @param trendlineDimension\n * @param scaleType\n * @param orientation\n * @param isDimensionNormalized\n * @returns\n */\nexport const getLineXProductionRule = (\n\ttrendlineDimension: string,\n\tscaleType: ScaleType,\n\torientation: Orientation,\n\tisDimensionNormalized: boolean\n): NumericValueRef => {\n\tconst scale = getScaleName('x', scaleType);\n\tif (orientation === 'vertical') {\n\t\treturn { scale, field: TRENDLINE_VALUE };\n\t}\n\treturn isDimensionNormalized\n\t\t? { scale: 'xTrendline', field: trendlineDimension }\n\t\t: { scale, field: trendlineDimension };\n};\n\nconst getTrendlineHoverMarks = (markOptions: TrendlineParentOptions, highlightRawPoint: boolean): GroupMark => {\n\tconst { metric, name } = markOptions;\n\tconst trendlines = getTrendlines(markOptions);\n\tconst trendlineHoverOptions = getLineMarkOptions(markOptions, trendlines[0], {\n\t\tname: `${name}Trendline`,\n\t\tchartTooltips: trendlines.map((trendline) => trendline.chartTooltips).flat(),\n\t\tmetric: TRENDLINE_VALUE,\n\t});\n\n\treturn {\n\t\tname: `${name}Trendline_hoverGroup`,\n\t\ttype: 'group',\n\t\tclip: true,\n\t\tmarks: getLineHoverMarks(\n\t\t\ttrendlineHoverOptions,\n\t\t\t`${name}_allTrendlineData`,\n\t\t\thighlightRawPoint ? metric : undefined\n\t\t),\n\t};\n};\n\nconst getLineMarkOptions = (\n\tmarkOptions: TrendlineParentOptions,\n\t{ dimensionScaleType, displayOnHover, lineWidth, metric, name, opacity }: TrendlineSpecOptions,\n\toverride?: Partial<LineMarkOptions>\n): LineMarkOptions => {\n\tconst { color, lineType } = markOptions;\n\tconst popoverMarkName = 'popoverMarkName' in markOptions ? markOptions.popoverMarkName : undefined;\n\tconst staticPoint = 'staticPoint' in markOptions ? markOptions.staticPoint : undefined;\n\treturn {\n\t\t...markOptions,\n\t\tcolor: getTrendlineColorFromMarkOptions(color),\n\t\tdisplayOnHover,\n\t\tlineType: getTrendlineLineTypeFromMarkOptions(lineType),\n\t\tlineWidth: { value: lineWidth },\n\t\tmetric,\n\t\tname,\n\t\topacity: { value: opacity },\n\t\tpopoverMarkName,\n\t\tscaleType: dimensionScaleType,\n\t\tstaticPoint,\n\n\t\t...override,\n\t};\n};\n","/*\n * Copyright 2024 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport { Scale } from 'vega';\n\nimport { FILTERED_TABLE, LINEAR_PADDING } from '@spectrum-charts/constants';\n\nimport { TrendlineParentOptions, hasTrendlineWithNormalizedDimension } from './trendlineUtils';\n\n/**\n * Gets all the scales used for trendlines\n * @param options\n * @returns Scale[]\n */\nexport const getTrendlineScales = (options: TrendlineParentOptions): Scale[] => {\n\tconst { dimension } = options;\n\n\t// if there is a trendline that requires a normalized dimension, add the scale\n\tif (hasTrendlineWithNormalizedDimension(options)) {\n\t\treturn [\n\t\t\t{\n\t\t\t\tname: 'xTrendline',\n\t\t\t\ttype: 'linear',\n\t\t\t\trange: 'width',\n\t\t\t\tdomain: { data: FILTERED_TABLE, fields: [`${dimension}Normalized`] },\n\t\t\t\tpadding: LINEAR_PADDING,\n\t\t\t\tzero: false,\n\t\t\t\tnice: false,\n\t\t\t},\n\t\t];\n\t}\n\treturn [];\n};\n","/*\n * Copyright 2024 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport { Signal } from 'vega';\n\nimport { hasTooltip } from '../marks/markUtils';\nimport { addHighlightedItemSignalEvents, addHighlightedSeriesSignalEvents } from '../signal/signalSpecBuilder';\nimport { TrendlineParentOptions, getTrendlines } from './trendlineUtils';\n\nexport const setTrendlineSignals = (signals: Signal[], markOptions: TrendlineParentOptions): void => {\n\tconst { idKey, name: markName } = markOptions;\n\tconst trendlines = getTrendlines(markOptions);\n\n\tif (trendlines.some((trendline) => hasTooltip(trendline))) {\n\t\taddHighlightedItemSignalEvents(signals, `${markName}Trendline_voronoi`, idKey, 2);\n\t\taddHighlightedSeriesSignalEvents(signals, `${markName}Trendline_voronoi`, 2);\n\t}\n\n\tif (trendlines.some((trendline) => trendline.displayOnHover)) {\n\t\taddHighlightedSeriesSignalEvents(signals, `${markName}_voronoi`, 2);\n\t}\n};\n","/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport { SignalRef } from 'vega';\n\nimport { FILTERED_TABLE, MS_PER_DAY, TRENDLINE_VALUE } from '@spectrum-charts/constants';\n\nimport {\n\tAggregateMethod,\n\tBarSpecOptions,\n\tColorFacet,\n\tLineSpecOptions,\n\tLineTypeFacet,\n\tOrientation,\n\tRegressionMethod as RscRegressionMethod,\n\tScaleType,\n\tScatterSpecOptions,\n\tTrendlineMethod,\n\tTrendlineOptions,\n\tTrendlineSpecOptions,\n\tWindowMethod,\n} from '../types';\n\n/** These are all the spec options that currently support trendlines */\nexport type TrendlineParentOptions = LineSpecOptions | ScatterSpecOptions | BarSpecOptions;\n\n/**\n * gets all the trendlines from the children and applies all the default trendline options\n * @param children\n * @param markName\n * @returns TrendlineSpecOptions[]\n */\nexport const getTrendlines = (markOptions: TrendlineParentOptions): TrendlineSpecOptions[] => {\n\treturn markOptions.trendlines.map((trendline, index) => applyTrendlinePropDefaults(markOptions, trendline, index));\n};\n\n/**\n * applies all the default trendline options\n * @param param0\n * @param markName\n * @param index\n * @returns TrendlineSpecOptions\n */\nexport const applyTrendlinePropDefaults = (\n\tmarkOptions: TrendlineParentOptions,\n\t{\n\t\tchartTooltips = [],\n\t\tcolor,\n\t\tdimensionExtent,\n\t\tdimensionRange = [null, null],\n\t\tdisplayOnHover = false,\n\t\thighlightRawPoint = false,\n\t\tlineType = 'dashed',\n\t\tlineWidth = 'M',\n\t\tmethod = 'linear',\n\t\topacity = 1,\n\t\torientation = 'horizontal',\n\t\ttrendlineAnnotations = [],\n\t\t...opts\n\t}: TrendlineOptions,\n\tindex: number\n): TrendlineSpecOptions => {\n\tconst dimensionScaleType = getTrendlineScaleType(markOptions, orientation);\n\tconst isDimensionNormalized =\n\t\tdimensionScaleType === 'time' && isRegressionMethod(method) && orientation === 'horizontal';\n\tconst { trendlineDimension, trendlineMetric } = getTrendlineDimensionMetric(\n\t\tmarkOptions.dimension,\n\t\tmarkOptions.metric,\n\t\torientation,\n\t\tisDimensionNormalized\n\t);\n\tconst trendlineColor = color ? { value: color } : getTrendlineColorFromMarkOptions(markOptions.color);\n\treturn {\n\t\tchartTooltips,\n\t\tcolorScheme: markOptions.colorScheme,\n\t\tdisplayOnHover,\n\t\tdimensionExtent: dimensionExtent ?? dimensionRange,\n\t\tdimensionRange,\n\t\tdimensionScaleType,\n\t\thighlightRawPoint,\n\t\tisDimensionNormalized,\n\t\tlineType,\n\t\tlineWidth,\n\t\tmethod,\n\t\tmetric: TRENDLINE_VALUE,\n\t\tname: `${markOptions.name}Trendline${index}`,\n\t\topacity,\n\t\torientation,\n\t\ttrendlineAnnotations,\n\t\ttrendlineColor,\n\t\ttrendlineDimension,\n\t\ttrendlineMetric,\n\t\t...opts,\n\t};\n};\n\n/**\n * Gets the color from the parent options.\n * Simplifies dual facet colors into a single facet\n * @param color\n * @returns color\n */\nexport const getTrendlineColorFromMarkOptions = (color: TrendlineParentOptions['color']): ColorFacet => {\n\treturn Array.isArray(color) ? color[0] : color;\n};\n\n/**\n * Gets the color from the parent options.\n * Simplifies dual facet colors into a single facet\n * @param lineType\n * @returns color\n */\nexport const getTrendlineLineTypeFromMarkOptions = (lineType: TrendlineParentOptions['lineType']): LineTypeFacet => {\n\treturn Array.isArray(lineType) ? lineType[0] : lineType;\n};\n\n/**\n * Gets the metric and dimension for the trendline, taking into account the orientation.\n * if isDimensionNormalized is true, the trendlineDimension will have `Normalized` appended to it\n * @param dimension\n * @param metric\n * @param orientation\n * @param isDimensionNormalized\n * @returns \\{trendlineDimension: string, trendlineMetric: string}\n */\nexport const getTrendlineDimensionMetric = (\n\tdimension: string,\n\tmetric: string,\n\torientation: Orientation,\n\tisDimensionNormalized: boolean\n): { trendlineDimension: string; trendlineMetric: string } => {\n\treturn orientation === 'horizontal'\n\t\t? {\n\t\t\t\ttrendlineDimension: normalizeTrendlineDimensionName(dimension, isDimensionNormalized),\n\t\t\t\ttrendlineMetric: metric,\n\t\t  }\n\t\t: {\n\t\t\t\ttrendlineDimension: metric,\n\t\t\t\ttrendlineMetric: dimension,\n\t\t  };\n};\n\n/**\n * If the dimension should be normalized, returns the normalized dimension name, otherwise returns the original dimension\n * @param dimension\n * @param method\n * @param scaleType\n * @returns dimension name\n */\nexport const normalizeTrendlineDimensionName = (dimension: string, isDimensionNormalized: boolean) =>\n\tisDimensionNormalized ? `${dimension}Normalized` : dimension;\n\n/**\n * determines if the supplied method is an aggregate method (average, median)\n * @see https://vega.github.io/vega/docs/transforms/aggregate/\n * @param method\n * @returns boolean\n */\nexport const isAggregateMethod = (method: TrendlineMethod): method is AggregateMethod =>\n\t['average', 'median'].includes(method);\n\n/**\n * determines if the supplied method is a regression method\n * @see https://vega.github.io/vega/docs/transforms/regression/\n * @param method\n * @returns boolean\n */\nexport const isRegressionMethod = (method: TrendlineMethod): method is RscRegressionMethod =>\n\tisPolynomialMethod(method) || ['exponential', 'logarithmic', 'power'].includes(method);\n\n/**\n * determines if the supplied method is a windowing method\n * @see https://vega.github.io/vega/docs/transforms/window/\n * @param method\n * @returns boolean\n */\nexport const isWindowMethod = (method: TrendlineMethod): method is WindowMethod => method.startsWith('movingAverage-');\n\n/**\n * determines if the supplied method is a polynomial method\n * @see https://vega.github.io/vega/docs/transforms/regression/\n * @param method\n * @returns boolean\n */\nexport const isPolynomialMethod = (method: TrendlineMethod): boolean =>\n\tmethod.startsWith('polynomial-') || ['linear', 'quadratic'].includes(method);\n\n/**\n * determines if any trendlines use the normalized dimension\n * @param markOptions\n * @returns boolean\n */\nexport const hasTrendlineWithNormalizedDimension = (markOptions: TrendlineParentOptions): boolean => {\n\tconst trendlines = getTrendlines(markOptions);\n\n\t// only need to add the normalized dimension transform if there is a regression trendline and the dimension scale type is time\n\treturn trendlines.some(\n\t\t({ dimensionScaleType, method }) => isRegressionMethod(method) && dimensionScaleType === 'time'\n\t);\n};\n\n/**\n * gets the order of the polynomial\n * y = a + b * x + … + k * pow(x, order)\n * @see https://vega.github.io/vega/docs/transforms/regression/\n * @param method trendline method\n * @returns order\n */\nexport const getPolynomialOrder = (method: TrendlineMethod): number => {\n\t// method is one of the named polynomial methods\n\tswitch (method) {\n\t\tcase 'linear':\n\t\t\treturn 1;\n\t\tcase 'quadratic':\n\t\t\treturn 2;\n\t}\n\n\t// method is of the form polynomial-<order>\n\tconst order = parseInt(method.split('-')[1]);\n\tif (order < 1) {\n\t\tthrow new Error(`Invalid polynomial order: ${order}, order must be an interger greater than 0`);\n\t}\n\treturn order;\n};\n\n/**\n * gets the extent used in the regression transform\n * @param dimensionExtent\n * @param name\n * @param isNormalized\n * @returns\n */\nexport const getRegressionExtent = (\n\tdimensionExtent: TrendlineSpecOptions['dimensionExtent'],\n\tname: string,\n\tisNormalized: boolean\n): SignalRef => {\n\tconst extentName = `${name}_extent`;\n\tconst extentSignal = dimensionExtent\n\t\t.map((value, i) => {\n\t\t\tswitch (value) {\n\t\t\t\tcase null:\n\t\t\t\t\treturn `${extentName}[${i}]`;\n\t\t\t\tcase 'domain':\n\t\t\t\t\treturn `${extentName}[${i}] ${i === 0 ? '-' : '+'} (${extentName}[1] - ${extentName}[0]) * 0.3`;\n\t\t\t\tdefault:\n\t\t\t\t\t// if this is a normalized date, we need to normalize the value\n\t\t\t\t\tif (isNormalized) {\n\t\t\t\t\t\treturn `(${value} - data('${FILTERED_TABLE}')[0].datetimeMin + ${MS_PER_DAY}) / ${MS_PER_DAY}`;\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t}\n\t\t})\n\t\t.join(', ');\n\n\treturn { signal: `[${extentSignal}]` };\n};\n\nexport const getTrendlineScaleType = (\n\tmarkOptions: TrendlineParentOptions,\n\ttrendlineOrientation: Orientation\n): ScaleType => {\n\t// y axis only support linear... for now...\n\tif (trendlineOrientation === 'vertical') return 'linear';\n\treturn 'scaleType' in markOptions ? markOptions.scaleType : markOptions.dimensionScaleType;\n};\n","/*\n * Copyright 2024 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport * from './trendlineAnnotationUtils';\n","/*\n * Copyright 2024 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport { ColorValueRef, GroupMark, NumericValueRef, ProductionRule, RectMark, SymbolMark, TextMark } from 'vega';\n\nimport { TRENDLINE_VALUE } from '@spectrum-charts/constants';\nimport { getColorValue } from '@spectrum-charts/themes';\n\nimport { getColorProductionRule, getColorProductionRuleSignalString } from '../marks/markUtils';\nimport { getScaleName } from '../scale/scaleSpecBuilder';\nimport { getLineWidthPixelsFromLineWidth } from '../specUtils';\nimport {\n\tgetEndDimensionExtentProductionRule,\n\tgetStartDimensionExtentProductionRule,\n} from '../trendline/trendlineMarkUtils';\nimport { ColorFacet, TrendlineAnnotationOptions, TrendlineAnnotationSpecOptions, TrendlineSpecOptions } from '../types';\n\n/**\n * Applies all trendline annotation defaults\n * @param trenlineAnnotationOptions\n * @param index\n * @param trendlineOptions\n * @param markName\n * @returns TrendlineAnnotationSpecOptions\n */\nexport const getTrendlineAnnotationSpecOptions = (\n\t{ badge = false, dimensionValue = 'end', numberFormat = '', prefix = '' }: TrendlineAnnotationOptions,\n\tindex: number,\n\t{\n\t\tcolorScheme,\n\t\tdimensionExtent,\n\t\tdimensionScaleType,\n\t\tdisplayOnHover,\n\t\tlineWidth,\n\t\torientation,\n\t\ttrendlineColor,\n\t\ttrendlineDimension,\n\t\tname: trendlineName,\n\t}: TrendlineSpecOptions,\n\tmarkName: string\n): TrendlineAnnotationSpecOptions => ({\n\tbadge,\n\tcolorScheme,\n\tdimensionValue,\n\tdisplayOnHover,\n\tmarkName,\n\tname: `${trendlineName}Annotation${index}`,\n\tnumberFormat,\n\tprefix,\n\ttrendlineColor,\n\ttrendlineDimension,\n\ttrendlineDimensionExtent: dimensionExtent,\n\ttrendlineDimensionScaleType: dimensionScaleType,\n\ttrendlineName: trendlineName,\n\ttrendlineOrientation: orientation,\n\ttrendlineWidth: getLineWidthPixelsFromLineWidth(lineWidth),\n});\n\n/**\n * Gets all the annotations on a trendline\n * @param trendlineOptions\n * @param markName\n * @returns TrendlineAnnotationSpecOptions[]\n */\nexport const getTrendlineAnnotations = (\n\ttrendlineOptions: TrendlineSpecOptions,\n\tmarkName: string\n): TrendlineAnnotationSpecOptions[] => {\n\treturn trendlineOptions.trendlineAnnotations.map((annotationOptions, index) =>\n\t\tgetTrendlineAnnotationSpecOptions(annotationOptions, index, trendlineOptions, markName)\n\t);\n};\n\n/**\n * Gets all the trendline annotation marks\n * @param trendlineOptions\n * @param markName\n * @returns GroupMark[]\n */\nexport const getTrendlineAnnotationMarks = (trendlineOptions: TrendlineSpecOptions, markName: string): GroupMark[] => {\n\tconst marks: GroupMark[] = [];\n\tconst annotations = getTrendlineAnnotations(trendlineOptions, markName);\n\n\tannotations.forEach((annotation) => {\n\t\tmarks.push({\n\t\t\tname: `${annotation.name}_group`,\n\t\t\ttype: 'group',\n\t\t\tinteractive: false,\n\t\t\tmarks: [\n\t\t\t\tgetTrendlineAnnotationPoints(annotation),\n\t\t\t\tgetTrendlineAnnotationTextMark(annotation),\n\t\t\t\t...getTrendlineAnnotationBadgeMark(annotation),\n\t\t\t],\n\t\t});\n\t});\n\treturn marks;\n};\n\n/**\n * Gets the annotation points\n * @param trendlineAnnotationOptions\n * @returns SymbolMark\n */\nconst getTrendlineAnnotationPoints = (annotationOptions: TrendlineAnnotationSpecOptions): SymbolMark => {\n\tconst { name, trendlineName, trendlineWidth, displayOnHover } = annotationOptions;\n\tconst data = displayOnHover ? `${trendlineName}_highlightedData` : `${trendlineName}_highResolutionData`;\n\treturn {\n\t\tname: `${name}_points`,\n\t\ttype: 'symbol',\n\t\tfrom: { data },\n\t\tinteractive: false,\n\t\tencode: {\n\t\t\tenter: {\n\t\t\t\topacity: { value: 0 },\n\t\t\t\tsize: { value: Math.pow(trendlineWidth, 2) },\n\t\t\t\tx: getTrendlineAnnotationPointX(annotationOptions),\n\t\t\t\ty: getTrendlineAnnotationPointY(annotationOptions),\n\t\t\t},\n\t\t},\n\t};\n};\n\n/**\n * Gets the correct x rule for the annotation point\n * @param trendlineAnnotationOptions\n * @returns NumericValueRef\n */\nexport const getTrendlineAnnotationPointX = ({\n\tdimensionValue,\n\ttrendlineDimension,\n\ttrendlineDimensionExtent,\n\ttrendlineDimensionScaleType,\n\ttrendlineOrientation,\n}: TrendlineAnnotationSpecOptions): NumericValueRef => {\n\tconst scale = getScaleName('x', trendlineDimensionScaleType);\n\tif (trendlineOrientation === 'vertical') {\n\t\treturn { scale, field: TRENDLINE_VALUE };\n\t}\n\tswitch (dimensionValue) {\n\t\tcase 'start':\n\t\t\treturn getStartDimensionExtentProductionRule(trendlineDimensionExtent[0], trendlineDimension, scale, 'x');\n\t\tcase 'end':\n\t\t\treturn getEndDimensionExtentProductionRule(trendlineDimensionExtent[1], trendlineDimension, scale, 'x');\n\t\tdefault:\n\t\t\treturn { scale, value: dimensionValue };\n\t}\n};\n\n/**\n * Gets the correct y rule for the annotation point\n * @param trendlineAnnotationOptions\n * @returns NumericValueRef\n */\nexport const getTrendlineAnnotationPointY = ({\n\tdimensionValue,\n\ttrendlineDimension,\n\ttrendlineDimensionExtent,\n\ttrendlineOrientation,\n}: TrendlineAnnotationSpecOptions): NumericValueRef => {\n\tconst scale = 'yLinear';\n\tif (trendlineOrientation === 'horizontal') {\n\t\treturn { scale, field: TRENDLINE_VALUE };\n\t}\n\tswitch (dimensionValue) {\n\t\tcase 'start':\n\t\t\treturn getStartDimensionExtentProductionRule(trendlineDimensionExtent[0], trendlineDimension, scale, 'y');\n\t\tcase 'end':\n\t\t\treturn getEndDimensionExtentProductionRule(trendlineDimensionExtent[1], trendlineDimension, scale, 'y');\n\t\tdefault:\n\t\t\treturn { scale, value: dimensionValue };\n\t}\n};\n\n/**\n * Gets the annotation text mark\n * @param trendlineAnnotationOptions\n * @returns TextMark\n */\nexport const getTrendlineAnnotationTextMark = (annotation: TrendlineAnnotationSpecOptions): TextMark => {\n\tconst { name, numberFormat, prefix, trendlineName, markName } = annotation;\n\tconst textPrefix = prefix ? `'${prefix} ' + ` : '';\n\tconst fill = getTextFill({ ...annotation });\n\treturn {\n\t\tname,\n\t\ttype: 'text',\n\t\tfrom: { data: `${name}_points` },\n\t\tzindex: 1, // this will draw the text in front of the badge\n\t\tinteractive: false,\n\t\tencode: {\n\t\t\tenter: {\n\t\t\t\ttext: { signal: `${textPrefix}format(datum.datum.${TRENDLINE_VALUE}, '${numberFormat}')` },\n\t\t\t\tfill,\n\t\t\t},\n\t\t},\n\t\ttransform: [\n\t\t\t{\n\t\t\t\ttype: 'label',\n\t\t\t\tsize: { signal: '[width, height]' },\n\t\t\t\tavoidMarks: [trendlineName, `${markName}_group`],\n\t\t\t\toffset: [6, 6, 6, 6, 8.49, 8.49, 8.49, 8.49],\n\t\t\t\tanchor: ['top', 'bottom', 'right', 'left', 'top-right', 'top-left', 'bottom-right', 'bottom-left'],\n\t\t\t},\n\t\t],\n\t};\n};\n\n/**\n * Get's the encoding for the annotation text fill.\n * Includes a color contrast check to ensure the text is visually a11y.\n * @param trendlineAnnotationOptions\n * @returns fill ProductionRule\n */\nexport const getTextFill = ({\n\tbadge,\n\tcolorScheme,\n\ttrendlineColor,\n}: TrendlineAnnotationSpecOptions): ProductionRule<ColorValueRef> | undefined => {\n\tif (!badge) {\n\t\t// by returning undefined, the rsc config will be used\n\t\treturn undefined;\n\t}\n\tconst color = getColorKey(trendlineColor);\n\tconst colorString = getColorProductionRuleSignalString(color, colorScheme);\n\tconst textColors = [getColorValue('gray-50', colorScheme), getColorValue('gray-900', colorScheme)];\n\treturn [\n\t\t{ test: `contrast(${colorString}, '${textColors[0]}') >= 4.5`, value: textColors[0] },\n\t\t{ value: textColors[1] },\n\t];\n};\n\nexport const getTrendlineAnnotationBadgeMark = ({\n\tbadge,\n\tcolorScheme,\n\tname,\n\ttrendlineColor,\n}: TrendlineAnnotationSpecOptions): RectMark[] => {\n\tif (!badge) {\n\t\treturn [];\n\t}\n\tconst color = getColorKey(trendlineColor, 2);\n\treturn [\n\t\t{\n\t\t\tname: `${name}_badge`,\n\t\t\tdescription: `${name}_badge`,\n\t\t\ttype: 'rect',\n\t\t\tfrom: { data: `${name}` },\n\t\t\tinteractive: false,\n\t\t\tencode: {\n\t\t\t\tenter: {\n\t\t\t\t\tcornerRadius: { value: 2 },\n\t\t\t\t\tfill: getColorProductionRule(color, colorScheme),\n\t\t\t\t\topacity: { field: 'opacity' },\n\t\t\t\t\tx: { signal: 'datum.bounds.x1 - 3' },\n\t\t\t\t\tx2: { signal: 'datum.bounds.x2 + 3' },\n\t\t\t\t\ty: { signal: 'datum.bounds.y1 - 3' },\n\t\t\t\t\ty2: { signal: 'datum.bounds.y2 + 3' },\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t];\n};\n\n/**\n * Gets the key used for color.\n * Since some of the marks base their data off of previous marks, the datum might be nested.\n * @param trendlineColor\n * @param datumOrder how many levels deep the datum is (ex. 1 becomes datum.color, 2 becomes datum.datum.color, etc.)\n * @returns\n */\nexport const getColorKey = (trendlineColor: ColorFacet, datumOrder: number = 1): ColorFacet => {\n\tif (typeof trendlineColor === 'string') {\n\t\treturn `${new Array(datumOrder).fill('datum.').join('')}${trendlineColor}`;\n\t}\n\treturn trendlineColor;\n};\n","/*\n * Copyright 2025 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport * from './axisSpec.types';\nexport * from './axisAnnotationSpec.types';\nexport * from './referenceLineSpec.types';\n","/*\n * Copyright 2025 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport * from './chartPopoverSpec.types';\nexport * from './chartTooltipSpec.types';\n","/*\n * Copyright 2025 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport * from './chartSpec.types';\nexport * from './legendSpec.types';\nexport * from './spectrumVizColor.types';\nexport * from './titleSpec.types';\nexport * from './specUtil.types';\n\nexport * from './axis';\nexport * from './dialogs';\nexport * from './marks';\n","/*\n * Copyright 2025 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport * from './areaSpec.types';\nexport * from './barSpec.types';\nexport * from './bigNumberSpec.types';\nexport * from './bulletSpec.types';\nexport * from './comboSpec.types';\nexport * from './donutSpec.types';\nexport * from './lineSpec.types';\nexport * from './scatterSpec.types';\n\nexport * from './supplemental';\n","/*\n * Copyright 2025 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport * from './barAnnotationSpec.types';\nexport * from './dountSummarySpec.types';\nexport * from './metricRangeSpec.types';\nexport * from './scatterPathSpec.types';\nexport * from './segmentLabelSpec.types';\nexport * from './trendlineSpec.types';\nexport * from './trendlineAnnotationSpec.types';\n","/*\n * Copyright 2025 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport { SymbolShape } from 'vega';\n\nimport { GROUP_DATA, MARK_ID, SERIES_ID, TRENDLINE_VALUE } from '@spectrum-charts/constants';\n\nimport { SpectrumVizColor } from './spectrumVizColor.types';\n\nexport type PartiallyRequired<T, K extends keyof T> = Omit<T, K> & Required<Pick<T, K>>;\n\nexport interface MarkBounds {\n\tx1: number;\n\tx2: number;\n\ty1: number;\n\ty2: number;\n}\n\nconst DatumPredefinedKey = {\n\tmarkId: MARK_ID,\n\tseriesId: SERIES_ID,\n\ttrendlineValue: TRENDLINE_VALUE,\n\tgroupData: GROUP_DATA,\n} as const;\n\nexport type Datum = object & {\n\t[DatumPredefinedKey.markId]: number;\n\t[DatumPredefinedKey.seriesId]: string;\n\t[DatumPredefinedKey.trendlineValue]?: number;\n\t[DatumPredefinedKey.groupData]?: Datum[];\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t[key: string]: any;\n};\n\nexport type NumberFormat = 'currency' | 'shortCurrency' | 'shortNumber' | 'standardNumber' | string;\nexport type Orientation = 'vertical' | 'horizontal';\nexport type Position = 'left' | 'right' | 'top' | 'bottom';\nexport type ScaleType = 'linear' | 'point' | 'time' | 'band';\nexport type ChartSymbolShape = 'rounded-square' | SymbolShape | string;\n\n/**\n * Stroke dasharray for the line.\n *\n * solid: null,\n * dashed: 7 4,\n * dotted: 2 3,\n * dotDash: 2 3 7 4,\n * shortDash: 3 4,\n * longDash: 11 4,\n * twoDash: 5 2 11 2\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-dasharray\n */\nexport type LineType = 'solid' | 'dashed' | 'dotted' | 'dotDash' | 'shortDash' | 'longDash' | 'twoDash' | number[];\n\n/**\n * Width of line in pixels\n *\n * XS: 1px,\n * S: 1.5px,\n * M: 2px,\n * L: 3px,\n * XL: 4px\n * */\nexport type LineWidth = 'XS' | 'S' | 'M' | 'L' | 'XL' | number;\n\n/**\n * Width of the trail in pixels\n *\n * XS: 6px,\n * S: 8px,\n * M: 10px,\n * L: 12px,\n * XL: 16px\n * */\nexport type PathWidth = 'XS' | 'S' | 'M' | 'L' | 'XL' | number;\n\n/**\n * Width of the symbol in pixels\n *\n * XS: 6px,\n * S: 8px,\n * M: 10px,\n * L: 12px,\n * XL: 16px\n * */\nexport type SymbolSize = 'XS' | 'S' | 'M' | 'L' | 'XL' | number;\n\nexport type StaticValue<T> = { value: T };\nexport type FacetRef<T> = string | StaticValue<T>;\n\nexport type ColorFacet = FacetRef<SpectrumVizColor | string>;\nexport type LineTypeFacet = FacetRef<LineType>;\nexport type LineWidthFacet = FacetRef<LineWidth>;\nexport type OpacityFacet = FacetRef<number>;\nexport type PathWidthFacet = FacetRef<PathWidth>;\nexport type SymbolSizeFacet = FacetRef<SymbolSize>;\nexport type SymbolShapeFacet = FacetRef<ChartSymbolShape>;\n\nexport type FacetType =\n\t| 'color'\n\t| 'linearColor'\n\t| 'lineType'\n\t| 'lineWidth'\n\t| 'opacity'\n\t| 'symbolShape'\n\t| 'symbolSize'\n\t| 'symbolPathWidth';\n\nexport type SecondaryFacetType =\n\t| 'secondaryColor'\n\t| 'secondaryLineType'\n\t| 'secondaryLineWidth'\n\t| 'secondaryOpacity'\n\t| 'secondarySymbolShape'\n\t| 'secondarySymbolSize'\n\t| 'secondarySymbolPathWidth';\n\n// vega production rule type\nexport type ProductionRuleTests<T> = ({\n\ttest?: string;\n} & T)[];\n","module.exports = __WEBPACK_EXTERNAL_MODULE__9633__;","module.exports = __WEBPACK_EXTERNAL_MODULE__1274__;","module.exports = __WEBPACK_EXTERNAL_MODULE__8365__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(7783);\n"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE__9633__","__WEBPACK_EXTERNAL_MODULE__1274__","__WEBPACK_EXTERNAL_MODULE__8365__","isMergeableObject","value","isNonNullObject","stringValue","Object","prototype","toString","call","$$typeof","REACT_ELEMENT_TYPE","isReactElement","isSpecial","Symbol","for","cloneUnlessOtherwiseSpecified","options","clone","deepmerge","val","Array","isArray","defaultArrayMerge","target","source","concat","map","element","getKeys","keys","getOwnPropertySymbols","filter","symbol","propertyIsEnumerable","getEnumerableOwnPropertySymbols","propertyIsOnObject","object","property","_","arrayMerge","sourceIsArray","destination","forEach","key","hasOwnProperty","propertyIsUnsafe","customMerge","getMergeFunction","mergeObject","all","array","Error","reduce","prev","next","deepmerge_1","e","ne","defineProperty","ge","getOwnPropertyDescriptor","be","getOwnPropertyNames","Te","Be","t","r","get","enumerable","Ae","Immer","J","applyPatches","Ce","castDraft","ke","castImmutable","Ke","createDraft","Re","current","re","enableMapSet","xe","enablePatches","Pe","finishDraft","ve","freeze","K","immerable","N","isDraft","O","isDraftable","A","nothing","j","original","le","produce","Fe","produceWithPatches","Ne","setAutoFreeze","ze","setUseStrictShallowCopy","je","n","i","Ie","u","h","z","getPrototypeOf","ye","constructor","v","k","Oe","Function","C","Reflect","ownKeys","o","R","has","X","Q","set","add","Map","Set","T","L","slice","getOwnPropertyDescriptors","f","length","l","c","writable","configurable","create","assign","$","clear","delete","Me","entries","isFrozen","U","ae","w","Y","B","oe","b","V","Z","a","we","ie","p","P","d","_e","x","m","se","s","ee","te","de","g","y","ue","me","Ee","ce","fe","W","pe","E","Number","isNaN","deleteProperty","setPrototypeOf","q","S","arguments","apply","autoFreeze","useStrictShallowCopy","path","op","I","D","revoke","proxy","Proxy","revocable","he","push","Se","from","H","F","join","splice","unshift","super","size","values","iterator","done","JSON","stringify","M","bind","addArea","spec","chartPopovers","chartTooltips","color","DEFAULT_COLOR","colorScheme","DEFAULT_COLOR_SCHEME","dimension","DEFAULT_TIME_DIMENSION","index","metric","DEFAULT_METRIC","metricStart","metricEnd","name","opacity","scaleType","areaOptions","toCamelCase","console","error","undefined","data","addData","signals","addSignals","scales","setScales","marks","addAreaMarks","highlightedItem","order","tableData","getTableData","transform","addTimeTransform","filteredTableData","getFilteredTableData","type","groupby","field","sort","getTransformSort","as","isInteractive","areaHasPopover","hasPopover","areaHasTooltip","hasTooltip","getAreaHighlightedData","idKey","isHighlightedByGroup","FILTERED_TABLE","expr","SELECTED_SERIES","addTooltipData","hasGroupId","HIGHLIGHTED_ITEM","SELECTED_ITEM","addHighlightedSeriesSignalEvents","excludeDataKeys","addHighlightedItemEvents","getControlledHoveredGroupSignal","getControlledHoveredIdSignal","addTooltipSignals","areaName","highlightedItemSignal","find","signal","on","events","update","padding","addContinuousDimensionScale","addFieldToFacetScaleDomain","COLOR_SCALE","addMetricScale","isStacked","facet","getAreaMark","getAnchorPointMark","getSelectedAreaMarks","getHoverMarks","interactive","encode","enter","scale","stroke","fill","getX","highlightMarks","BACKGROUND_COLOR","isHighlightedByDimension","y2","strokeWidth","spectrumColors","light","strokeJoin","getAreaOpacity","displayOnHover","isMetricRange","fadedOpacity","HIGHLIGHT_CONTRAST_RATIO","test","HIGHLIGHTED_SERIES","SERIES_ID","DEFAULT_OPACITY_RULE","opacityRules","dataSource","description","getColorProductionRule","tooltip","getTooltip","getBorderStrokeEncodings","cursor","getCursor","fillOpacity","DEFAULT_TRANSFORMED_TIME_DIMENSION","getLabelValue","label","getTimeLabelFormats","granularity","secondaryLabelFormat","primaryLabelFormat","tickCount","interval","step","getControlledLabelAnchorValues","position","labelOrientaion","labelAlign","getLabelAnchor","align","baseline","getLabelAnchorValues","vegaLabelAlign","vegaLabelBaseline","labelBaseline","labelIsParallelToAxis","start","center","end","includes","getLabelAngle","getLabelBaseline","isVerticalAxis","getLabelOffset","scaleName","vegaLabelOffset","getLabelFormat","labelFormat","labelOrientation","numberFormat","truncateLabels","currencyLocale","currencyCode","getTextNumberFormat","getAxisLabelsEncoding","labelFontWeight","labelKey","signalName","text","fontWeight","getEncodedLabelAnchor","defaultLabelAlign","baseTestString","baseSignalString","getReferenceLines","axisOptions","referenceLines","referenceLine","applyReferenceLineOptionDefaults","iconColor","DEFAULT_FONT_COLOR","labelColor","DEFAULT_LABEL_FONT_WEIGHT","layer","scaleTypeSupportsReferenceLines","Boolean","getReferenceLineMarks","referenceLineMarks","back","front","positionEncoding","getPositionEncoding","getReferenceLineRuleMark","getReferenceLineSymbolMark","getReferenceLineTextMark","signalValue","halfInnerPaddingFormula","ticks","startOffset","positionOptions","top","bottom","left","x2","right","getColorValue","getAdditiveMarkPositionOptions","offset","horizontalOffset","icon","shape","getPathFromIcon","referenceLineOptions","getReferenceLineLabelsEncoding","VERTICAL_OFFSET","HORIZONTAL_OFFSET","getEncodedLabelBaselineAlign","setAxisBaseline","axis","domain","domainWidth","addAxis","axisAnnotations","baselineOffset","DEFAULT_GRANULARITY","grid","hideDefaultLabels","DEFAULT_LABEL_ALIGN","DEFAULT_LABEL_ORIENTATION","labels","range","subLabels","getScale","opposingScaleType","getOpposingScaleType","addAxisData","addAxisSignals","axes","addAxes","isTrellisedChart","addAxesMarks","getAxisAnnotationsFromChildren","annotationOptions","addAxisAnnotationData","getGenericValueSignal","getLabelSignalValue","hasSubLabels","addAxisAnnotationSignals","newAxes","getTrellisAxisOptions","getTimeAxes","getDefaultAxis","titlePadding","getSubLabelAxis","referenceLineLabel","linePosition","addAxisAnnotationAxis","trellisGroupMark","mark","isTrellised","baselineRule","getBaselineRule","addBaseline","trellisOrientation","startsWith","axisOrientation","title","encodeAxisTitle","addAxesToTrellisGroup","addAxisAnnotationMarks","trellisAxisOptions","labelOffsetSignal","axisType","vegaLabelPadding","facetName","facetGroupBy","trellisScaleName","getTrellisGroupProperties","groupMark","fromFacet","tickMinStep","orient","getTickCount","labelAngle","labelOffset","labelPadding","getSecondaryTimeAxis","getPrimaryTimeAxis","formatType","labelSeparation","getSecondaryTimeAxisLabelFormatting","format","labelOverlap","dy","subLabelValues","subLabelAxis","applicableScales","getRange","getDefaultScaleNameFromPosition","getOpposingRange","getDefaultOpposingScaleNameFromPosition","orientation","dataKey","getAxisAnnotationDetailData","getAxisAnnotationSummaryData","getAxisAnnotationAggregateData","getAxisAnnotationRangeData","option","fields","ops","getHighlightAxisAnnotationSignal","getClickAxisAnnotationSignal","getSelectAxisAnnotationSignal","markname","between","axisAnnotationOptions","getAxisAnnotationSummaryMarks","getAxisAnnotationSpanMarks","zindex","ANNOTATION_SINGLE_ICON_SVG","xc","yc","band","width","height","ANNOTATION_RANGED_ICON_SVG","axisName","annotation","annotationIndex","applyDefaultAxisAnnotationOptions","DEFAULT_AXIS_ANNOTATION_OFFSET","DEFAULT_AXIS_ANNOTATION_COLOR","axisTypeSupportsAxisAnnotations","getAnnotationMarks","barOptions","dataName","dimensionScaleName","dimensionName","dimensionField","barAnnotations","textKey","applyAnnotationPropDefaults","getAnnotation","getAnnotationTextMark","getAnnotationBackgroundMark","style","metricAxis","dimensionAxis","getOrientationProperties","annotationWidth","getAnnotationWidth","annotationPosition","getAnnotationMetricAxisPosition","getMinBandwidth","fontSize","ANNOTATION_FONT_SIZE","ANNOTATION_FONT_WEIGHT","getAnnotationXEncode","ANNOTATION_PADDING","cornerRadius","getAnnotationPositionOffset","isDodgedAndStacked","metricScaleKey","scaleKey","positionOffset","addBar","DEFAULT_CATEGORICAL_DIMENSION","hasOnClick","hasSquareCorners","lineType","lineWidth","paddingRatio","PADDING_RATIO","trellisPadding","TRELLIS_PADDING","trendlines","barName","dimensionScaleType","interactiveMarkName","getInteractiveMarkName","addScales","addMarks","paddingOuter","barPaddingOuter","paddingInner","getBarPadding","addHighlightedItemSignalEvents","setTrendlineSignals","dimensionDataType","TIME","findIndex","getStackFields","getStackIdTransform","getStackAggregateData","getDodgeGroupTransform","addTrendlineData","addPopoverData","STACK_ID","trellis","facets","secondaryFacets","getFacetsFromOptions","getScaleValues","addDimensionScale","addTrellisScale","LINE_TYPE_SCALE","OPACITY_SCALE","addSecondaryScales","getScaleIndexByType","addDomainFields","secondaryScaleName","secondaryIndex","getScaleIndexByName","primaryIndex","primaryScale","barMarks","getDodgedAndStackedBarMark","getStackedBarMarks","getDodgedMark","getPopovers","some","popover","UNSAFE_highlightBy","getDimensionSelectionRing","repeatedScale","getRepeatedScale","getTrellisGroupMark","getTrendlineMarks","getMetricScale","getDimensionScale","getDefaultScale","getDodgedGroupMark","groupedPadding","dimensionScaleKey","rangeScale","getTrellisProperties","getDodgedDimensionEncodings","getTrellisedDimensionEncodings","getMetricEncodings","startKey","endKey","getStackedMetricEncodings","startValue","endValue","getCornerRadiusEncodings","Math","max","CORNER_RADIUS","getLineWidthPixelsFromLineWidth","rectEncodeEntry","getStackedCornerRadiusEncodings","cornerRadiusTopLeft","cornerRadiusTopRight","cornerRadiusBottomLeft","cornerRadiusBottomRight","rotateRectClockwiseIfNeeded","topTestString","bottomTestString","getBaseBarEnterEncodings","getBarEnterEncodings","getOpacityProductionRule","getBarUpdateEncodings","getMarkOpacity","getStroke","strokeDash","getStrokeDash","getStrokeWidth","defaultProductionRule","SELECTED_GROUP","getStrokeDashProductionRule","lineWidthValue","popovers","popoverWithDimensionHighlightExists","getBandPadding","getStackedBackgroundBar","getStackedBar","getBaseDataSourceName","getStackedDimensionEncodings","markName","trellisAxis","trellisRangeScale","trellisScaleIndex","getTrellisedEncodeEntries","generateThresholdColorExpr","thresholds","metricField","defaultColor","sorted","thresholdMin","exprParts","nextLower","getBulletTableData","TABLE","getBulletTransforms","bulletOptions","transforms","maxScaleValue","thresholdBarColor","getBulletMarkRect","bulletMarkRectEncodeUpdateYSignal","showTarget","showTargetValue","fillColor","getBulletMarkTarget","solidColor","bulletMarkTargetEncodeUpdateY","bulletMarkTargetEncodeUpdateY2","getBulletMarkLabel","barLabelColor","getBulletMarkValueLabel","encodeUpdateSignalWidth","direction","fillExpr","getBulletMarkTargetValueLabel","getBulletMarkThreshold","baseHeightSignal","encodeUpdateYSignal","clip","getBulletTrack","trackColor","trackWidth","trackY","getBulletLabelAxesLeft","tickSize","getBulletLabelAxesRight","markGroupEncodeUpdateDirection","bulletGroupWidth","bulletMark","track","labelPosition","getBulletGroupHeightExpression","addBullet","DEFAULT_BULLET_DIRECTION","DEFAULT_LABEL_POSITION","DEFAULT_SCALE_TYPE","DEFAULT_SCALE_VALUE","groupScaleRangeSignal","xRange","domainFields","round","clamp","zero","chartPopover","applyPopoverPropDefaults","markOptions","addHighlightedData","filteredTable","markType","getGroupIdTransform","getMarkSelectedData","highlightBy","backgroundColor","DEFAULT_BACKGROUND_COLOR","colors","hiddenSeries","highlightedSeries","MARK_ID","legends","lineTypes","DEFAULT_LINE_TYPES","lineWidths","opacities","symbolShapes","symbolSizes","titles","initializeSpec","getDefaultSignals","getDefaultScales","areaCount","barCount","bulletCount","comboCount","donutCount","lineCount","scatterCount","initializeComponentCounts","specOptions","acc","addCombo","addDonut","addLine","addScatter","legend","addLegend","addTitle","parse","getFacetsFromScales","setHoverOpacityForMarks","removeUnusedScales","signalBackgroundColor","getTwoDimensionalColorScheme","getTwoDimensionalLineTypes","getTwoDimensionalOpacities","HIGHLIGHTED_GROUP","isColors","getColors","isLineTypeArray","getStrokeDashesFromLineTypes","lineTypeArray","isNumberArray","getColorScale","getLinearColorScale","getLineTypeScale","getLineWidthScale","getOpacityScale","getSymbolShapeScale","getSymbolSizeScale","getSymbolPathWidthScale","colorSchemes","getStrokeDashFromLineType","getOrdinalScale","LINEAR_COLOR_SCALE","lineTypesArray","isSymbolShapeArray","symbolShape","getPathFromSymbolShape","getPathsFromSymbolShapes","SYMBOL_SHAPE_SCALE","SYMBOL_SIZE_SCALE","symbolSize","getVegaSymbolSizeFromRscSymbolSize","SYMBOL_PATH_WIDTH_SCALE","getSymbolWidthFromRscSymbolSize","LINE_WIDTH_SCALE","opacityArray","getSeriesIdTransform","datum","isColorScale","isStrokeDashArray","getTooltips","chartTooltip","applyTooltipPropDefaults","tooltips","getMarkHighlightedData","highlightedGroupSignal","interactionMode","INTERACTION_MODE","ITEM","getHoverMarkNames","addMouseEvents","addHighlightMarkOpacityRules","comboName","getComboMarkName","getDimension","displayName","getDisplayName","combineNames","charAt","toUpperCase","units","getFilteredTooltipData","excludeDataKey","donutSummaries","startAngle","holeRatio","isBoolean","segmentLabels","donutOptions","filteredTableIndex","getPieTransforms","getDonutSummaryData","endAngle","getDonutSummaryScales","getArcMark","getDonutSummaryMarks","getSegmentLabelMarks","getDonutSummarySignals","getDonutSummary","applyDonutSummaryPropDefaults","donutName","DONUT_RADIUS","DONUT_SUMMARY_FONT_SIZE_RATIO","donutSummary","getBooleanDonutSummaryGroupMark","getDonutSummaryGroupMark","getSummaryValueEncode","getSummaryLabelEncode","getSummaryValueText","DONUT_SUMMARY_MIN_RADIUS","getSummaryValueBaseline","limit","getSummaryValueLimit","fontHeight","padAngle","innerRadius","outerRadius","segmentLabel","percent","valueFormat","applySegmentLabelPropDefaults","getSegmentLabel","getSegmentLabelTextMark","getSegmentLabelValueTextMark","getBaseSegmentLabelEnterEncode","positionEncodings","getSegmentLabelValueText","radius","theta","getSegmentLabelFontSize","percentSignal","rules","rule","DONUT_SEGMENT_LABEL_MIN_ANGLE","facetScaleNames","getFacets","ordinalFacets","continuousFacets","isScaleWithMultiFields","facetType","getFacetsFromKeys","scaleHasKey","flattenMarks","markUsesSeriesColorScale","highlightOpacityRule","getHighlightOpacityRule","opacityRuleInsertIndex","result","isGroupMark","hasMouseInteraction","hiddenEntries","highlight","isToggleable","formattedColor","formattedLineType","formattedLineWidth","formattedSymbolShape","formatFacetRefsWithPresets","legendOptions","uniqueFacetFields","getCategoricalLegend","getContinuousLegend","labelLimit","getEncodings","columns","getColumns","getLegendLayout","symbolType","getSymbolType","gradientThickness","getHiddenEntriesFilter","legendLabels","addHighlighSignalLegendHoverEvents","symbolEncodings","getSymbolEncodings","hoverEncodings","getHoverEncodings","legendLabelsEncodings","getLegendLabelsEncodings","showHideEncodings","getShowHideEncodings","mergeLegendEncodings","descriptions","getOpacityEncoding","symbols","COMPONENT_NAME","highlightSignalName","getSymbolFacetEncoding","customValue","getHiddenSeriesColorRule","secondaryFacetMapping","linearColor","symbolPathWidth","secondaryFacet","colorValue","hiddenSeriesEncode","clickEncode","encodings","mergedEncodings","encoding","getLineHighlightedData","highlightedExpr","getLineStaticPointData","staticPoint","isSparkline","isMethodLast","getLineMark","lineMarkOptions","getYProductionRule","strokeOpacity","getLineWidthProductionRule","getXProductionRule","getLineOpacity","popoverMarkName","strokeOpacityRules","getLineHoverMarks","lineOptions","secondaryHighlightedMetric","getHoverRule","getHighlightBackgroundPoint","getSelectRingPoint","getSelectionPoint","getHighlightPoint","getSecondaryHighlightPoint","getInteractiveMarks","DEFAULT_INTERACTION_MODE","nearest","getVoronoiMarks","item","getItemHoverMarks","getPointsForVoronoi","getVoronoiPath","getItemHoverArea","staticPointTest","getSelectedTest","getLineStaticPoint","pointSize","getHighlightPointSize","getHighlightPointStrokeWidth","getHighlightOrSelectionPoint","useHighlightedData","getHighlightPointFill","getHighlightPointStroke","getHighlightPointStrokeOpacity","fillRules","selectedTest","strokeRules","baseOpacityRule","getHighlightOpacityValue","sizeRules","DEFAULT_SYMBOL_SIZE","strokeWidthRules","DEFAULT_SYMBOL_STROKE_WIDTH","metricRanges","lineName","getPopoverMarkName","addLineMarks","getMetricRangeData","getMetricRangeSignals","addHoverSignals","getMetricKeys","getTrendlineScales","getMetricRangeGroupMarks","metricKeys","getMetricRanges","metricRange","scaleAxisToFit","hoverMarkName","nestedDatum","defaultTooltip","isArea","trendline","colorScaleType","colorScaleName","getColorProductionRuleSignalString","colorRule","getSymbolSizeProductionRule","opacityValue","getScaleName","isVoronoi","getHoverSizes","getHoverMarkName","HOVER_SHAPE","getHoverSizeSignal","HOVER_SHAPE_COUNT","HOVER_SIZE","applyMetricRangeOptionDefaults","rangeOpacity","metricRangeOptions","getMetricRangeMark","parentName","generateScale","isScaleMultiFieldsRef","getDimensionField","overridePadding","chartOrientation","facetValue","facetField","isDimensionAxis","vertical","horizontal","getPadding","nice","LINEAR_PADDING","DISCRETE_PADDING","addScatterMarks","scatterGroup","getScatterMark","getScatterHoverMarks","getScatterSelectMarks","getScatterPathMarks","blend","getOpacity","scatterOptions","fadedValue","getSelectRingSize","baseSize","pow","sqrt","DEFAULT_LINEAR_DIMENSION","DEFAULT_DIMENSION_SCALE_TYPE","scatterPaths","scatterName","setScatterPathScales","getScatterPathSpecOptions","groupBy","pathWidth","scatterPathOptions","scatterColor","scatterOpacity","getScatterPaths","getScatterPathTrailMark","getPathWidth","hasSignalByName","legendName","includeHiddenSeries","getHighlightSignalUpdateExpression","hoveredSeriesExpression","getLegendLabelsSeriesSignal","getGenericUpdateSignal","datumOrder","excludeDataKeysCondition","highlightedSeriesSignal","cur","ROUNDED_SQUARE_PATH","date","DATE_PATH","sentimentNegative","SENTIMENT_NEGATIVE_PATH","sentimentNeutral","SENTIMENT_NEUTRAL_PATH","sentimentPositive","SENTIMENT_POSITIVE_PATH","baseData","chartOptions","baseSpec","autosize","contains","resize","background","mergeValuesIntoData","dataset","datasetValues","getD3FormatSpecifierFromNumberFormat","datumProperty","DEFAULT_TITLE_FONT_WEIGHT","anchor","frame","getAggregateTransform","method","trendlineDimension","trendlineMetric","isHighResolutionData","operations","average","median","TRENDLINE_VALUE","getRegressionTransform","trendlineOptions","dimensionExtent","isDimensionNormalized","regressionMethod","getPolynomialOrder","params","extent","getRegressionExtent","getWindowTransform","frameWidth","parseInt","split","getNormalizedDimensionTransform","MS_PER_DAY","getRegressionExtentTransform","getSortTransform","getTrendlineDimensionRangeTransforms","dimensionRange","filterExpressions","getTrendlineParamFormulaTransforms","isPolynomialMethod","getTrendlineParamLookupTransform","getTrendlineData","addTableDataTransforms","getTrendlines","concatenatedTrendlineData","isRegressionMethod","getRegressionTrendlineData","isAggregateMethod","getAggregateTrendlineData","isWindowMethod","getWindowTrendlineData","getTrendlineDisplayOnHoverData","getHighlightTrendlineData","dimensionRangeTransforms","getExcludeDataKeyTransforms","getTrendlineStatisticalTransforms","standardTrendlineDimension","getTrendlineDimensionMetric","standardTrendlinDimension","trendlineName","getTrendlineRuleMark","getDataSourceName","getTrendlineLineMark","getTrendlineAnnotationMarks","getTrendlineHoverMarks","highlightRawPoint","trendlineColor","getRuleYEncodings","getRuleXEncodings","getLineMarkOptions","getStartDimensionExtentProductionRule","getEndDimensionExtentProductionRule","startDimensionExtent","endDimensionExtent","getLineYProductionRule","getLineXProductionRule","trendlineHoverOptions","flat","override","getTrendlineColorFromMarkOptions","getTrendlineLineTypeFromMarkOptions","hasTrendlineWithNormalizedDimension","applyTrendlinePropDefaults","trendlineAnnotations","opts","getTrendlineScaleType","normalizeTrendlineDimensionName","isNormalized","extentName","trendlineOrientation","getTrendlineAnnotationSpecOptions","badge","dimensionValue","prefix","trendlineDimensionExtent","trendlineDimensionScaleType","trendlineWidth","getTrendlineAnnotations","getTrendlineAnnotationPoints","getTrendlineAnnotationTextMark","getTrendlineAnnotationBadgeMark","getTrendlineAnnotationPointX","getTrendlineAnnotationPointY","textPrefix","getTextFill","avoidMarks","getColorKey","colorString","textColors","GROUP_DATA","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__"],"sourceRoot":""}