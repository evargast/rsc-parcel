import { AreaEncodeEntry, ArrayValueRef, ColorValueRef, EncodeEntry, GroupMark, NumericValueRef, PathMark, SignalRef, SymbolMark } from 'vega';
import { LineMarkOptions } from '../line/lineUtils';
import { BarSpecOptions, ChartPopoverOptions, ChartTooltipOptions, ColorFacet, ColorScheme, DonutSpecOptions, DualFacet, HighlightedItem, LineTypeFacet, LineWidthFacet, MetricRangeOptions, OpacityFacet, ProductionRuleTests, ScaleType, ScatterSpecOptions, SymbolSizeFacet, TrendlineOptions } from '../types';
/**
 * If a popover or hasOnClick exists on the mark, then set the cursor to a pointer.
 * @param chartPopovers
 * @param hasOnClick
 * @returns cursor encoding
 */
export declare const getCursor: (chartPopovers: ChartPopoverOptions[], hasOnClick?: boolean) => EncodeEntry['cursor'];
/**
 * If a tooltip exists on the mark, then set tooltip to true.
 */
export declare function getTooltip(chartTooltips: ChartTooltipOptions[], name: string, nestedDatum?: boolean): ProductionRuleTests<SignalRef> | SignalRef | undefined;
/**
 * returns the border stroke encodings for stacked bar/area
 */
export declare const getBorderStrokeEncodings: (isStacked: boolean, isArea?: boolean) => AreaEncodeEntry;
/**
 * Checks if there are any tooltips or popovers on the mark
 * @param children
 * @returns
 */
export declare const isInteractive: (options: {
    chartPopovers?: ChartPopoverOptions[];
    chartTooltips?: ChartTooltipOptions[];
    hasOnClick?: boolean;
    metricRanges?: MetricRangeOptions[];
    trendlines?: TrendlineOptions[];
}) => boolean;
export declare const hasPopover: (options: {
    chartPopovers?: ChartPopoverOptions[];
}) => boolean;
export declare const hasTooltip: (options: {
    chartTooltips?: ChartTooltipOptions[];
}) => boolean;
/**
 * Gets the color encoding
 * @param color
 * @param colorScheme
 * @param colorScaleType
 * @returns ColorValueRef
 */
export declare const getColorProductionRule: (color: ColorFacet | DualFacet, colorScheme: ColorScheme, colorScaleType?: 'linear' | 'ordinal') => ColorValueRef;
/**
 * gets the color encoding in a signal string format
 * @param color
 * @param colorScheme
 * @param colorScaleType
 * @returns string
 */
export declare const getColorProductionRuleSignalString: (color: ColorFacet | DualFacet, colorScheme: ColorScheme, colorScaleType?: 'linear' | 'ordinal') => string;
export declare const getLineWidthProductionRule: (lineWidth: LineWidthFacet | DualFacet | undefined) => NumericValueRef | undefined;
export declare const getOpacityProductionRule: (opacity: OpacityFacet | DualFacet) => {
    signal: string;
} | {
    value: number;
};
export declare const getSymbolSizeProductionRule: (symbolSize: SymbolSizeFacet) => NumericValueRef;
export declare const getStrokeDashProductionRule: (lineType: LineTypeFacet | DualFacet) => ArrayValueRef;
export declare const getHighlightOpacityValue: (opacityValue?: {
    signal: string;
} | {
    value: number;
}) => NumericValueRef;
/**
 * gets the correct x encoding for marks that support scaleType
 * @param scaleType
 * @param dimension
 * @returns x encoding
 */
export declare const getXProductionRule: (scaleType: ScaleType, dimension: string) => NumericValueRef;
/**
 * Gets the y encoding for marks
 * @param metricAxis
 * @param metric
 * @returns y encoding
 */
export declare const getYProductionRule: (metricAxis: string | undefined, metric: string) => NumericValueRef;
/**
 * Gets the points used for the voronoi calculation
 * @param dataSource the name of the data source that will be used in the voronoi calculation
 * @param dimension the dimension for the x encoding
 * @param metric the metric for the y encoding
 * @param name the name of the component the voronoi is associated with, i.e. `scatter0`
 * @param scaleType the scale type for the x encoding
 * @returns SymbolMark
 */
export declare const getPointsForVoronoi: (dataSource: string, dimension: string, metric: string, name: string, scaleType: ScaleType, metricAxis?: string) => SymbolMark;
/**
 * Gets the voronoi path used for tooltips and popovers
 * @param markOptions
 * @param dataSource name of the point data source the voronoi is based on
 * @returns PathMark
 */
export declare const getVoronoiPath: (markOptions: LineMarkOptions | ScatterSpecOptions, dataSource: string) => PathMark;
/**
 * Gets the hover area for the mark
 * @param chartTooltips
 * @param dataSource the name of the data source that will be used in the hover area calculation
 * @param dimension the dimension for the x encoding
 * @param metric the metric for the y encoding
 * @param name the name of the component the hover area is associated with, i.e. `scatter0`
 * @param scaleType the scale type for the x encoding
 * @returns GroupMark
 */
export declare const getItemHoverArea: (chartTooltips: ChartTooltipOptions[], dataSource: string, dimension: string, metric: string, name: string, scaleType: ScaleType, metricAxis?: string) => GroupMark;
export declare const getHoverMarkName: (name: string, index: number) => string;
export declare const getHoverSizes: () => number[];
export declare const getHoverMarkNames: (markName: string) => string[];
/**
 * Gets the opacity for the mark (used to highlight marks).
 * This will take into account if there are any tooltips or popovers on the mark.
 * @param options
 * @returns
 */
export declare const getMarkOpacity: (options: BarSpecOptions | DonutSpecOptions) => ({
    test?: string;
} & NumericValueRef)[];
export declare const getInteractiveMarkName: (options: {
    chartPopovers?: ChartPopoverOptions[];
    chartTooltips?: ChartTooltipOptions[];
    hasOnClick?: boolean;
    highlightedItem?: HighlightedItem;
    metricRanges?: MetricRangeOptions[];
    trendlines?: TrendlineOptions[];
}, name: string) => string | undefined;
//# sourceMappingURL=markUtils.d.ts.map