import { Data, Legend, Signal, Spec } from 'vega';
import { ColorFacet, ColorScheme, FacetRef, LegendOptions, LegendSpecOptions, LineTypeFacet, LineWidthFacet, SymbolShapeFacet } from '../types';
import { Facet } from './legendUtils';
export declare const addLegend: (state: Spec, args_0: LegendOptions & {
    colorScheme?: ColorScheme | undefined;
    index?: number | undefined;
    hiddenSeries?: string[] | undefined;
    highlightedSeries?: string | number | undefined;
}) => Spec;
/**
 * converts facets that could reference preset values to the actual vega supported value
 * Example {value: 'L'} => {value: 3}
 * @param color
 * @param lineType
 * @param lineWidth
 * @param colorScheme
 */
export declare const formatFacetRefsWithPresets: (color: ColorFacet | undefined, lineType: LineTypeFacet | undefined, lineWidth: LineWidthFacet | undefined, symbolShape: SymbolShapeFacet | undefined, colorScheme: ColorScheme) => {
    formattedColor: FacetRef<string> | undefined;
    formattedLineType: FacetRef<number[]> | undefined;
    formattedLineWidth: FacetRef<number> | undefined;
    formattedSymbolShape: FacetRef<string> | undefined;
};
/**
 * gets the legend for a continuous facet
 * currently just setup to handle symbolSize since that is the only supported continuous facet
 * @param _facet
 * @param options
 * @returns
 */
export declare const getContinuousLegend: (facet: Facet, options: LegendSpecOptions) => Legend;
/**
 * Adds a new data set that aggregates the data off of the facet fields
 * This creates a row for every unique combination of the facets in the data
 * Each unique combination gets joined with a pipe to create a single string to use as legend entries
 */
export declare const addData: (state: Data[], args_0: LegendSpecOptions & {
    facets: string[];
}) => Data[];
export declare const addSignals: (state: Signal[], args_0: LegendSpecOptions) => Signal[];
//# sourceMappingURL=legendSpecBuilder.d.ts.map